diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/configs/tango2_defconfig linux-2.6.22.19/arch/mips/configs/tango2_defconfig
--- linux-2.6.22.19.ref/arch/mips/configs/tango2_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/configs/tango2_defconfig	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,1102 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Tue Mar  6 10:24:42 2007
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+CONFIG_TANGO2=y
+# CONFIG_TANGO3 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_TANGO2_SMP863X=y
+# CONFIG_TANGO2_ES1 is not set
+# CONFIG_TANGO2_ES2 is not set
+# CONFIG_TANGO2_ES3 is not set
+# CONFIG_TANGO2_ES4 is not set
+# CONFIG_TANGO2_ES5 is not set
+CONFIG_TANGO2_ES6=y
+
+#
+# 
+#
+CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
+# CONFIG_TANGOX_IGNORE_CMDLINE is not set
+# CONFIG_TANGOX_PROM_CONSOLE is not set
+# CONFIG_TANGOX_FIXED_FREQUENCIES is not set
+# CONFIG_TANGOX_UART_USE_SYSCLK is not set
+CONFIG_TANGOX_USE_TLB_REMAP_DRAM1=y
+
+#
+# 
+#
+CONFIG_TANGOX_XENV_READ=y
+# CONFIG_TANGOX_XENV_DUMP is not set
+CONFIG_TANGOX_XENV_READ_SAFE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_TANGOX=y
+CONFIG_DMA_TANGOX=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_OWN_DMA=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
+CONFIG_MIPS_L1_CACHE_SHIFT=4
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+CONFIG_CPU_MIPS32_R2=y
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE="/tmp/CR/CR-26/"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_SHMEM is not set
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=y
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+# CONFIG_SD_CDROM_MAXIMUM_SECTOR_RESTRICTION is not set
+CONFIG_SD_CDROM_WAIT=y
+CONFIG_SD_CDROM_WAIT_TIME=5
+CONFIG_SD_CDROM_KEEP_DMA=y
+CONFIG_SD_CDROM_DMAPACKET=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_TANGO2_ENET=y
+# CONFIG_TANGO2_ENET_OLD is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_TANGOX_IR=m
+CONFIG_TANGOX_FIP=m
+CONFIG_TANGOX_FIP_REF1=y
+# CONFIG_TANGOX_FIP_REF2 is not set
+CONFIG_TANGOX_SCARD=m
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_BANDWIDTH=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_TANGOX_EHCI_HCD=m
+CONFIG_TANGOX_OHCI_HCD=m
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS0"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/configs/tango3_defconfig linux-2.6.22.19/arch/mips/configs/tango3_defconfig
--- linux-2.6.22.19.ref/arch/mips/configs/tango3_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/configs/tango3_defconfig	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,1096 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Mon Oct 23 14:23:16 2006
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANGO2 is not set
+CONFIG_TANGO3=y
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_TANGO3_SMP86XX=y
+CONFIG_TANGO3_865X=y
+
+#
+# 
+#
+# CONFIG_TANGO3_DISABLE_HWFPU is not set
+CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
+# CONFIG_TANGOX_IGNORE_CMDLINE is not set
+# CONFIG_TANGOX_PROM_CONSOLE is not set
+# CONFIG_TANGOX_FIXED_FREQUENCIES is not set
+# CONFIG_TANGOX_UART_USE_SYSCLK is not set
+
+#
+# 
+#
+CONFIG_TANGOX_XENV_READ=y
+# CONFIG_TANGOX_XENV_DUMP is not set
+CONFIG_TANGOX_XENV_READ_SAFE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_TANGOX=y
+CONFIG_DMA_TANGOX=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_OWN_DMA=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+CONFIG_CPU_MIPS32_R2=y
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE="/tmp/CR/CR-26/"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_SHMEM is not set
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=y
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+CONFIG_SD_CDROM_WAIT=y
+CONFIG_SD_CDROM_WAIT_TIME=5
+CONFIG_SD_CDROM_KEEP_DMA=y
+CONFIG_SD_CDROM_DMAPACKET=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_TANGO2_ENET is not set
+# CONFIG_TANGO2_ENET_OLD is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_TANGOX_IR=m
+CONFIG_TANGOX_FIP=m
+CONFIG_TANGOX_FIP_REF1=y
+# CONFIG_TANGOX_FIP_REF2 is not set
+CONFIG_TANGOX_SCARD=m
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_BANDWIDTH=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_TANGOX_EHCI_HCD=m
+CONFIG_TANGOX_OHCI_HCD=m
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS0"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/Kconfig linux-2.6.22.19/arch/mips/Kconfig
--- linux-2.6.22.19.ref/arch/mips/Kconfig	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/Kconfig	2009-04-24 10:51:33.000000000 -0700
@@ -606,6 +606,48 @@
 	  Technology and now in turn merged with Fujitsu.  Say Y here to
 	  support this machine type.
 
+config TANGO2
+	bool "Support for SigmaDesigns Tango2 board"
+	select TANGOX
+	select TANGO2_SMP863X
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+#	select SYS_HAS_EARLY_PRINTK
+	select IRQ_CPU
+#	select OWN_DMA
+	select ZONE_DMA
+	select DMA_TANGOX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SD_IPFILTER
+	help
+	  Add support for Sigma Designs SMP863x board. Say Y here to
+	  support this machine type.
+
+config TANGO3
+	bool "Support for SigmaDesigns Tango3 board"
+	select TANGOX
+	select TANGO3_SMP86XX
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+#	select SYS_HAS_EARLY_PRINTK
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select IRQ_CPU
+#	select OWN_DMA
+	select ZONE_DMA
+	select DMA_TANGOX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SD_IPFILTER
+	help
+	  Add support for Sigma Designs SMP864x/SMP865x board. Say Y here to
+	  support this machine type.
+
 config TOSHIBA_JMR3927
 	bool "Toshiba JMR-TX3927 board"
 	select DMA_NONCOHERENT
@@ -665,6 +707,7 @@
 source "arch/mips/pmc-sierra/Kconfig"
 source "arch/mips/sgi-ip27/Kconfig"
 source "arch/mips/sibyte/Kconfig"
+source "arch/mips/tangox/Kconfig"
 source "arch/mips/tx4927/Kconfig"
 source "arch/mips/tx4938/Kconfig"
 source "arch/mips/vr41xx/Kconfig"
@@ -730,6 +773,16 @@
 	bool
 	select DMA_NEED_PCI_MAP_STATE
 
+config TANGOX
+	bool 
+
+config DMA_TANGOX
+	bool
+	select DMA_NEED_PCI_MAP_STATE
+
+config SD_IPFILTER
+	bool
+
 config DMA_NONCOHERENT
 	bool
 	select DMA_NEED_PCI_MAP_STATE
@@ -900,6 +953,8 @@
 config MIPS_L1_CACHE_SHIFT
 	int
 	default "4" if MACH_DECSTATION || SNI_RM
+        default "4" if TANGO2
+        default "5" if TANGO3
 	default "7" if SGI_IP27
 	default "5"
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/cpu-probe.c linux-2.6.22.19/arch/mips/kernel/cpu-probe.c
--- linux-2.6.22.19.ref/arch/mips/kernel/cpu-probe.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/cpu-probe.c	2009-04-24 10:51:33.000000000 -0700
@@ -575,7 +575,9 @@
 	if (config1 & MIPS_CONF1_EP)
 		c->options |= MIPS_CPU_EJTAG;
 	if (config1 & MIPS_CONF1_FP) {
+#ifndef CONFIG_TANGO3_DISABLE_HWFPU
 		c->options |= MIPS_CPU_FPU;
+#endif
 		c->options |= MIPS_CPU_32FPR;
 	}
 	if (cpu_has_tlb)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/head.S linux-2.6.22.19/arch/mips/kernel/head.S
--- linux-2.6.22.19.ref/arch/mips/kernel/head.S	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/head.S	2009-04-24 10:51:33.000000000 -0700
@@ -129,23 +129,47 @@
 #endif
 	.endm
 
+#if defined(CONFIG_TANGOX) 
+	/*
+	 * Give us a fighting chance of running if execution beings at the
+	 * kernel load address.  This is needed because this platform does
+	 * not have a ELF loader yet.
+	 */
+	j	kernel_entry
+	nop
+
+	/*
+	 * Reserved space for exception handlers.
+	 * Necessary for machines which link their kernels at KSEG0.
+	 */
+	.fill	0x400-0x8
+#else
 	/*
 	 * Reserved space for exception handlers.
 	 * Necessary for machines which link their kernels at KSEG0.
 	 */
 	.fill	0x400
+#endif
+
+#if defined(CONFIG_TANGO3)
+	/* Creating some buffer for power management purpose */
+	/* Mark 16KB off the starting point */
+	.org	0x4000
+#endif
 
 EXPORT(stext)					# used for profiling
 EXPORT(_stext)
 
-#ifdef CONFIG_MIPS_SIM
+#if defined(CONFIG_MIPS_SIM) 
 	/*
 	 * Give us a fighting chance of running if execution beings at the
 	 * kernel load address.  This is needed because this platform does
 	 * not have a ELF loader yet.
 	 */
 	j	kernel_entry
+	nop
 #endif
+
 	__INIT
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/proc.c linux-2.6.22.19/arch/mips/kernel/proc.c
--- linux-2.6.22.19.ref/arch/mips/kernel/proc.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/proc.c	2009-04-24 10:51:33.000000000 -0700
@@ -112,9 +112,15 @@
 	                            cpu_data[n].cputype : CPU_UNKNOWN],
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+#ifdef CONFIG_TANGOX
+	seq_printf(m, "Initial BogoMIPS\t: %lu.%02lu\n",
+	              cpu_data[n].udelay_val / (500000/HZ),
+	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+#else
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
 	              cpu_data[n].udelay_val / (500000/HZ),
 	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+#endif
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
@@ -140,6 +146,16 @@
 	seq_printf(m, fmt, 'I', vcei_count);
 	seq_printf(m, "\n");
 
+#ifdef CONFIG_TANGOX
+	{
+		extern unsigned long tangox_get_cpuclock(void);
+		extern unsigned long tangox_get_sysclock(void);
+		extern unsigned long tangox_get_dspclock(void);
+		seq_printf(m, "System bus frequency\t: %ld Hz\n", tangox_get_sysclock());
+		seq_printf(m, "CPU frequency\t\t: %ld Hz\n", tangox_get_cpuclock());
+		seq_printf(m, "DSP frequency\t\t: %ld Hz\n", tangox_get_dspclock());
+	}
+#endif
 	return 0;
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/setup.c linux-2.6.22.19/arch/mips/kernel/setup.c
--- linux-2.6.22.19.ref/arch/mips/kernel/setup.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/setup.c	2009-04-24 10:51:33.000000000 -0700
@@ -9,6 +9,7 @@
  * Copyright (C) 1996 Stoned Elipot
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2000 2001, 2002  Maciej W. Rozycki
+ * Copyright (C) 2003-2007 Sigma Designs, Inc.
  */
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -29,6 +30,21 @@
 #include <asm/setup.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/memcfg.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/memcfg.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/hardware.h>
+
+#include "../tangox/xenv.h"
+#include "../tangox/xenvkeys.h"
+#endif
+
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
@@ -73,6 +89,8 @@
  */
 unsigned long isa_slot_offset;
 EXPORT_SYMBOL(isa_slot_offset);
+	
+extern void * __rd_start, * __rd_end;
 
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
@@ -168,6 +186,10 @@
 	unsigned long end;
 	u32 *initrd_header;
 
+	if ((!initrd_start) && (&__rd_start != &__rd_end)) {
+        	initrd_start = (unsigned long)&__rd_start;
+	        initrd_end = (unsigned long)&__rd_end;
+	}
 	/*
 	 * Board specific code or command line parser should have
 	 * already set up initrd_start and initrd_end. In these cases
@@ -232,8 +254,6 @@
 	}
 
 	reserve_bootmem(__pa(initrd_start), size);
-	initrd_below_start_ok = 1;
-
 	printk(KERN_INFO "Initial ramdisk at: 0x%lx (%lu bytes)\n",
 	       initrd_start, size);
 	return;
@@ -421,6 +441,16 @@
 static int __init early_parse_mem(char *p)
 {
 	unsigned long start, size;
+#ifdef CONFIG_TANGOX
+        extern unsigned long em8xxx_kmem_start;
+        extern unsigned long em8xxx_kmem_size;
+#ifdef CONFIG_TANGO3
+	extern unsigned long max_remap_size;
+	extern unsigned long phy_remap;
+	extern unsigned long em8xxx_max_dx_size;
+	void update_lrrw_kend(unsigned long kend);
+#endif
+#endif
 
 	/*
 	 * If a user specifies memory size, we
@@ -435,8 +465,72 @@
 	size = memparse(p, &p);
 	if (*p == '@')
 		start = memparse(p + 1, &p);
+	else {
+#ifdef CONFIG_TANGOX
+		start = CPHYSADDR(em8xxx_kmem_start);
+#else
+		start = 0;
+#endif
+        }
+
 
+#ifdef CONFIG_TANGOX
+	if (start == CPHYSADDR(em8xxx_kmem_start)) {
+		unsigned long em8xxx_kmem_end;
+#ifdef CONFIG_TANGO3
+#define REMAP_IDX      (((CPU_REMAP_SPACE-CPU_remap2_address)/0x04000000)+2)
+#define MAX_KERNEL_MEMSIZE	(0x18000000-(((REMAP_IDX)-2)*0x04000000))
+		em8xxx_kmem_size = ((size + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+
+		if (em8xxx_kmem_size > max_remap_size) {
+			if (em8xxx_kmem_size > 0x18000000) /* Maximum 384MB */
+				em8xxx_kmem_size = max_remap_size;
+			else {
+				int i, remap_cnt = (max_remap_size / 0x04000000); /* 64MB per remap */
+				unsigned long newaddr = phy_remap + max_remap_size;
+				for (i = REMAP_IDX + remap_cnt; i < 8; i++) {
+					gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + i * 4, newaddr);
+					iob();
+					max_remap_size += 0x04000000;
+					if (em8xxx_kmem_size <= max_remap_size)
+						break;
+					newaddr += 0x04000000;
+				}
+				if (em8xxx_kmem_size > max_remap_size)
+					em8xxx_kmem_size = max_remap_size;
+				printk("Modified physical map 0x%08lx to 0x%08lx, max remap/kernel size: 0x%08lx/0x%08lx.\n",
+						phy_remap, (unsigned long)CPU_REMAP_SPACE, max_remap_size, (unsigned long)MAX_KERNEL_MEMSIZE);
+			}
+		}
+
+#ifdef CONFIG_TANGOX_XENV_READ
+		if ((em8xxx_max_dx_size != 0) && (em8xxx_kmem_size > em8xxx_max_dx_size)) { /* don't push into RUAMM area */
+			em8xxx_kmem_size = em8xxx_max_dx_size;
+			printk("Maximum kernel memory size is 0x%08lx with RUAMM restriction.\n", em8xxx_kmem_size);
+		}
+#endif
+		em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(CPU_REMAP_SPACE);
+
+		/* Update information into LR_XENV2_RW */
+		update_lrrw_kend(em8xxx_kmem_end);
+		add_memory_region(start, em8xxx_kmem_size, BOOT_MEM_RAM);
+#else
+		memcfg_t *m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+
+		em8xxx_kmem_size = ((size + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+		add_memory_region(start, em8xxx_kmem_size, BOOT_MEM_RAM);
+
+		em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(MEM_BASE_dram_controller_0_alias);
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+#endif
+	} else {
+		/* We just add this blindly as the alignment can be wrong, use it as own risk */
+		add_memory_region(start, size, BOOT_MEM_RAM);
+	}
+#else
 	add_memory_region(start, size, BOOT_MEM_RAM);
+#endif
 	return 0;
 }
 early_param("mem", early_parse_mem);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/time.c linux-2.6.22.19/arch/mips/kernel/time.c
--- linux-2.6.22.19.ref/arch/mips/kernel/time.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/time.c	2009-04-24 10:51:33.000000000 -0700
@@ -2,6 +2,7 @@
  * Copyright 2001 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
  * Copyright (c) 2003, 2004  Maciej W. Rozycki
+ * Copyright (C) 2003-2007 Sigma Designs, Inc.
  *
  * Common time service routines for MIPS machines. See
  * Documentation/mips/time.README.
@@ -32,6 +33,29 @@
 #include <asm/div64.h>
 #include <asm/sections.h>
 #include <asm/time.h>
+   
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#endif
+
+#ifdef CONFIG_TANGOX
+void reset_timer(unsigned long cpu, unsigned long sys, unsigned long pll, unsigned long premux, unsigned long mux);
+extern unsigned long tangox_get_cpuclock(void);
+extern unsigned long tangox_get_sysclock(void);
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+extern unsigned long em8xxx_sys_clkgen_pll;
+extern unsigned long em8xxx_sys_premux;
+extern unsigned long em8xxx_sys_mux;
+#endif
 
 /*
  * The integer part of the number of usecs per jiffy is taken from tick,
@@ -139,7 +163,9 @@
  */
 void local_timer_interrupt(int irq, void *dev_id)
 {
+#ifdef CONFIG_PROFILING
 	profile_tick(CPU_PROFILING);
+#endif
 	update_process_times(user_mode(get_irq_regs()));
 }
 
@@ -149,6 +175,30 @@
  */
 irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
+
+#ifdef CONFIG_TANGOX
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	unsigned long clkgen_pll = gbus_read_reg32(REG_BASE_system_block + SYS_clkgen_pll);
+	unsigned long premux = gbus_read_reg32(REG_BASE_system_block + SYS_sysclk_premux) & 0x3;
+	unsigned long mux = gbus_read_reg32(REG_BASE_system_block + SYS_sysclk_mux) & 0xf1;
+#endif
+
+        if ((jiffies % HZ) == 0) { /* Update CPU heart beat conunter per second */
+                gbus_write_reg32(REG_BASE_cpu_block + LR_HB_CPU,
+                                gbus_read_reg32(REG_BASE_cpu_block + LR_HB_CPU) + 1);
+#if defined(CONFIG_PRINTK_TIME)
+//		printk("*** time marker ***\n");
+#endif
+	}
+
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	if ((em8xxx_sys_clkgen_pll != clkgen_pll) || (em8xxx_sys_premux != premux) || (em8xxx_sys_mux != mux)) {
+		/* Detected potential CPU/System frequency change */
+		reset_timer(tangox_get_cpuclock(), tangox_get_sysclock(), clkgen_pll, premux, mux);
+        }
+#endif
+#endif
+
 	write_seqlock(&xtime_lock);
 
 	mips_timer_ack();
@@ -333,6 +383,7 @@
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
+#ifdef CONFIG_TANGOX_USE_CPU_CLOCK
 static void __init init_mips_clocksource(void)
 {
 	u64 temp;
@@ -355,6 +406,7 @@
 
 	clocksource_register(&clocksource_mips);
 }
+#endif
 
 void __init time_init(void)
 {
@@ -371,14 +423,15 @@
 	                        -xtime.tv_sec, -xtime.tv_nsec);
 
 	/* Choose appropriate high precision timer routines.  */
-	if (!cpu_has_counter && !clocksource_mips.read)
+	if (!cpu_has_counter && !clocksource_mips.read) {
 		/* No high precision timer -- sorry.  */
 		clocksource_mips.read = null_hpt_read;
-	else if (!mips_hpt_frequency && !mips_timer_state) {
+	} else if (!mips_hpt_frequency && !mips_timer_state) {
 		/* A high precision timer of unknown frequency.  */
-		if (!clocksource_mips.read)
+		if (!clocksource_mips.read) {
 			/* No external high precision timer -- use R4k.  */
 			clocksource_mips.read = c0_hpt_read;
+		}
 	} else {
 		/* We know counter frequency.  Or we can get it.  */
 		if (!clocksource_mips.read) {
@@ -398,8 +451,10 @@
 				c0_hpt_timer_init();
 			}
 		}
-		if (!mips_hpt_frequency)
+
+		if (!mips_hpt_frequency) {
 			mips_hpt_frequency = calibrate_hpt();
+		}
 
 		/* Report the high precision timer rate for a reference.  */
 		printk("Using %u.%03u MHz high precision timer.\n",
@@ -424,7 +479,9 @@
 	 */
 	plat_timer_setup(&timer_irqaction);
 
+#ifdef CONFIG_TANGOX_USE_CPU_CLOCK
 	init_mips_clocksource();
+#endif
 }
 
 #define FEBRUARY		2
@@ -478,3 +535,25 @@
 EXPORT_SYMBOL(to_tm);
 EXPORT_SYMBOL(rtc_mips_set_time);
 EXPORT_SYMBOL(rtc_mips_get_time);
+
+#if defined(CONFIG_TANGOX) 
+/* Called after PLL has been reset */
+void reset_timer(unsigned long cpuf, unsigned long sysf, unsigned long pll, unsigned long premux, unsigned long mux)
+{
+	em8xxx_sys_clkgen_pll = pll;
+	em8xxx_sys_premux = premux;
+	em8xxx_sys_mux = mux;
+        em8xxx_cpu_frequency = cpuf;
+        em8xxx_sys_frequency = sysf;
+
+        mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+        cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
+
+        /* Report the high precision timer rate for a reference.  */
+        printk("Using %u.%03u MHz high precision timer.\n",
+                        ((mips_hpt_frequency + 500) / 1000) / 1000,
+                        ((mips_hpt_frequency + 500) / 1000) % 1000);
+}
+EXPORT_SYMBOL(reset_timer);
+#endif /* CONFIG_TANGOX */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/traps.c linux-2.6.22.19/arch/mips/kernel/traps.c
--- linux-2.6.22.19.ref/arch/mips/kernel/traps.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/traps.c	2009-04-24 10:51:33.000000000 -0700
@@ -43,6 +43,16 @@
 #include <asm/types.h>
 #include <asm/stacktrace.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango3/hardware.h>
+#endif
+
 extern asmlinkage void handle_int(void);
 extern asmlinkage void handle_tlbm(void);
 extern asmlinkage void handle_tlbl(void);
@@ -1282,6 +1292,8 @@
 	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
+	write_c0_ebase(ebase);
+
 #ifdef CONFIG_CPU_MIPSR2
 	if (cpu_has_mips_r2) {
 		unsigned int enable = 0x0000000f;
@@ -1372,7 +1384,6 @@
 #ifdef CONFIG_64BIT
 	unsigned long uncached_ebase = TO_UNCAC(ebase);
 #endif
-
 	memcpy((void *)(uncached_ebase + offset), addr, size);
 }
 
@@ -1394,7 +1405,15 @@
 	if (cpu_has_veic || cpu_has_vint)
 		ebase = (unsigned long) alloc_bootmem_low_pages (0x200 + VECTORSPACING*64);
 	else
+#ifdef CONFIG_TANGOX
+#ifdef CONFIG_TANGO3
+		ebase = KSEG0ADDR(CPU_REMAP_SPACE);
+#else
+		ebase = KSEG0ADDR(MEM_BASE_dram_controller_0_alias + FM_RESERVED);
+#endif
+#else
 		ebase = CAC_BASE;
+#endif
 
 	per_cpu_trap_init();
 
@@ -1502,11 +1521,11 @@
 
 	if (cpu_has_vce)
 		/* Special exception: R4[04]00 uses also the divec space. */
-		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
+		memcpy((void *)(ebase + 0x180), &except_vec3_r4000, 0x100);
 	else if (cpu_has_4kex)
-		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
+		memcpy((void *)(ebase + 0x180), &except_vec3_generic, 0x80);
 	else
-		memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
+		memcpy((void *)(ebase + 0x080), &except_vec3_generic, 0x80);
 
 	signal_init();
 #ifdef CONFIG_MIPS32_COMPAT
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/unaligned.c linux-2.6.22.19/arch/mips/kernel/unaligned.c
--- linux-2.6.22.19.ref/arch/mips/kernel/unaligned.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/unaligned.c	2009-04-24 10:51:33.000000000 -0700
@@ -490,7 +490,7 @@
 
 asmlinkage void do_ade(struct pt_regs *regs)
 {
-	unsigned long *regptr, newval;
+	unsigned long *regptr, newval = 0;
 	extern int do_dsemulret(struct pt_regs *);
 	unsigned int __user *pc;
 	mm_segment_t seg;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/kernel/vmlinux.lds.S linux-2.6.22.19/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.22.19.ref/arch/mips/kernel/vmlinux.lds.S	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/kernel/vmlinux.lds.S	2009-04-24 10:51:33.000000000 -0700
@@ -66,6 +66,13 @@
 
     DATA_DATA
 
+    /* Align the initial ramdisk image (INITRD) on page boundaries. */
+    . = ALIGN(4096);
+    __rd_start = .;
+    *(.initrd)
+    . = ALIGN(4096);
+    __rd_end = .;
+
     CONSTRUCTORS
   }
   _gp = . + 0x8000;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/lib-32/dump_tlb.c linux-2.6.22.19/arch/mips/lib-32/dump_tlb.c
--- linux-2.6.22.19.ref/arch/mips/lib-32/dump_tlb.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/lib-32/dump_tlb.c	2009-04-24 10:51:33.000000000 -0700
@@ -40,6 +40,7 @@
 		return "256Mb";
 #endif
 	}
+	return "unknown";
 }
 
 #define BARRIER()					\
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/Makefile linux-2.6.22.19/arch/mips/Makefile
--- linux-2.6.22.19.ref/arch/mips/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -589,6 +589,106 @@
 core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/tx4938/common/
 load-$(CONFIG_TOSHIBA_RBTX4938) += 0xffffffff80100000
 
+ifdef CONFIG_TANGO2
+#
+# Tango2 board
+#
+include include/asm-mips/tango2/emhwlib_registers_tango2.inc
+include include/asm-mips/tango2/emhwlib_dram_tango2.inc
+else
+ifdef CONFIG_TANGO3
+#
+# Tango3 board
+#
+include include/asm-mips/tango3/emhwlib_registers_tango3.inc
+include include/asm-mips/tango3/emhwlib_dram_tango3.inc
+endif
+endif
+
+ifneq ($(XSDK_DEFAULT_CPU_CERTID),)
+CERT_ID=$(XSDK_DEFAULT_CPU_CERTID)
+endif
+
+ifneq ($(XSDK_DEFAULT_KEY_DOMAIN),)
+CERT_TYPE=$(XSDK_DEFAULT_KEY_DOMAIN)
+endif
+
+ifneq ($(CERT_TYPE),)
+ifneq ($(CERT_ID),)
+CERT_SET=y
+endif
+endif
+
+ifneq ($(CERT_SET),y)
+ifdef CONFIG_TANGO2
+ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+CERT_ID=000c
+CERT_TYPE=8634_ES4_prod
+else
+CERT_ID=000b
+CERT_TYPE=8634_ES4_dev
+endif
+else
+ifdef CONFIG_TANGO3
+# Use 0001 for encrypted image (instead of signed-only image) 
+ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+CERT_ID=000f
+CERT_TYPE=8644_ES1_prod
+else
+CERT_ID=000f
+CERT_TYPE=8644_ES1_dev
+endif
+endif
+endif
+endif
+
+internal_hex = 0x$(shell printf "%x" $$(($(1))))
+
+core-$(CONFIG_TANGOX)		+= arch/mips/tangox/
+
+ifdef CONFIG_TANGO2
+cflags-$(CONFIG_TANGO2)		+= -Iinclude/asm-mips/mach-tango2
+load-$(CONFIG_TANGO2)		:= $(call internal_hex,0x80000000+	\
+					$(MEM_BASE_dram_controller_0_alias)+	\
+					$(FM_linuxmips__ftext))
+#ifdef RMCFLAGS
+#cflags-$(CONFIG_TANGO2)		+= $(RMCFLAGS)
+#else
+cflags-$(CONFIG_TANGO2)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2
+cflags-$(CONFIG_TANGO2_ES4)	+= -DEM86XX_REVISION=4
+cflags-$(CONFIG_TANGO2_ES5)	+= -DEM86XX_REVISION=5
+cflags-$(CONFIG_TANGO2_ES6)	+= -DEM86XX_REVISION=6
+#endif
+else
+ifdef CONFIG_TANGO3
+KERNEL_START_ADDRESS		:= $(CPU_remap2_address)
+cflags-$(CONFIG_TANGO3)		+= -Iinclude/asm-mips/mach-tango3
+load-$(CONFIG_TANGO3)		:= $(call internal_hex,0x80000000+	\
+					$(KERNEL_START_ADDRESS))
+#ifdef RMCFLAGS
+#cflags-$(CONFIG_TANGO3)		+= $(RMCFLAGS)
+#else
+cflags-$(CONFIG_TANGO3)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO3
+cflags-$(CONFIG_TANGO3_865X)	+= -DEM86XX_REVISION=3
+cflags-$(CONFIG_TANGO3_864X)	+= -DEM86XX_REVISION=3
+#endif
+cflags-$(CONFIG_TANGO3)		+= -DCPU_REMAP_SPACE=$(KERNEL_START_ADDRESS) 
+cflags-$(CONFIG_TANGO3_865X)	+= -mtune=24kf
+cflags-$(CONFIG_TANGO3_864X)	+= -mtune=24kf
+endif
+endif
+
+CLEAN_FILES += arch/mips/boot/vmlinux.gz \
+		arch/mips/boot/*.bin \
+		arch/mips/boot/*.xload \
+		arch/mips/boot/*.zbf \
+		arch/mips/boot/zbimage-linux-* 
+
+# ramdisk/initrd support
+# You may need a compressed ramdisk image, named ramdisk.gz in
+# arch/mips/ramdisk
+core-$(CONFIG_EMBEDDED_RAMDISK) += arch/mips/ramdisk/
+
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
@@ -660,7 +760,11 @@
 vmlinux.64: vmlinux
 	$(OBJCOPY) -O $(64bit-bfd) $(OBJCOPYFLAGS) $< $@
 
-makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1)
+ifdef CONFIG_TANGOX
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) loadaddr=$(2) certtype=$(3) certid=$(4)
+else
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) 
+endif
 
 ifdef CONFIG_BOOT_ELF32
 all:	$(vmlinux-32)
@@ -699,6 +803,22 @@
 vmlinux.srec: $(vmlinux-32)
 	+@$(call makeboot,$@)
 
+ifdef CONFIG_TANGO2
+zbimage-linux-xrpc: vmlinux.bin
+	+@$(call makeboot,$@,$(load-y),$(CERT_TYPE),$(CERT_ID))
+
+zbimage-linux-enc: vmlinux.bin
+	+@$(call makeboot,$@,$(load-y),$(CERT_TYPE),$(CERT_ID))
+
+zbimage-linux-encs: vmlinux.bin
+	+@$(call makeboot,$@,$(load-y),$(CERT_TYPE),$(CERT_ID))
+endif
+
+ifdef CONFIG_TANGO3
+zbimage-linux-xload: vmlinux.bin
+	+@$(call makeboot,$@,$(load-y),$(CERT_TYPE),$(CERT_ID))
+endif
+
 CLEAN_FILES += vmlinux.ecoff \
 	       vmlinux.srec
 
@@ -713,8 +833,10 @@
 endif
 
 archclean:
-	@$(MAKE) $(clean)=arch/mips/boot
-	@$(MAKE) $(clean)=arch/mips/lasat
+	$(Q)$(MAKE) $(clean)=arch/mips/boot
+	$(Q)$(MAKE) $(clean)=arch/mips/lasat
+	#@$(MAKE) $(clean)=arch/mips/boot
+	#@$(MAKE) $(clean)=arch/mips/lasat
 
 CLEAN_FILES += vmlinux.32 \
 	       vmlinux.64 \
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/mm/cache.c linux-2.6.22.19/arch/mips/mm/cache.c
--- linux-2.6.22.19.ref/arch/mips/mm/cache.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/mm/cache.c	2009-04-24 10:51:33.000000000 -0700
@@ -27,6 +27,10 @@
 	unsigned long pfn);
 void (*flush_icache_range)(unsigned long start, unsigned long end);
 
+#ifdef CONFIG_TANGOX
+void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
+#endif
+
 /* MIPS specific cache operations */
 void (*flush_cache_sigtramp)(unsigned long addr);
 void (*local_flush_data_cache_page)(void * addr);
@@ -53,6 +57,7 @@
  * We could optimize the case where the cache argument is not BCACHE but
  * that seems very atypical use ...
  */
+//#define FLUSH_FOR_REAL
 asmlinkage int sys_cacheflush(unsigned long addr,
 	unsigned long bytes, unsigned int cache)
 {
@@ -60,12 +65,30 @@
 		return 0;
 	if (!access_ok(VERIFY_WRITE, (void __user *) addr, bytes))
 		return -EFAULT;
-
+	
+#ifdef FLUSH_FOR_REAL
+	if (cache & ICACHE)
+		flush_icache_range(addr, addr + bytes);
+	if (cache & DCACHE) {
+		unsigned long start_addr;
+		for (start_addr = addr; start_addr < (addr + bytes); start_addr += PAGE_SIZE)
+			flush_data_cache_page(start_addr);
+	}
+#else
 	flush_icache_range(addr, addr + bytes);
+#endif
 
 	return 0;
 }
 
+/* write-back and invalidate dcache */
+void flush_dcache_range(void __user *userbuf, unsigned int len)
+{
+	unsigned long start_addr, addr;
+	for (start_addr = addr = (unsigned long)userbuf; addr < (start_addr + len); addr += PAGE_SIZE)
+		flush_data_cache_page(addr);
+}
+
 void __flush_dcache_page(struct page *page)
 {
 	struct address_space *mapping = page_mapping(page);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/mm/c-r4k.c linux-2.6.22.19/arch/mips/mm/c-r4k.c
--- linux-2.6.22.19.ref/arch/mips/mm/c-r4k.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/mm/c-r4k.c	2009-04-24 10:52:43.000000000 -0700
@@ -500,6 +500,14 @@
 	r4k_on_each_cpu(local_r4k_flush_cache_page, &args, 1, 1);
 }
 
+#ifdef CONFIG_TANGOX
+static void r4k_flush_icache_range(unsigned long start, unsigned long end);
+static void r4k_flush_icache_page(struct vm_area_struct *vma, struct page *page)
+{
+	r4k_flush_icache_range((unsigned long)page_address(page), (unsigned long)page_address(page) + PAGE_SIZE);
+}
+#endif
+
 static inline void local_r4k_flush_data_cache_page(void * addr)
 {
 	r4k_blast_dcache_page((unsigned long) addr);
@@ -561,6 +569,8 @@
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
 
+	iob();
+
 	if (cpu_has_inclusive_pcaches) {
 		if (size >= scache_size)
 			r4k_blast_scache();
@@ -934,9 +944,10 @@
 	case CPU_R14000:
 	case CPU_SB1:
 		break;
+	case CPU_74K:
+		c->dcache.flags |= MIPS_CACHE_VTAG;
 	case CPU_24K:
 	case CPU_34K:
-	case CPU_74K:
 		if ((read_c0_config7() & (1 << 16))) {
 			/* effectively physically indexed dcache,
 			   thus no virtual aliases. */
@@ -966,13 +977,16 @@
 		break;
 	}
 
-	printk("Primary instruction cache %ldkB, %s, %s, linesize %d bytes.\n",
-	       icache_size >> 10,
-	       cpu_has_vtag_icache ? "virtually tagged" : "physically tagged",
-	       way_string[c->icache.ways], c->icache.linesz);
-
-	printk("Primary data cache %ldkB, %s, linesize %d bytes.\n",
-	       dcache_size >> 10, way_string[c->dcache.ways], c->dcache.linesz);
+	printk("Primary instruction cache %ldkB, %s, %s tagged, linesize %d bytes.\n",
+	       icache_size >> 10, way_string[c->icache.ways],
+	       cpu_has_vtag_icache ? "virtually" : "physically",
+	       c->icache.linesz);
+
+	printk("Primary data cache %ldkB, %s, %s tagged, %s aliases, linesize %d bytes\n",
+	       dcache_size >> 10, way_string[c->dcache.ways],
+	       (c->dcache.flags & MIPS_CACHE_PINDEX) ? "physically" : "virtually",
+	       (c->dcache.flags & MIPS_CACHE_ALIASES) ? "cache" : "no",
+	       c->dcache.linesz);
 }
 
 /*
@@ -1226,6 +1240,10 @@
 	flush_data_cache_page	= r4k_flush_data_cache_page;
 	flush_icache_range	= r4k_flush_icache_range;
 
+#ifdef CONFIG_TANGOX
+	flush_icache_page	= r4k_flush_icache_page;
+#endif
+
 #ifdef CONFIG_DMA_NONCOHERENT
 	_dma_cache_wback_inv	= r4k_dma_cache_wback_inv;
 	_dma_cache_wback	= r4k_dma_cache_wback_inv;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/mm/init.c linux-2.6.22.19/arch/mips/mm/init.c
--- linux-2.6.22.19.ref/arch/mips/mm/init.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/mm/init.c	2009-04-24 10:51:33.000000000 -0700
@@ -60,6 +60,13 @@
 
 #endif /* CONFIG_MIPS_MT_SMTC */
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#endif
+#ifdef CONFIG_TANGO3
+#include <asm/tango3/hardware.h>
+#endif
+
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
 
 /*
@@ -354,6 +361,13 @@
 	unsigned long zholes_size[MAX_NR_ZONES] = { 0, };
 	unsigned long i, j, pfn;
 #endif
+	unsigned long max_dma_pfn = MAX_DMA_PFN;
+
+#if defined(CONFIG_TANGOX) && defined(CONFIG_PCI)
+	extern unsigned long em8xxx_kmem_start;
+	extern unsigned long em8xxx_kmem_size;
+	extern int tangox_pci_host_enabled(void);
+#endif
 
 	pagetable_init();
 
@@ -362,11 +376,17 @@
 #endif
 	kmap_coherent_init();
 
+#if defined(CONFIG_TANGOX) && defined(CONFIG_PCI)
+	/* If PCI is used, then limit DMA memory to MAX_PCIMEM_MAP_SIZE if kernel memory is > MAX_PCIMEM_MAP_SIZE */
+	if (tangox_pci_host_enabled() && (em8xxx_kmem_size>(MAX_PCIMEM_MAP_SIZE<<20)))
+		max_dma_pfn = PFN_DOWN(virt_to_phys((void *)((em8xxx_kmem_start+(MAX_PCIMEM_MAP_SIZE<<20))&0xfff00000)));
+#endif
+
 #ifdef CONFIG_ZONE_DMA
-	if (min_low_pfn < MAX_DMA_PFN && MAX_DMA_PFN <= max_low_pfn) {
-		zones_size[ZONE_DMA] = MAX_DMA_PFN - min_low_pfn;
-		zones_size[ZONE_NORMAL] = max_low_pfn - MAX_DMA_PFN;
-	} else if (max_low_pfn < MAX_DMA_PFN)
+	if (min_low_pfn < max_dma_pfn && max_dma_pfn <= max_low_pfn) {
+		zones_size[ZONE_DMA] = max_dma_pfn - min_low_pfn;
+		zones_size[ZONE_NORMAL] = max_low_pfn - max_dma_pfn;
+	} else if (max_low_pfn < max_dma_pfn)
 		zones_size[ZONE_DMA] = max_low_pfn - min_low_pfn;
 	else
 #endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/mm/Makefile linux-2.6.22.19/arch/mips/mm/Makefile
--- linux-2.6.22.19.ref/arch/mips/mm/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/mm/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -2,7 +2,7 @@
 # Makefile for the Linux/MIPS-specific parts of the memory manager.
 #
 
-obj-y				+= cache.o dma-default.o extable.o fault.o \
+obj-y				+= cache.o extable.o fault.o \
 				   init.o pgtable.o tlbex.o tlbex-fault.o
 
 obj-$(CONFIG_32BIT)		+= ioremap.o pgtable-32.o
@@ -31,3 +31,8 @@
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
 obj-$(CONFIG_MIPS_CPU_SCACHE)	+= sc-mips.o
+ifdef CONFIG_DMA_TANGOX
+obj-y	+= dma-tangox.o
+else
+obj-y	+= dma-default.o
+endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/pci/pci.c linux-2.6.22.19/arch/mips/pci/pci.c
--- linux-2.6.22.19.ref/arch/mips/pci/pci.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/pci/pci.c	2009-04-24 10:51:33.000000000 -0700
@@ -326,5 +326,17 @@
 
 char *pcibios_setup(char *str)
 {
+	extern int pci_enabled;
+
+	if (strcmp(str, "disabled") == 0) {
+		pci_enabled = 0;
+		return(NULL);
+	} else if (strcmp(str, "off") == 0) {
+		pci_enabled = 0;
+		return(NULL);
+	} else if (strcmp(str, "on") == 0) {
+		pci_enabled = 1;
+		return(NULL);
+	}
 	return str;
 }
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/ramdisk/ld.script linux-2.6.22.19/arch/mips/ramdisk/ld.script
--- linux-2.6.22.19.ref/arch/mips/ramdisk/ld.script	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/ramdisk/ld.script	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,9 @@
+OUTPUT_ARCH(mips)
+SECTIONS
+{
+  .initrd :
+  {
+       *(.data)
+  }
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/ramdisk/Makefile linux-2.6.22.19/arch/mips/ramdisk/Makefile
--- linux-2.6.22.19.ref/arch/mips/ramdisk/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/ramdisk/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,23 @@
+#
+# Makefile for a ramdisk image
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+ifneq ($(CONFIG_EMBEDDED_RAMDISK),)
+ifneq ($(CONFIG_EMBEDDED_RAMDISK_IMAGE),)
+IMAGENAME := $(CONFIG_EMBEDDED_RAMDISK_IMAGE)
+else
+IMAGENAME := $(SMP86XX_ROOTFS_PATH)/root_fs_mipsel.cramfs
+endif
+RDPATH := $(TOPDIR)/arch/mips/ramdisk
+O_FORMAT := $(shell $(OBJDUMP) -i | head -2 | grep elf32)
+RD_MADE := $(shell $(LD) $(LDFLAGS) -T $(RDPATH)/ld.script -b binary --oformat $(O_FORMAT) -o $(RDPATH)/ramdisk.o $(IMAGENAME))
+endif
+
+obj-$(CONFIG_EMBEDDED_RAMDISK) += ramdisk.o
+
+clean-files += ramdisk.o
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/console.c linux-2.6.22.19/arch/mips/tangox/console.c
--- linux-2.6.22.19.ref/arch/mips/tangox/console.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/console.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,144 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * simple  uart support for  tango2/tango3 board,  register an  early console
+ * that make boot problem easier to debug.
+ *
+ * this uart init code comes from zboot
+ */
+
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/console.h>
+
+#include "setup.h"
+
+extern int tangox_uart_console_port(void);
+
+#ifdef CONFIG_TANGO3
+/*
+ * helpers to access uart0/uart1/uart2 register
+ */
+#define RD_UART_REG32(r)							\
+	((tangox_uart_console_port() == 0) ? 					\
+		gbus_read_reg32(REG_BASE_cpu_block + CPU_UART0_base + (r)) :	\
+		((tangox_uart_console_port() == 1) ? 				\
+			gbus_read_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r)) : 	\
+			gbus_read_reg32(REG_BASE_cpu_block + CPU_UART2_base + (r))))
+
+#define WR_UART_REG32(r, v)								\
+	((tangox_uart_console_port() == 0) ? 						\
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + (r), (v)) :	\
+		((tangox_uart_console_port() == 1) ? 					\
+			gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r), (v)) : 	\
+			gbus_write_reg32(REG_BASE_cpu_block + CPU_UART2_base + (r), (v)))) 
+#else
+/*
+ * helpers to access uart0/uart1 register
+ */
+#define RD_UART_REG32(r)							\
+	((tangox_uart_console_port() == 0) ? 					\
+		gbus_read_reg32(REG_BASE_cpu_block + CPU_UART0_base + (r)) :	\
+		gbus_read_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r)))
+
+#define WR_UART_REG32(r, v)								\
+	((tangox_uart_console_port() == 0) ? 						\
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + (r), (v)) :	\
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r), (v)))
+#endif
+
+/*
+ * print given char to uart0/uart1/uart2
+ */
+static void __init prom_putc(char c)
+{
+	/* if '\n', then print '\r' also */
+	if (c == '\n') {
+		prom_putc('\r');
+	}
+
+	while ((RD_UART_REG32(CPU_UART_LSR) & 0x20) == 0);
+	WR_UART_REG32(CPU_UART_THR, (unsigned long)c);
+	while ((RD_UART_REG32(CPU_UART_LSR) & 0x20) == 0);
+}
+
+/*
+ * print given string to uart0/uart1/uart2
+ */
+void __init prom_puts(const char *s)
+{
+	while (*s)
+		prom_putc(*s++);
+}
+
+/*
+ * initialize uart0/uart1/uart2 with given parameters
+ */
+static void __init uart_init(int baud, int fifo)
+{
+	unsigned int div;
+
+	WR_UART_REG32(CPU_UART_IER, 0x0);
+	WR_UART_REG32(CPU_UART_FCR, (fifo ? 0x1f : 0x0));
+	WR_UART_REG32(CPU_UART_LCR, 0x3);
+
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	WR_UART_REG32(CPU_UART_CLKSEL, 0x0);
+	div = (tangox_get_sysclock() / baud) >> 4;
+	if (((((tangox_get_sysclock() * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+	WR_UART_REG32(CPU_UART_CLKDIV, div);
+#else
+	WR_UART_REG32(CPU_UART_CLKSEL, 0x1);
+#ifdef CONFIG_TANGO2
+	div = (TANGO3_UART_FREQUENCY / baud) >> 4;
+	if (((((TANGO3_UART_FREQUENCY * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+#elif defined(CONFIG_TANGO3)
+	div = (TANGO3_UART_FREQUENCY / baud) >> 4;
+	if (((((TANGO3_UART_FREQUENCY * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+#else
+#error Unsupported platform.
+#endif
+	WR_UART_REG32(CPU_UART_CLKDIV, div);
+#endif
+}
+
+/*
+ * kernel console write callback
+ */
+static void __init prom_console_write(struct console *con, const char *s,
+				      unsigned int c)
+{
+	prom_puts(s);
+}
+
+static struct console promcons __initdata = {
+	.name   = "prom",
+	.write  = prom_console_write,
+	.flags  = CON_PRINTBUFFER | CON_BOOT,
+	.index  = -1,
+};
+
+/*
+ * init uart0/uart1/uart2 and register a console that will use our prom console
+ * callbacks
+ */
+void __init prom_console_register(void)
+{
+	uart_init(tangox_uart_baudrate(tangox_uart_console_port()), 0);
+	register_console(&promcons);
+
+	/* hello world ! */
+	printk(KERN_INFO "prom console registered\n");
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/cpucache.c linux-2.6.22.19/arch/mips/tangox/cpucache.c
--- linux-2.6.22.19.ref/arch/mips/tangox/cpucache.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/cpucache.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,116 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file  cpucache.c
+  @brief  
+
+  Implementing /proc/cpucache_info interface
+
+  @author YH Lin
+  @date   2006-08-16
+*/
+
+#include <linux/jiffies.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/tango2_gbus.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/tango3_gbus.h>
+#endif
+
+static int cpucache_info_read_proc(char *buf, char **start, off_t off, int count, int *eof, void *data);
+static unsigned long cpucache_saved_jiffies = 0;
+static unsigned icache_missed = 0, dcache_missed = 0;
+
+extern unsigned long em8xxx_cpu_frequency;
+
+//
+// init
+//
+int __init cpucache_info_init(void)
+{
+	create_proc_read_entry("cpucache_info", S_IRUGO, NULL, cpucache_info_read_proc, NULL);
+
+        printk("Created /proc/cpucache_info entry.\n");
+
+	/* Enable performance monitor and start counting */
+	/* 0: DCache Hit 
+	 * 1: DCache Miss
+	 * 2: TLB Hit
+	 * 3: TLB Miss
+	 * 4: ICache Hit
+	 * 5: ICache Miss
+	 * 6: Instn Complete
+	 * 7: ITLB Hit
+	 * 8: ITLB Miss
+	 * 9: JTLB Hit
+	 * 10: JTLB Miss
+	 * 11: WTB Merge */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_pm_select_1, (1<<5));
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_pm_select_0, (1<<1));
+	cpucache_saved_jiffies = jiffies;
+	icache_missed = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_1);
+	dcache_missed = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_0);
+	return 0;
+}
+
+__initcall(cpucache_info_init);
+
+static int cpucache_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+        int len = 0;
+	unsigned long diffj, diffi, diffd, icache_miss, dcache_miss, tmpj;
+	unsigned long pd, pi;
+        
+	icache_miss = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_1);
+	dcache_miss = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_0);
+	tmpj = jiffies;
+	diffj = tmpj - cpucache_saved_jiffies; 
+	cpucache_saved_jiffies = tmpj;
+	if (diffj == 0)
+		diffj = 1;
+
+	if (icache_miss < icache_missed)
+		diffi = (0xffffffff - icache_missed) + icache_miss;
+	else
+		diffi = icache_miss - icache_missed;
+	icache_missed = icache_miss;
+
+	if (dcache_miss < dcache_missed)
+		diffd = (0xffffffff - dcache_missed) + dcache_miss;
+	else
+		diffd = dcache_miss - dcache_missed;
+	dcache_missed = dcache_miss;
+
+	len += sprintf(page+off+len, "jiffies");
+	/* The average miss per jiffies is (diffx / diffj), per second is then ((diffx * HZ) / diffj).
+	 * Assuming one instruction per clock, we have (((diffx * HZ) / diffj) / em8xxx_cpu_frequency)
+	 * as average ratio of cache miss per instruction at given period of time (from last 
+	 * measured, as expressed as (diffj / HZ)). */
+	pi = ((diffi * HZ) / diffj) / (em8xxx_cpu_frequency / 10000); /* Times 10000 to get percentage */
+	pd = ((diffd * HZ) / diffj) / (em8xxx_cpu_frequency / 10000);
+
+	len += sprintf(page+off+len, "(%ld): I-Cache miss ratio(%ld): %ld.%02ld%c, D-Cache miss ratio(%ld): %ld.%02ld%c\n",
+			diffj, diffi, pi / 100, pi % 100, '%', diffd, pd / 100, pd % 100, '%');
+	*eof = 1;
+
+        return(len);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/delay.c linux-2.6.22.19/arch/mips/tangox/delay.c
--- linux-2.6.22.19.ref/arch/mips/tangox/delay.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/delay.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,83 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * arch/mips/tangox/delay.c
+ *
+ * Copyright (C) 2003-2007 Sigma Designs, Inc
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+
+#include "setup.h"
+
+//#define TANGOX_USE_XTAL_UDELAY
+
+#ifdef TANGOX_USE_XTAL_UDELAY
+static inline unsigned long tangox_getxtal(void)
+{
+	return(gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
+/* This is the replacement of Linux's udelay. */
+void tangox_udelay(unsigned usec)
+{
+	/* SYS_xtal_in_cnt is a counter running off TANGOX_BASE_FREQUENCY */
+	unsigned long start = tangox_getxtal();
+	unsigned long end = start + (usec * (TANGOX_BASE_FREQUENCY / 1000000));
+	unsigned long xtal;
+
+	if (end > start)
+		for (xtal = tangox_getxtal(); (xtal < end) && (xtal >= start); xtal = tangox_getxtal());
+	else
+		for (xtal = tangox_getxtal(); (xtal < end) || (xtal >= start); xtal = tangox_getxtal());
+}
+
+void tangox_syncwith_xtal(unsigned long *mark, unsigned usec)
+{
+	unsigned long end = *mark + (usec * (TANGOX_BASE_FREQUENCY / 1000000));
+	unsigned long xtal;
+
+	if (end > *mark)
+		for (xtal = tangox_getxtal(); (xtal < end) && (xtal >= *mark); xtal = tangox_getxtal());
+	else
+		for (xtal = tangox_getxtal(); (xtal < end) || (xtal >= *mark); xtal = tangox_getxtal());
+	*mark = end;
+}
+#else
+/* This is the replacement of Linux's udelay. */
+void tangox_udelay(unsigned usec)
+{
+	extern unsigned long em8xxx_cpu_frequency;
+	unsigned long start = read_c0_count();
+	unsigned long end, cnt, c0_cnt;
+
+			/* CP0_COUNT increase every two CPU clocks */
+	cnt = em8xxx_cpu_frequency / (1000000 * 2);
+	if ((cnt * (1000000 * 2)) < em8xxx_cpu_frequency)
+		cnt++; /* take the ceiling */
+	end = start + (usec * cnt);
+
+	if (end > start)
+		for (c0_cnt = read_c0_count(); (c0_cnt < end) && (c0_cnt >= start); c0_cnt = read_c0_count());
+	else
+		for (c0_cnt = read_c0_count(); (c0_cnt < end) || (c0_cnt >= start); c0_cnt = read_c0_count());
+}
+#endif
+
+EXPORT_SYMBOL(tangox_udelay);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/gbus.c linux-2.6.22.19/arch/mips/tangox/gbus.c
--- linux-2.6.22.19.ref/arch/mips/tangox/gbus.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/gbus.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,267 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * export gbus symbol to modules
+ */
+
+#include <linux/module.h>
+#include <asm/system.h>
+
+#include "setup.h"
+
+#define TMP_REMAPPED_REG	CPU_remap1
+#define TMP_REMAPPED_BASE	CPU_remap1_address
+#define TMP_REMAPPED_SIZE	0x00010000
+#define TMP_REMAPPED_MASK	~(TMP_REMAPPED_SIZE-1)
+
+#define TMP_REMAPPED_REG1	CPU_remap
+#define TMP_REMAPPED_BASE1	CPU_remap_address
+#define TMP_REMAPPED_SIZE1	0x00010000
+#define TMP_REMAPPED_MASK1	~(TMP_REMAPPED_SIZE1-1)
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+unsigned long em86xx_tlb_dram1_map_base;
+unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+static RMuint32 set_remap(RMuint32 remap_reg, RMuint32 value)
+{
+	RMuint32 orig = *((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg));
+	if (orig != value) {
+		*((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg)) = value;
+		iob();
+	}
+	return(orig);
+}
+
+#if defined(CONFIG_TANGO3)
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	extern unsigned long phy_remap, max_remap_size;							\
+	if (byte_address < CPU_remap2_address) {							\
+		tmp = *((volatile RMuint##size *)KSEG1ADDR(byte_address)); 				\
+		rmb();											\
+	} else if ((byte_address >= phy_remap) && (byte_address < (phy_remap + max_remap_size))) {	\
+		tmp = *((volatile RMuint##size *)KSEG1ADDR(CPU_REMAP_SPACE + (byte_address - phy_remap))); 	\
+		rmb();											\
+	} else {											\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			rmb();										\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			rmb();										\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		local_irq_restore(flags);								\
+	}												\
+	return(tmp);											\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	extern unsigned long phy_remap, max_remap_size;							\
+	mb();												\
+	if (byte_address < CPU_remap2_address) {							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data;				\
+		iob();											\
+	} else if ((byte_address >= phy_remap) && (byte_address < (phy_remap + max_remap_size))) {	\
+		*((volatile RMuint##size *)KSEG1ADDR(CPU_REMAP_SPACE + (byte_address - phy_remap))) = data;	\
+		iob();											\
+	} else {											\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			iob();										\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			iob();										\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		local_irq_restore(flags);								\
+	}												\
+}
+
+#elif defined(CONFIG_TANGO2)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))		\
+			return gbus_read_dram_uint##size(pgbus, byte_address);				\
+		else {											\
+			printk("accessing non-existed DRAM1 area 0x%08lx\n", byte_address);		\
+			return(0);									\
+		}											\
+	else {												\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		local_irq_restore(flags);								\
+		return(tmp);										\
+	}												\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))		\
+			gbus_write_dram_uint##size(pgbus, byte_address, data);				\
+		else 											\
+			printk("accessing non-existed DRAM1 area 0x%08lx.\n", byte_address);		\
+	else {												\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		local_irq_restore(flags);								\
+	}												\
+	__sync();											\
+}
+
+#else /* CONFIG_TANGOX_USE_TLB_REMAP_DRAM1 */
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else {												\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		local_irq_restore(flags);								\
+		return(tmp);										\
+	}												\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else {												\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		local_irq_restore(flags);								\
+	}												\
+	__sync();											\
+}
+
+#endif /* CONFIG_TANGOX_USE_TLB_REMAP_DRAM1 */
+
+#else
+#error Unsupported platform.
+#endif /* CONFIG_TANGO3 */
+
+BUILD_GBUS_READ_OP(32);
+BUILD_GBUS_READ_OP(16);
+BUILD_GBUS_READ_OP(8);
+
+BUILD_GBUS_WRITE_OP(32);
+BUILD_GBUS_WRITE_OP(16);
+BUILD_GBUS_WRITE_OP(8);
+
+EXPORT_SYMBOL(gbus_read_uint32);
+EXPORT_SYMBOL(gbus_write_uint32);
+EXPORT_SYMBOL(gbus_read_uint16);
+EXPORT_SYMBOL(gbus_write_uint16);
+EXPORT_SYMBOL(gbus_read_uint8);
+EXPORT_SYMBOL(gbus_write_uint8);
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_base);
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_size);
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/irq.c linux-2.6.22.19/arch/mips/tangox/irq.c
--- linux-2.6.22.19.ref/arch/mips/tangox/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/irq.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,497 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ *
+ * arch_init_irq for tango2/tango3.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq_cpu.h>
+
+#include "setup.h"
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)		\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		do {								\
+			gbus_write_reg32(REG_BASE_cpu_block + (r), (v));	\
+			iob();							\
+		} while(0)	
+
+static DEFINE_SPINLOCK(mips_irq_lock);
+
+static inline u64 get_irq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_irq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_irq_status));
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+	return status;
+}
+static inline u64 get_fiq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_fiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_fiq_status));
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+	return status;
+}
+static inline u64 get_iiq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_iiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_iiq_status));
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+	return status;
+}
+ 
+static void fastcall tangox_irq_flow_handler(unsigned int irq, struct irq_desc *desc)
+{
+	__do_IRQ(irq);
+}
+
+static inline int clz(unsigned long x)
+{
+	__asm__ (
+	"	.set	push					\n"
+	"	.set	mips32					\n"
+	"	clz	%0, %1					\n"
+	"	.set	pop					\n"
+	: "=r" (x)
+	: "r" (x));
+
+	return x;
+}
+
+static inline int clz64(u64 x)
+{
+	u32 xl = (u32)x & 0xffffffff, xh = (u32)(x >> 32) & 0xffffffff;
+	int lz;
+	lz = clz(xh) & 0x1f;
+	if (lz != 0)
+		return lz;
+	else {
+		lz = clz(xl) & 0x1f;
+		if (lz != 0)
+			return lz + 32;
+	}
+	return 64;
+}
+
+static inline unsigned int irq_ffs(unsigned int pending)
+{
+	return -clz(pending) + 31 - CAUSEB_IP;
+}
+
+static int mips_timer_irq = 0;
+#ifdef CONFIG_TANGO3
+static int mips_pref_irq = 0;
+#endif
+static unsigned long edge_trig = 0;
+static unsigned long edge_trig_hi = 0;
+
+/*
+ * dispatch routine called from genex.S
+ */
+extern void spurious_interrupt(void);
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = (read_c0_cause() & read_c0_status()) & ST0_IM;
+	int irq;
+	u64 status;
+
+	if (pending == 0) {
+		printk("spurious hwirq: nothing pending\n");
+		spurious_interrupt();
+		return;
+	}
+
+	for (; pending != 0; pending = (read_c0_cause() & read_c0_status()) & ST0_IM) {
+
+		irq = irq_ffs(pending);
+
+		switch(irq) {
+			case 2: if ((status = get_irq_status()) == 0) {
+					printk("spurious irq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					do_IRQ(IRQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+				}
+				break;
+
+			case 3: if ((status = get_fiq_status()) == 0) {
+					printk("spurious fiq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					/* We need to mask out irq, fiq > irq */
+					u32 sr_old = read_c0_status();
+					u32 sr_new = sr_old & (~STATUSF_IP2);
+
+					write_c0_status(sr_new);
+					do_IRQ(FIQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+					write_c0_status(sr_old);
+				}
+				break;
+
+			case 4: if ((status = get_iiq_status()) == 0) {
+					printk("spurious iiq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					/* We need to mask out fiq/irq, iiq > fiq > irq */
+					u32 sr_old = read_c0_status();
+					u32 sr_new = sr_old & (~(STATUSF_IP2|STATUSF_IP3));
+
+					write_c0_status(sr_new);
+					do_IRQ(IIQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+					write_c0_status(sr_old);
+				}
+				break;
+
+			default: if ((irq == mips_timer_irq)
+#ifdef CONFIG_TANGO3
+					|| (irq == mips_pref_irq)
+#endif
+				) {
+					do_IRQ(irq);
+				} else { 
+					printk("spurious hwirq: %d\n", irq);
+					goto spurious;
+				}
+				break;
+		}
+
+		continue;
+spurious:
+		spurious_interrupt();
+	}
+
+	return;
+}
+
+/*
+ * our hw_irq_controller cb
+ */
+static inline void tangox_irq_enable(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_irq_enableset_hi, 1 << (bit - 32));
+	else 
+		WR_CPU_REG32(CPU_irq_enableset, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_fiq_enable(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_fiq_enableset_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_fiq_enableset, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_iiq_enable(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_iiq_enableset_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_iiq_enableset, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_irq_disable(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_irq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_irq_enableclr, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_fiq_disable(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_fiq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_fiq_enableclr, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_iiq_disable(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_iiq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_iiq_enableclr, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static unsigned int tangox_irq_startup(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		if (edge_trig_hi & (1 << (bit - 32)))
+			WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		if (edge_trig & (1 << bit))
+			WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_irq_enable(x);
+	return 0;
+}
+
+static unsigned int tangox_fiq_startup(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		if (edge_trig_hi & (1 << (bit - 32)))
+			WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		if (edge_trig & (1 << bit))
+			WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_fiq_enable(x);
+	return 0;
+}
+
+static unsigned int tangox_iiq_startup(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		if (edge_trig_hi & (1 << (bit - 32)))
+			WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		if (edge_trig & (1 << bit))
+			WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_iiq_enable(x);
+	return 0;
+}
+
+#define	tangox_irq_shutdown tangox_irq_disable
+#define	tangox_fiq_shutdown tangox_fiq_disable
+#define	tangox_iiq_shutdown tangox_iiq_disable
+
+static void tangox_irq_ack(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+
+	tangox_irq_disable(x);
+
+	if (bit >= 32) {
+		if (edge_trig_hi & (1 << (bit - 32)))
+			WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		if (edge_trig & (1 << bit))
+			WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_fiq_ack(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_fiq_disable(x);
+
+	if (bit >= 32) {
+		if (edge_trig_hi & (1 << (bit - 32)))
+			WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		if (edge_trig & (1 << bit))
+			WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_iiq_ack(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_iiq_disable(x);
+
+	if (bit >= 32) {
+		if (edge_trig_hi & (1 << (bit - 32)))
+			WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		if (edge_trig & (1 << bit))
+			WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_irq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_irq_enable(x);
+}
+
+static void tangox_fiq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_fiq_enable(x);
+}
+
+static void tangox_iiq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_iiq_enable(x);
+}
+
+/*
+ * our hw_irq_controller
+ */
+static hw_irq_controller tangox_irq_controller = {
+	.typename = "tangox_irq",
+	.startup = tangox_irq_startup,
+	.shutdown = tangox_irq_shutdown,
+	.enable = tangox_irq_enable,
+	.disable = tangox_irq_disable,
+	.ack = tangox_irq_ack,
+	.end = tangox_irq_end,
+};
+
+static hw_irq_controller tangox_fiq_controller = {
+	.typename = "tangox_fiq",
+	.startup = tangox_fiq_startup,
+	.shutdown = tangox_fiq_shutdown,
+	.enable = tangox_fiq_enable,
+	.disable = tangox_fiq_disable,
+	.ack = tangox_fiq_ack,
+	.end = tangox_fiq_end,
+};
+
+static hw_irq_controller tangox_iiq_controller = {
+	.typename = "tangox_iiq",
+	.startup = tangox_iiq_startup,
+	.shutdown = tangox_iiq_shutdown,
+	.enable = tangox_iiq_enable,
+	.disable = tangox_iiq_disable,
+	.ack = tangox_iiq_ack,
+	.end = tangox_iiq_end,
+};
+
+static struct irqaction irq_cascade = {
+	no_action, IRQF_SHARED, { { 0, } }, "cascade", NULL, NULL
+};
+
+void __init arch_init_irq(void)
+{
+	unsigned long x;
+	unsigned long rise = 0;
+	unsigned long fall = 0;
+	unsigned long rise_hi = 0;
+	unsigned long fall_hi = 0;
+
+	/* irq_desc entries 0..7 */
+	mips_cpu_irq_init();
+
+	WR_CPU_REG32(CPU_irq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_irq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr_hi, 0xffffffff);
+
+	rise = RD_CPU_REG32(CPU_edge_config_rise);
+	fall = RD_CPU_REG32(CPU_edge_config_fall);
+	edge_trig = rise ^ fall;
+	WR_CPU_REG32(CPU_edge_rawstat, edge_trig);
+//WR_CPU_REG32(CPU_edge_rawstat, 0xffffffff);
+	rise_hi = RD_CPU_REG32(CPU_edge_config_rise_hi);
+	fall_hi = RD_CPU_REG32(CPU_edge_config_fall_hi);
+	edge_trig_hi = rise_hi ^ fall_hi;
+	WR_CPU_REG32(CPU_edge_rawstat_hi, edge_trig_hi);
+//WR_CPU_REG32(CPU_edge_rawstat_hi, 0xffffffff);
+
+	for (x = IRQ_CONTROLLER_IRQ_BASE; x < IRQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) 
+		irq_desc[x].status = IRQ_DISABLED;
+		irq_desc[x].action = NULL;
+		irq_desc[x].depth = 1;
+		irq_desc[x].handle_irq = &tangox_irq_controller;
+#else
+		set_irq_chip_and_handler(x, &tangox_irq_controller, tangox_irq_flow_handler);
+#endif
+	}
+
+	for (x = FIQ_CONTROLLER_IRQ_BASE; x < FIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+		irq_desc[x].status = IRQ_DISABLED;
+		irq_desc[x].action = NULL;
+		irq_desc[x].depth = 1;
+		irq_desc[x].handle_irq = &tangox_fiq_controller;
+#else
+		set_irq_chip_and_handler(x, &tangox_fiq_controller, tangox_irq_flow_handler);
+#endif
+	}
+
+	for (x = IIQ_CONTROLLER_IRQ_BASE; x < IIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+		irq_desc[x].status = IRQ_DISABLED;
+		irq_desc[x].action = NULL;
+		irq_desc[x].depth = 1;
+		irq_desc[x].handle_irq = &tangox_iiq_controller;
+#else
+		set_irq_chip_and_handler(x, &tangox_iiq_controller, tangox_irq_flow_handler);
+#endif
+	}
+
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 3, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 4, &irq_cascade);
+
+#ifdef CONFIG_TANGO2
+	mips_timer_irq = 7;
+#elif defined(CONFIG_TANGO3)
+	mips_timer_irq = (read_c0_intctl() >> 29) & 7;
+	mips_pref_irq = (read_c0_intctl() >> 26) & 7;
+#endif
+	return;
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/Kconfig linux-2.6.22.19/arch/mips/tangox/Kconfig
--- linux-2.6.22.19.ref/arch/mips/tangox/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/Kconfig	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,290 @@
+
+#
+# environnent selection
+#
+
+config TANGO2_SMP863X
+	bool
+
+config TANGO3_SMP86XX
+	bool
+
+#
+# chip revision selection
+#
+choice
+	prompt "SMP863x chip revision"
+	depends on TANGO2_SMP863X
+	default TANGO2_ES6
+
+config TANGO2_ES4
+	bool "ES4"
+
+config TANGO2_ES5
+	bool "ES5"
+
+config TANGO2_ES6
+	bool "ES6+"
+
+endchoice
+
+choice
+	prompt "SMP864x/SMP865x chip selection"
+	depends on TANGO3_SMP86XX
+	default TANGO3_865X
+
+config TANGO3_865X
+	bool "SMP865x"
+	help
+	  Sigma Designs' SMP865x chip (MIPS 24Kf core based), ES3 or above.
+
+config TANGO3_864X
+	bool "SMP864x"
+	help
+	  Sigma Designs' SMP864x chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler will be needed to support 74Kf core.
+
+endchoice
+
+comment ""
+
+config TANGO3_DISABLE_HWFPU
+	bool "Disable HW FPU"
+	depends on TANGO3_SMP86XX && TANGO3
+	default n
+	help
+	 Disable HW FPU, and use SW FPU emulation.
+
+config TANGOX_SYSTEMRAM_ACTUALSIZE
+	int "System RAM size (in MB)"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+	default 64
+	help
+	 This is the default amount of RAM available to the Linux kernel. It can be
+	 override with "mem=" command line option.
+
+
+config TANGOX_IGNORE_CMDLINE
+	bool "Ignore YAMON, XENV & memcfg command line"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+	default n
+	help
+	 If you say  yes, boot command line from  YAMON, XENV & memcfg
+	 will be ignored. You can then use CONFIG_CMDLINE to force the
+	 kernel command line.
+
+
+config TANGOX_PROM_CONSOLE
+	bool "Register an early console"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+	default n
+	help
+	 If you say yes, an light console will be available very early
+	 in the  boot process,  this is useful  if the  kernel crashes
+	 before reaching  the main console  code. The console  will be
+	 automatically replaced by the normal one after.
+	 ### NOTE: This console can only do output ###
+
+config TANGOX_FIXED_FREQUENCIES
+	bool "Specified fixed frequencies"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+	default n if TANGO2_SMP863X
+	default y if TANGO3_SMP86XX
+	help
+	 To specify, statically, the frequencies for CPU, System, and Base.
+	 Normally this is only used in experimental purpose where PLL may be
+	 set differently (typical for simulation or FPGA).
+
+config TANGOX_BASE_FREQUENCY
+	int "Base Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 27000000
+	help
+	 Base frequency (corresponding to XTAL in).
+
+config TANGOX_CPU_FREQUENCY
+	int "CPU Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 300000000
+	help
+	 CPU frequency.
+
+config TANGOX_SYS_FREQUENCY
+	int "System Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 200000000
+	help
+	 System frequency.
+
+config TANGOX_DSP_FREQUENCY
+ 	int "DSP Frequency"
+ 	depends on TANGOX_FIXED_FREQUENCIES
+ 	default 200000000
+ 	help
+ 	 DSP frequency.
+ 
+config TANGOX_UART_USE_SYSCLK
+	bool "Use system clock for UART"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+	default y
+	help
+	 If you  say yes here, the UART  clock will be  derivated from the
+	 board  system clock. If  you say  no, the  CPU clock  is used
+	 instead.
+
+config TANGOX_USE_CPU_CLOCK
+	bool "Use internal cpu clock for system timer"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+	default y
+	help
+	 If you say  yes here, the mips timer  interrupt (IP7) will be
+	 used as the  Linux timer interrupt. Timer0 can  be used as an
+	 alternative.
+
+config TANGOX_USE_TLB_REMAP_DRAM1
+	bool "Use TLB to access DRAM1"
+	depends on TANGO2_SMP863X 
+	default n
+	help
+	 If  you say yes  here, kernel  access to  DRAM1 will  be done
+	 using TLB implementation. gbus() funcs will use an ioremapped
+	 address to access this area of memory. If you say no, special
+	 CPU remap registers are used instead.
+
+#
+# XENV stuffs
+#
+comment ""
+
+config TANGOX_XENV_READ
+	bool "Read config from XENV"
+	depends on TANGO2_SMP863X || TANGO3_SMP86XX
+ 	select CRYPTO_SHA1 
+ 	select CRYPTO_SHA256 if TANGO3
+	help
+	 If you  say yes  here, board configuration  (enabled devices,
+	 pci irq routing,  ...) will be read from  xenv space.
+
+config TANGOX_XENV_DUMP
+	bool "Dump XENV content at boot"
+	depends on TANGOX_XENV_READ
+	default n
+
+config TANGOX_XENV_READ_SAFE
+	bool "Don't boot if XENV invalid"
+	depends on TANGOX_XENV_READ
+	help
+	 If you say yes here and XENV content is invalid, linux wont boot.
+
+menu "XENV failsafe/override values"
+	depends on (TANGO2_SMP863X || TANGO3_SMP86XX) && (!TANGOX_XENV_READ_SAFE)
+
+config TANGOX_XENV_DEF_CS0_SIZE
+	hex "CS0 size (flash0)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS1_SIZE
+	hex "CS1 size (flash1)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS2_SIZE
+	hex "CS2 size (flash2)"
+	default 0x400000
+
+config TANGOX_XENV_DEF_CS3_SIZE
+	hex "CS3 size (flash3)"
+	default 0x0
+
+config TANGOX_XENV_DEF_UART0
+	bool "UART0 enabled"
+	default y
+
+config TANGOX_XENV_DEF_UART1
+	bool "UART1 enabled"
+	default y
+
+config TANGOX_XENV_DEF_BAUDRATE
+	int "Default baudrate"
+	default 115200
+
+config TANGOX_XENV_DEF_CONSOLE_UART_PORT
+	int "Console UART port"
+	default 0
+
+config TANGOX_XENV_DEF_ENET
+	bool "Ethernet enabled"
+	default n
+
+config TANGOX_XENV_DEF_FIP
+	bool "FIP enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CM
+	bool "I2CM enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CS
+	bool "I2CS enabled"
+	default n
+
+config TANGOX_XENV_DEF_BMIDE
+	bool "BM IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_ISAIDE
+	bool "ISA IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_IR
+	bool "IR enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCIHOST
+	bool "PCI Host enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1
+	bool "PCI device 1 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1_IRQ
+	hex "PCI device 1 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID1
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID2
+	bool "PCI device 2 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID2_IRQ
+	hex "PCI device 2 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID2
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID3
+	bool "PCI device 3 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID3_IRQ
+	hex "PCI device 3 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID3
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID4
+	bool "PCI device 4 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID4_IRQ
+	hex "PCI device 4 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID4
+	default 0x0
+
+config TANGOX_XENV_DEF_USB
+	bool "USB enabled"
+	default n
+
+endmenu
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/Makefile linux-2.6.22.19/arch/mips/tangox/Makefile
--- linux-2.6.22.19.ref/arch/mips/tangox/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,17 @@
+#
+# Makefile for SigmaDesigns Tango2/Tango3 board
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y += irq.o setup.o prom.o gbus.o xenv_config.o delay.o 
+
+obj-$(CONFIG_TANGO2) += cpucache.o
+
+obj-$(CONFIG_TANGOX_PROM_CONSOLE) += console.o
+
+obj-$(CONFIG_TANGOX_XENV_READ) += sha.o xenv.o
+
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/prom.c linux-2.6.22.19/arch/mips/tangox/prom.c
--- linux-2.6.22.19.ref/arch/mips/tangox/prom.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/prom.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,682 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+
+#include "setup.h"
+
+#ifdef CONFIG_TANGO3 
+#include "xenv.h"
+#include "xenvkeys.h"
+#endif
+
+/*
+ * em8xxx_sys_frequency may be used later in the serial  code, DON'T mark
+ * it as initdata
+ */
+unsigned long em8xxx_sys_frequency;
+unsigned long em8xxx_cpu_frequency;
+unsigned long em8xxx_kmem_start;
+unsigned long em8xxx_kmem_size;
+unsigned long em8xxx_sys_clkgen_pll;
+unsigned long em8xxx_sys_premux;
+unsigned long em8xxx_sys_mux;
+unsigned long em8xxx_max_dx_size;
+#ifdef CONFIG_TANGO3
+unsigned long phy_remap;
+unsigned long max_remap_size;
+#endif 
+
+unsigned long tangox_chip_id(void);
+int is_tango2_chip(void);
+int is_tango3_chip(void);
+int is_tango3_es1(void);
+int is_tango3_es2(void);
+
+/*
+ * we will restore remap registers before rebooting
+ */
+#ifdef CONFIG_TANGO2
+unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+unsigned long em8xxx_remap_registers[8];
+#endif 
+
+/*
+ * helper to access base registers
+ */
+#define RD_BASE_REG32(r)	\
+		gbus_read_reg32(REG_BASE_system_block + (r))
+
+/*
+ * return system type (/proc/cpuinfo)
+ */
+const char *get_system_type(void)
+{
+	return "Sigma Designs TangoX";
+}
+
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+unsigned long tangox_get_pllclock(int pll)
+{
+	return(0);
+}
+
+unsigned long tangox_get_sysclock(void)
+{
+	return(CONFIG_TANGOX_SYS_FREQUENCY);
+}
+
+unsigned long tangox_get_cpuclock(void)
+{
+	return(CONFIG_TANGOX_CPU_FREQUENCY);
+}
+
+unsigned long tangox_get_dspclock(void)
+{
+	return(CONFIG_TANGOX_DSP_FREQUENCY);
+}
+#else
+unsigned long tangox_get_pllclock(int pll)
+{
+	unsigned long sys_clkgen_pll, sysclk_mux;
+	unsigned long n, m, freq, k, step;
+
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	if ((sysclk_mux & 0x1) == 0) {
+		freq = TANGOX_BASE_FREQUENCY;
+		goto done;
+	}
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll + (pll * 0x8));
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		goto freq_error;
+
+#ifdef CONFIG_TANGO2
+	m = (sys_clkgen_pll >> 16) & 0x1f;
+	n = sys_clkgen_pll & 0x000003ff;
+	k = (pll) ? 0 : ((sys_clkgen_pll >> 14) & 0x3); 
+	step = 2;
+#elif defined(CONFIG_TANGO3)
+	if (pll != 0) { /* PLL1/PLL2 */
+		m = (sys_clkgen_pll >> 16) & 0x1;
+		n = sys_clkgen_pll & 0x0000007f;
+		k = (sys_clkgen_pll >> 13) & 0x7;
+		step = 1;
+	} else {
+		m = (sys_clkgen_pll >> 16) & 0x1f;
+		n = sys_clkgen_pll & 0x000003ff;
+		k = (sys_clkgen_pll >> 14) & 0x3; 
+		step = 2;
+	}
+#else
+#error Unsupported platform.
+#endif
+	freq = ((TANGOX_BASE_FREQUENCY / (m + step)) * (n + step)) / (1 << k);
+
+done:
+	return(freq);
+
+freq_error:
+	return(0);
+}
+
+static unsigned long tangox_get_clock(unsigned int clk_dom)
+{
+	unsigned long sysclk_mux, sysclk_premux;
+	unsigned long div, mux, pll, pll_freq;
+	static const unsigned char dividers[3][12] = {
+		{ 2, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 },
+		{ 2, 2, 2, 3, 3, 2, 3, 2, 4, 2, 4, 2 }, 
+#ifdef CONFIG_TANGO2
+		{ 2, 4, 3, 3, 3, 3, 2, 2, 4, 4, 2, 2 },
+#else
+		{ 2, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 },
+#endif
+	};
+
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	sysclk_premux = RD_BASE_REG32(SYS_sysclk_premux);
+	pll = sysclk_premux & 0x3;
+
+	if (((pll_freq = tangox_get_pllclock(pll)) == 0) || (clk_dom >= 3))
+		goto freq_error;
+	else if ((mux = ((sysclk_mux >> 8) & 0xf)) >= 12)
+		goto freq_error; /* invalid mux value */
+
+	div = (unsigned long)dividers[clk_dom][mux];
+
+	return(pll_freq / div);
+
+freq_error:
+	return(0);
+}
+
+unsigned long tangox_get_sysclock(void)
+{
+	return(tangox_get_clock(0));
+}
+
+unsigned long tangox_get_cpuclock(void)
+{
+	return(tangox_get_clock(1));
+}
+
+unsigned long tangox_get_dspclock(void)
+{
+	return(tangox_get_clock(2));
+}
+#endif
+
+extern int do_syslog(int type, char * buf, int len);
+extern int __init xenv_config(void);
+extern void __init tangox_device_info(void);
+extern const char *tangox_xenv_cmdline(void);
+
+#ifdef CONFIG_TANGO3
+static inline unsigned long fixup_dram_address(unsigned long addr)
+{
+	if ((addr >= 0x10000000) && (addr < 0x20000000))
+		addr = (addr - 0x10000000) + MEM_BASE_dram_controller_0; /* to DRAM0 */
+	else if ((addr >= 0x20000000) && (addr < 0x30000000))
+		addr = (addr - 0x20000000) + MEM_BASE_dram_controller_1; /* to DRAM1 */
+	return(addr);
+}
+
+void update_lrrw_kend(unsigned long kend)
+{
+	xenv_set((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_KERNEL_END, &kend, 0, sizeof(kend));
+}
+#endif
+
+void __init prom_init(void)
+{
+	extern char _text;
+	unsigned long offset, em8xxx_kmem_end;
+	int clksel, xenv_res = 0, i;
+	char *revStr = NULL;
+#ifdef CONFIG_TANGO2
+	memcfg_t *m;
+#endif
+
+#if 0
+	/* For emulator, setup registers that typically got setup by bootloader */
+	/* Temporary HACK */
+	/* UART0/1 UART mode */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode, 0xff00);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode, 0xff00);
+
+	/* Set interrupt attributes, clear/disable all external interrupts */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_irq_enableclr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_clr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_clr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_set, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_set, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_rawstat, 0xffffffff);
+
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_irq_enableclr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_clr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_clr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_set_hi, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_set_hi, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_rawstat_hi, 0xffffffff);
+#endif
+	/*
+	 * save remap registers for reboot time
+	 */
+	for (i = 0;
+#ifdef CONFIG_TANGO2
+		i < 5;
+#elif defined(CONFIG_TANGO3)
+		i < 8;
+#endif
+		i++) {
+		em8xxx_remap_registers[i] = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (i * 4));
+	}
+
+	/* 
+	 * Set remap so that 0x1fc00000 and 0x0 back to they should be...
+	 */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap, 0x1fc00000);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap1, 0x0);
+	iob();
+	
+#ifdef CONFIG_TANGO3
+#define REMAP_IDX      (((CPU_REMAP_SPACE-CPU_remap2_address)/0x04000000)+2)
+#define MAX_KERNEL_MEMSIZE	(0x18000000-(((REMAP_IDX)-2)*0x04000000))
+	phy_remap = fixup_dram_address(em8xxx_remap_registers[REMAP_IDX]);
+	max_remap_size = 0x04000000; /* minimum 64MB */
+	if (phy_remap != em8xxx_remap_registers[REMAP_IDX]) { /* fix up needed */
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + REMAP_IDX * 4, phy_remap);
+		iob();
+	}
+	for (i = REMAP_IDX + 1; i < 8; i++) {
+		unsigned long newaddr = fixup_dram_address(em8xxx_remap_registers[i]);
+		if (newaddr == (phy_remap + (0x04000000 * (i - REMAP_IDX)))) {
+			max_remap_size += 0x04000000;
+			if (newaddr != em8xxx_remap_registers[i]) { /* fix up needed */
+				gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + i * 4, newaddr);
+				iob();
+			}
+		}
+	}
+	printk("Physical map 0x%08lx to 0x%08lx, max remap/kernel size: 0x%08lx/0x%08lx.\n",
+		phy_remap, (unsigned long)CPU_REMAP_SPACE, max_remap_size, (unsigned long)MAX_KERNEL_MEMSIZE);
+#endif
+#ifdef CONFIG_TANGO2
+#define MAX_KERNEL_MEMSIZE	(0x10000000)
+#endif
+
+#if defined(CONFIG_TANGO2_SMP863X)
+	printk("Configured for SMP863%c (revision %s), ",
+#if defined(CONFIG_TANGO2_ES1)
+			'0', "ES1"
+#elif defined(CONFIG_TANGO2_ES2)
+			'0', "ES2"
+#elif defined(CONFIG_TANGO2_ES3)
+			'0', "ES3"
+#elif defined(CONFIG_TANGO2_ES4)
+			'4', "ES4"
+#elif defined(CONFIG_TANGO2_ES5)
+			'4', "ES5"
+#elif defined(CONFIG_TANGO2_ES6)
+			'x', "ES6+/RevA+"
+#endif
+	      );
+#elif defined(CONFIG_TANGO3_SMP86XX)
+	printk("Configured for SMP%s, ",
+#if defined(CONFIG_TANGO3_865X)
+			"865x"
+#elif defined(CONFIG_TANGO3_864X)
+			"864x"
+#endif
+	      );
+#else
+#error Unsupported platform.
+#endif
+	printk("detected SMP%lx (revision ", (tangox_chip_id()>>16)&0xffff);
+	if (is_tango2_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x81: /* ES1-3 */
+				revStr = "ES1-3";
+				break;
+			case 0x82: /* ES4-5 */
+				revStr = "ES4-5";
+				break;
+			case 0x83: /* ES6/RevA */
+				revStr = "ES6/RevA";
+				break;
+			case 0x84: /* ES7/RevB */
+				revStr = "ES7/RevB";
+				break;
+			case 0x85: /* ES8 */
+				revStr = "ES8";
+				break;
+			case 0x86: /* ES9/RevC */
+				revStr = "ES9/RevC";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} else if (is_tango3_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x1: /* ES1 */
+				revStr = "ES1";
+				break;
+			case 0x2: /* ES2 */
+				revStr = "ES2";
+				break;
+			case 0x3: /* ES3 */
+				revStr = "ES3";
+				break;
+			case 0x4: /* ES4 */
+				revStr = "ES4";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} else
+		revStr = "unknown";
+	
+	printk("%s).\n", revStr);
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+	printk("Fixed CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
+#else
+	printk("Detected CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
+#endif
+
+	/*
+	 * read xenv  configuration, we  need it quickly  to configure
+	 * console accordingly.
+	 *
+	 * NOTE: We  may stay STUCK in  this if safe  mode is required
+	 * and XENV is not valid !
+	 */
+	xenv_res = xenv_config();
+
+	/*
+	 * calculate cpu & sys frequency (may be needed for uart init)
+	 */
+	em8xxx_cpu_frequency = tangox_get_cpuclock();
+	em8xxx_sys_frequency = tangox_get_sysclock();
+
+	em8xxx_sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	em8xxx_sys_premux = RD_BASE_REG32(SYS_sysclk_premux) & 0x3;
+	em8xxx_sys_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf1;
+
+	/*
+	 * program the right clock divider in both uart
+	 */
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	clksel = 0;
+#else
+	clksel = 1;
+#endif
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, clksel);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + CPU_UART_CLKSEL, clksel);
+#ifdef CONFIG_TANGO3
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART2_base + CPU_UART_CLKSEL, clksel);
+#endif
+
+	/*
+	 * show KERN_DEBUG message on console
+	 */
+	do_syslog(8, NULL, 8);
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+	/* initialize uart and register early console */
+	prom_console_register();
+#endif
+
+	/* warn user if we use failsafe values for xenv */
+	if (xenv_res)
+		printk("Invalid XENV content, using failsafe values\n");
+	tangox_device_info();
+
+	/*
+	 * compute kernel memory start address/size
+	 * _text section gives kernel address start
+	 */
+	em8xxx_kmem_start = ((unsigned long)(&_text)) & PAGE_MASK;
+
+#if ((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE<<20) > MAX_KERNEL_MEMSIZE)
+	em8xxx_kmem_size = ((MAX_KERNEL_MEMSIZE + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+#else
+	em8xxx_kmem_size = (((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE << 20) + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+#endif
+
+#ifdef CONFIG_TANGO3
+	if (em8xxx_kmem_size > max_remap_size)
+		em8xxx_kmem_size = max_remap_size;
+
+#ifdef CONFIG_TANGOX_XENV_READ
+	{
+		unsigned long max_d0_size = 0, max_d1_size = 0, tmp;
+		unsigned int size = sizeof(unsigned long);
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_RUAMM0_GA, &tmp, &size) == 0) 
+				&& (size == sizeof(unsigned long))) 
+			max_d0_size = tmp - MEM_BASE_dram_controller_0;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_RUAMM1_GA, &tmp, &size) == 0) 
+				&& (size == sizeof(unsigned long))) 
+			max_d1_size = tmp - MEM_BASE_dram_controller_1;
+		em8xxx_max_dx_size = (phy_remap >= MEM_BASE_dram_controller_1) ? max_d1_size : max_d0_size;
+	}
+	if ((em8xxx_max_dx_size != 0) && (em8xxx_kmem_size > em8xxx_max_dx_size)) { /* don't push into RUAMM area */
+		em8xxx_kmem_size = em8xxx_max_dx_size;
+		printk("Maximum kernel memory size is 0x%08lx with RUAMM restriction.\n", em8xxx_kmem_size);
+	}
+#endif
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(CPU_REMAP_SPACE);
+	update_lrrw_kend(em8xxx_kmem_end);
+#else
+	/*
+	 * check/fill the memcfg
+	 */
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(MEM_BASE_dram_controller_0);
+	m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+	if (is_valid_memcfg(m) == 0) {
+		printk("Invalid MEMCFG, creating new one at 0x%08x.\n", MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+		memset(m, 0, sizeof (memcfg_t));
+		m->signature = MEMCFG_SIGNATURE;
+		m->dram0_size = TANGOX_SYSTEMRAM_ACTUALSIZE;
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	} else {
+		printk("Valid MEMCFG found at 0x%08x.\n", MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	}
+#endif
+
+	/*
+	 * tell kernel about available memory size/offset
+	 */
+#ifdef CONFIG_TANGO3
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(CPU_REMAP_SPACE);
+	add_memory_region(CPU_REMAP_SPACE + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#else
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(MEM_BASE_dram_controller_0_alias);
+	add_memory_region(MEM_BASE_dram_controller_0_alias + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#endif
+
+#ifndef CONFIG_TANGOX_IGNORE_CMDLINE
+	/*
+	 * set up correct linux command line according to XENV, memcfg
+	 * and YAMON args, if not told to ignore them
+	 */
+
+#ifdef CONFIG_TANGOX_XENV_READ
+	/* If specified by xenv, override the command line */
+	if (tangox_xenv_cmdline())
+		strcpy(arcs_cmdline, tangox_xenv_cmdline());
+#ifdef CONFIG_CMDLINE
+	else
+		strcpy(arcs_cmdline, CONFIG_CMDLINE);
+#endif
+#else
+	strcpy(arcs_cmdline, CONFIG_CMDLINE);
+#endif
+
+	/* If specified by memcfg, override the command line */
+//	if (m->linux_cmd != 0 && strlen((char *)KSEG1ADDR(m->linux_cmd)) > 0)
+//disabled. e.m. 2006feb3rd		strcpy(arcs_cmdline, (char *)KSEG1ADDR(m->linux_cmd));
+
+	/* take regular args given by bootloader */
+	if ((fw_arg0 > 1) && (fw_arg0 < 65)) { /* Up to 64 arguments */
+		int argc, i, pos;
+		char **argv;
+
+		argc = fw_arg0;
+		arcs_cmdline[0] = '\0';
+		argv = (char **) fw_arg1;
+		pos = 0;
+		for (i = 1; i < argc; i++) {
+			int len;
+
+			len = strlen(argv[i]);
+			if (pos + 1 + len + 1 > sizeof (arcs_cmdline))
+				break;
+			if (pos)
+				arcs_cmdline[pos++] = ' ';
+			strcpy(arcs_cmdline + pos, argv[i]);
+			pos += len;
+		}
+	}
+#else
+#ifdef CONFIG_CMDLINE
+	strcpy(arcs_cmdline, CONFIG_CMDLINE);
+#endif
+#endif /* !CONFIG_TANGOX_IGNORE_CMDLINE */
+
+	mips_machgroup = MACH_GROUP_SIGMADESIGNS;
+	mips_machtype = MACH_TANGOX;
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) 
+unsigned long __init prom_free_prom_memory(void)
+{
+	return 0;
+}
+#else
+void __init prom_free_prom_memory(void)
+{
+	return;
+}
+#endif
+EXPORT_SYMBOL(tangox_get_sysclock);
+EXPORT_SYMBOL(tangox_get_cpuclock);
+EXPORT_SYMBOL(tangox_get_dspclock);
+EXPORT_SYMBOL(tangox_get_pllclock);
+
+unsigned long tangox_chip_id(void)
+{
+	return (((gbus_read_reg32(REG_BASE_host_interface + PCI_REG0) & 0xffff) << 16) |
+                        (gbus_read_reg32(REG_BASE_host_interface + PCI_REG1) & 0xff));
+}
+
+int is_tango2_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return (chip == 0x8630) ? 1 : 0;
+}
+
+static inline int is_tango2_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	return (is_tango2_chip() && rev == revid) ? 1 : 0;
+}
+
+int is_tango2_es123(void)
+{
+	return(is_tango2_revision(0x81));
+}
+
+int is_tango2_es45(void)
+{
+	return(is_tango2_revision(0x82));
+}
+
+int is_tango2_es6(void)
+{
+	return(is_tango2_revision(0x83));
+}
+
+int is_tango2_es7(void)
+{
+	return(is_tango2_revision(0x84));
+}
+
+int is_tango2_es89(void)
+{
+	return(is_tango2_revision(0x85) || is_tango2_revision(0x86));
+}
+
+static inline int is_tango3_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	if (!is_tango3_chip())
+		return(0);
+	else {
+		switch(chip_id) {
+			case 0x8652:
+				rev += 2;
+			case 0x8654:
+			case 0x8644:
+				return((rev == revid) ? 1 : 0);
+			default:
+				return(0);
+		}
+	}
+}
+
+int is_tango3_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return ((chip == 0x8640) || (chip == 0x8650)) ? 1 : 0;
+}
+
+int is_tango3_es1(void)
+{
+	return(is_tango3_revision(0x1));
+}
+
+int is_tango3_es2(void)
+{
+	return(is_tango3_revision(0x2));
+}
+
+int is_tango3_es3(void)
+{
+	return(is_tango3_revision(0x3));
+}
+
+int is_tango3_es4(void)
+{
+	return(is_tango3_revision(0x4));
+}
+
+int is_tango3_es5(void)
+{
+	return(is_tango3_revision(0x5));
+}
+
+EXPORT_SYMBOL(tangox_chip_id);
+EXPORT_SYMBOL(is_tango2_chip);
+EXPORT_SYMBOL(is_tango3_chip);
+EXPORT_SYMBOL(is_tango2_es123);
+EXPORT_SYMBOL(is_tango2_es45);
+EXPORT_SYMBOL(is_tango2_es6);
+EXPORT_SYMBOL(is_tango2_es7);
+EXPORT_SYMBOL(is_tango2_es89);
+EXPORT_SYMBOL(is_tango3_es1);
+EXPORT_SYMBOL(is_tango3_es2);
+EXPORT_SYMBOL(is_tango3_es3);
+EXPORT_SYMBOL(is_tango3_es4);
+EXPORT_SYMBOL(is_tango3_es5);
+#ifdef CONFIG_TANGO3
+EXPORT_SYMBOL(phy_remap);
+EXPORT_SYMBOL(max_remap_size);
+#endif
+
+int tangox_get_order(unsigned long size)
+{
+	return(get_order(size));
+}
+EXPORT_SYMBOL(tangox_get_order);
+
+void tangox_do_timer(unsigned long ticks)
+{
+	extern void do_timer(unsigned long ticks);
+
+	write_seqlock(&xtime_lock);
+	do_timer(ticks);
+	write_sequnlock(&xtime_lock);
+}
+  
+EXPORT_SYMBOL(tangox_do_timer);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/setup.c linux-2.6.22.19/arch/mips/tangox/setup.c
--- linux-2.6.22.19.ref/arch/mips/tangox/setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/setup.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,505 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * arch/mips/tangox/setup.c
+ *     The setup file for tango2/tango3.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+#include <asm/time.h>
+#include <asm/serial.h>
+
+#include "setup.h"
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+extern unsigned long em86xx_tlb_dram1_map_base;
+extern unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_cpu_block + (r), (v))
+
+#ifdef CONFIG_PCI
+extern void tangox_pci_shutdown(void);
+#endif
+
+#ifdef CONFIG_TANGO2
+/*
+ * we use xrpc to reboot
+*/
+struct xrpc_block_header {
+	u32 callerid;
+	u32 xrpcid;
+
+	u32 param0;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+
+	u32 headerandblocksize;
+};
+
+#define XRPC_ID_REBOOT		19
+#define SOFT_IRQ_XRPC		(1 << 4)
+#endif
+
+void tangox_machine_restart(char *command)
+{
+	unsigned long tmp;
+	int i;
+#ifdef CONFIG_TANGO2
+ 	struct xrpc_block_header *pB;
+	unsigned long base_addr;
+	int loop;
+#endif
+
+        local_irq_disable();
+
+#ifdef CONFIG_PCI
+	tangox_pci_shutdown();
+#endif
+
+	/* Resetting TangoX EHCI */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1410);
+	tmp &= ~1;
+	gbus_write_reg32(REG_BASE_host_interface + 0x1410, tmp);
+	mdelay(5);
+
+	/* Resetting TangoX OHCI */
+	gbus_write_reg32(REG_BASE_host_interface + 0x1514, 1<<31);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1504, 0);
+	mdelay(5);
+
+	/* Resetting internal USB PHY in USB Control space */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1700);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp | 1);
+	udelay(30);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp);
+	mdelay(5);
+
+	/* Resetting internal OHCI in USB OHCI space*/
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1508);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1508, tmp | 0x01);
+
+	/* Reseting OHCI dpll, it says the bit is for simulation */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1700);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp | (1<<19));
+	mdelay(1);
+
+#if defined(CONFIG_TANGO2) 
+	/* Resetting ethernet interface */
+	gbus_write_reg32(REG_BASE_host_interface + 0x7018, 0);
+	gbus_write_reg32(REG_BASE_host_interface + 0x701c, 0);
+	gbus_write_reg32(REG_BASE_host_interface + 0x7000, 1);
+	for (i = 0; (i < 10) && (gbus_read_reg32(REG_BASE_host_interface + 0x7000) & 1); i++)
+		mdelay(1);
+
+	/* Resetting Video, MPEG0/MPEG1 blocks */ 
+	gbus_write_reg32(REG_BASE_display_block + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_display_block + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Transport demux block */
+	gbus_write_reg32(REG_BASE_demux_engine + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_demux_engine + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Audio0/1, host interface blocks */
+	gbus_write_reg32(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_host_interface + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_host_interface + G2L_RESET_CONTROL, 2);
+#endif
+
+	/* restore remap registers to boot state */
+	for (i = 0; 
+#ifdef CONFIG_TANGO2
+		i < 5; 
+#elif defined(CONFIG_TANGO3)
+		i < 8; 
+#endif
+		i++) {
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + i * 4, em8xxx_remap_registers[i]);
+	}
+	iob();
+
+	/* Now to handle CPU side */
+
+#ifdef CONFIG_TANGO3
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	/* Using watchdog to trigger reset here */
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0x80); 
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration, 0x1); /* Use XTAL_IN as source */
+
+	/* For ~100 usec delay */
+	gbus_write_reg32(REG_BASE_system_block + SYS_watchdog_counter, TANGOX_BASE_FREQUENCY / 10000);
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0); /* Start counting */
+#else
+	/* Don't use watchdog to reboot */
+	printk("System rebooting ...\n");
+#endif
+#else
+	/* nowhere to  jump, everything is  in xload format,  lets ask
+	 * xpu to reboot */
+	base_addr = DMEM_BASE_audio_engine_0;
+
+	pB = (struct xrpc_block_header *)base_addr;
+	gbus_write_reg32((unsigned long)&pB->callerid, 0);
+	gbus_write_reg32((unsigned long)&pB->headerandblocksize,
+		    (sizeof(struct xrpc_block_header) + 63) & ~63);
+	gbus_write_reg32((unsigned long)&pB->xrpcid, XRPC_ID_REBOOT);
+
+	/* try to lock xrpc mutex for at most 1 sec */
+	for (loop = 0; loop < 1000; loop++) {
+		if (!gbus_read_reg32((RMuint32)XRPC_MUTEX))
+			break;
+		mdelay(1);
+	}
+	gbus_write_reg32(REG_BASE_cpu_block + LR_XPU_STAGE, (unsigned long)pB);
+
+	/* cross our fingers now */
+	gbus_write_reg32(REG_BASE_irq_handler_block + CPU_irq_softset,
+		    SOFT_IRQ_XRPC);
+#endif
+	while (1); /* wait forever */
+}
+
+void tangox_machine_halt(void)
+{
+	while (1); /* wait forever */
+}
+
+void tangox_machine_power_off(void)
+{
+	while (1);
+}
+
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+union tangox_cycle_cnt_union {
+	u64 cycle64;
+	u32 cycle32[2];
+};
+union tangox_cycle_cnt_union tangox_cycle_cnt;
+static u32 old_xtal_cnt = 0;
+
+EXPORT_SYMBOL(tangox_cycle_cnt);
+
+struct clocksource clocksource_tangox = {
+	.name		= "TANGOX",
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static cycle_t tangox_get_cycles(void)
+{
+	tangox_cycle_cnt.cycle32[0] = (u32)gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	if (old_xtal_cnt > tangox_cycle_cnt.cycle32[0])
+		tangox_cycle_cnt.cycle32[1]++;
+
+	old_xtal_cnt = tangox_cycle_cnt.cycle32[0];
+	return (cycle_t)tangox_cycle_cnt.cycle64;
+}
+#endif
+
+static void __init tangox_time_init(void)
+{
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+	u64 temp;
+	u32 shift;
+#endif
+
+	mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+	/* Setup clock source from SYS_xtal_in_cnt */
+	clocksource_tangox.rating = em8xxx_cpu_frequency / 1000000;
+	tangox_cycle_cnt.cycle32[0] = old_xtal_cnt = (u32)gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	tangox_cycle_cnt.cycle32[1] = 0;
+
+	/* Find a shift value */
+	for (shift = 32; shift > 0; shift--) {
+		temp = (u64) NSEC_PER_SEC << shift;
+		do_div(temp, TANGOX_BASE_FREQUENCY);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	clocksource_tangox.shift = shift;
+	clocksource_tangox.mult = (u32)temp;
+	clocksource_tangox.read = tangox_get_cycles;
+
+	clocksource_register(&clocksource_tangox);
+#endif
+}
+
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+/*
+ * two variants for linux system timer , we can use internal cpu timer
+ * or hw timer0
+ */
+/*
+ * CPU_time0_load
+ *  clock / HZ / (2 * prescale)
+ * CPU_time0_ctrl
+ *  PS(D2-3) : prescale. 0x00 = 1, 0x01 = 16, 0x10 = 256
+ *    There is a bug, and the actual prescale is 0x01 = 32, 0x10 = 512
+ *  M(D6) : periodic mode
+ *  E(D7) : enable
+ */
+#define TICKS_PER_SEC           em8xxx_sys_frequency
+//#define TIMER_PRESCALE          2
+//#define TIMER_PRESCALEBITS      1
+//#define TIMER_PRESCALE          32
+//#define TIMER_PRESCALEBITS      5
+//#define TIMER_PRESCALE          512
+//#define TIMER_PRESCALEBITS      9
+//#define TIMER_RELOAD            ((TICKS_PER_SEC / HZ) >> (TIMER_PRESCALEBITS))
+
+#define TIMER_ENABLE            0x80    // D7
+#define TIMER_PERIODIC          0x40    // D6
+#define TIMER_PRESCALE_1        0x00    // D[2-3] = 00b
+#define TIMER_PRESCALE_32       0x04    // D[2-3] = 01b
+#define TIMER_PRESCALE_512      0x08    // D[2-3] = 10b
+
+static const unsigned timer_prescale_bit[3] = { 1, 5, 9 };
+static const unsigned timer_prescale[3] = { TIMER_PRESCALE_1, TIMER_PRESCALE_32, TIMER_PRESCALE_512 };
+
+static void tangox_timer_ack(void)
+{
+	WR_CPU_REG32(CPU_time0_clr, 1);
+}
+
+void reset_cpu_timer0(void)
+{
+	int idx;
+	unsigned int timer_reload;
+
+	/* CPU_time0_load  register contains  just  16-bits value  So,
+	   take care not to let the value to overflow */
+	for (idx = 0; idx < 3; idx++) {
+		timer_reload = (TICKS_PER_SEC / HZ) >> timer_prescale_bit[idx];
+		if ((timer_reload & 0xffff0000) == 0)
+			break;
+	}
+	if (idx >= 3)
+		BUG();
+
+	WR_CPU_REG32(CPU_time0_load, timer_reload);
+	WR_CPU_REG32(CPU_time0_ctrl, TIMER_ENABLE | TIMER_PERIODIC | timer_prescale[idx]);
+	WR_CPU_REG32(CPU_time0_clr, 1);
+}
+
+/*
+ * Setup Timer0 as the source
+ */
+void __init plat_timer_setup(struct irqaction *irq)
+{
+	int idx;
+	unsigned int timer_reload;
+
+	/* CPU_time0_load  register contains  just  16-bits value  So,
+	   take care not to let the value to overflow */
+	for (idx = 0; idx < 3; idx++) {
+		timer_reload = (TICKS_PER_SEC / HZ) >> timer_prescale_bit[idx];
+		if ((timer_reload & 0xffff0000) == 0)
+			break;
+	}
+	if (idx >= 3)
+		BUG();
+
+	WR_CPU_REG32(CPU_time0_load, timer_reload);
+	WR_CPU_REG32(CPU_time0_ctrl, TIMER_ENABLE | TIMER_PERIODIC | timer_prescale[idx]);
+	WR_CPU_REG32(CPU_time0_clr, 1);
+
+	setup_irq(LOG2_CPU_TIMER0_INT + IRQ_CONTROLLER_IRQ_BASE, irq);
+
+	/* set ack callback */
+	mips_timer_ack = tangox_timer_ack;
+
+	/* Clear heart beat counter */
+	WR_CPU_REG32(LR_HB_CPU, 0);
+}
+#else
+/*
+ * Setup CPU timer (compare/count) as source
+ */
+void __init plat_timer_setup(struct irqaction *irq)
+{
+#ifdef CONFIG_TANGO3
+	setup_irq(MIPS_CPU_IRQ_BASE + ((read_c0_intctl() >> 29) & 7), irq);
+#else
+	setup_irq(MIPS_CPU_IRQ_BASE + STATUSB_IP7 - STATUSB_IP0, irq);
+#endif
+
+	/* Clear heart beat counter */
+	WR_CPU_REG32(LR_HB_CPU, 0);
+}
+#endif
+
+/*
+ * setup remap registers, we may need  to use ioremap() so we can't do
+ * this in plat_setup, this function is set as arch_initcall().
+ */
+static int __init tangox_remap_setup(void)
+{
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+	memcfg_t *m;
+#endif
+
+#if defined(CONFIG_TANGO2) 
+	/*
+	 * Program CPU_remap so we can see full 256MB space in KSEG0 /
+	 * KSEG1
+	 */
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	/*
+	 * Use TLB mapping to map the DRAM1 (size specified by memcfg)
+	 * into KSEG2
+	 */
+	m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+
+	if (m->dram1_size) {
+		em86xx_tlb_dram1_map_size = ((m->dram1_size > 0x20000000) ? 
+			0x20000000 : m->dram1_size); /* Max. 512MB */
+		em86xx_tlb_dram1_map_base =
+			(unsigned long)ioremap(MEM_BASE_dram_controller_1_alias,
+					       m->dram1_size);
+		printk("tangox: creating TLB mapping for 0x%08x at 0x%08lx, "
+		       "size 0x%08lx.\n", MEM_BASE_dram_controller_1_alias,
+		       em86xx_tlb_dram1_map_base, em86xx_tlb_dram1_map_size);
+	} else {
+		printk("tangox: dram1 size is 0, _not_ creating mapping\n");
+	}
+#else
+	/*
+	 * Use remap strategy (CPU_remap3/4 for 128MB resolution)
+	 */
+	printk("tangox: creating CPU mapping for 0x%08x at 0x%08x, "
+	       "size 0x%08x.\n", MEM_BASE_dram_controller_1_alias,
+	       CPU_remap3_address, 0x08000000);
+
+	/*
+	 * remap dram controller 1 at 0x08000000 -> 0x0fffffff (128MB)
+	 * so Linux can see it in KSEG[01]
+	 */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap3,
+		    MEM_BASE_dram_controller_1_alias);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap4,
+		    MEM_BASE_dram_controller_1_alias + 0x04000000);
+	iob();
+#endif
+#endif
+
+	return 0;
+}
+
+arch_initcall(tangox_remap_setup);
+
+extern int tangox_uart_enabled(int uart);
+extern int tangox_uart_baudrate(int uart);
+extern int tangox_uart_console_port(void);
+
+#ifdef CONFIG_SERIAL_8250
+struct tangox_uart_info {
+	int irq;
+	unsigned long base;
+};
+
+#ifdef CONFIG_TANGO3
+static struct tangox_uart_info uinfo[3] = {
+	{ LOG2_CPU_UART0_INT, CPU_UART0_base },
+	{ LOG2_CPU_UART1_INT, CPU_UART1_base },
+	{ LOG2_CPU_UART2_INT, CPU_UART2_base },
+};
+#else
+static struct tangox_uart_info uinfo[2] = {
+	{ LOG2_CPU_UART0_INT, CPU_UART0_base },
+	{ LOG2_CPU_UART1_INT, CPU_UART1_base },
+};
+#endif
+#endif
+
+void __init plat_mem_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	int i, idx;
+	struct uart_port uart;
+	int console_port = tangox_uart_console_port();
+#endif
+
+	board_time_init = tangox_time_init;
+	//board_timer_setup = tangox_timer_setup;
+	_machine_restart = tangox_machine_restart;
+	_machine_halt = tangox_machine_halt;
+	//_machine_power_off = tangox_machine_power_off;
+
+#ifdef CONFIG_SERIAL_8250
+	/* Handle console first */
+	memset(&uart, 0, sizeof (uart));
+	uart.line = 0;
+	uart.uartclk = tangox_uart_baudrate(console_port) << 4;
+	uart.irq = IRQ_CONTROLLER_IRQ_BASE + uinfo[console_port].irq;
+	uart.flags = UPF_BOOT_AUTOCONF /* | UPF_SHARE_IRQ */;
+	uart.membase = (unsigned char *)(REG_BASE_cpu_block + uinfo[console_port].base);
+	uart.iotype = UPIO_MEM;
+	uart.regshift = 2;
+
+	if (early_serial_setup(&uart))
+		printk("early_serial_setup failed\n");
+
+	for (i = 0, idx = 1; (i < CONFIG_SERIAL_8250_NR_UARTS) && (i < (sizeof(uinfo) / sizeof(uinfo[0]))); i++) {
+		if (console_port == i)
+			continue;
+
+		memset(&uart, 0, sizeof (uart));
+		uart.line = idx++;
+		uart.uartclk = tangox_uart_baudrate(i) << 4;
+		uart.irq = IRQ_CONTROLLER_IRQ_BASE + uinfo[i].irq;
+		uart.flags = UPF_BOOT_AUTOCONF /* | UPF_SHARE_IRQ */;
+		uart.membase = (unsigned char *)(REG_BASE_cpu_block + uinfo[i].base);
+		uart.iotype = UPIO_MEM;
+		uart.regshift = 2;
+
+		if (early_serial_setup(&uart))
+			printk("early_serial_setup failed\n");
+	}
+#endif
+
+	/*
+	 * set I/O /mem regions limit
+	 */
+	ioport_resource.start = 0;
+	ioport_resource.end = 0x80000000UL - 1;
+	iomem_resource.start = 0;
+	iomem_resource.end = 0x80000000UL - 1;
+
+}
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/setup.h linux-2.6.22.19/arch/mips/tangox/setup.h
--- linux-2.6.22.19.ref/arch/mips/tangox/setup.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/setup.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,61 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * misc vars/func shared by platform setup code
+ */
+
+#ifndef __SETUP_H
+#define __SETUP_H
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <linux/interrupt.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <linux/interrupt.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/hardware.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/*
+ * in console.c
+ */
+void prom_console_register(void);
+
+/*
+ * in prom.c
+ */
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+#ifdef CONFIG_TANGO2
+extern unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+extern unsigned long em8xxx_remap_registers[8];
+#endif
+
+unsigned long tangox_get_cpuclock(void);
+unsigned long tangox_get_sysclock(void);
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/sha.c linux-2.6.22.19/arch/mips/tangox/sha.c
--- linux-2.6.22.19.ref/arch/mips/tangox/sha.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/sha.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,407 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <linux/version.h>
+#include <asm/scatterlist.h>
+#include <asm/byteorder.h>
+
+#include "sha.h"
+	
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_HMAC_BLOCK_SIZE	64
+#define SHA_WORKSPACE_WORDS 	80
+
+static void __init __sha1_init(struct sha1_ctx *sctx)
+{
+	static const struct sha1_ctx initstate = {
+	  0,
+	  { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 },
+	  { 0, }
+	};
+	*sctx = initstate;
+}
+
+static void __init __sha1_update(struct sha1_ctx *sctx, const u8 *data, unsigned int len)
+{
+	unsigned int partial, done;
+	const u8 *src;
+
+	partial = sctx->count & 0x3f;
+	sctx->count += len;
+	done = 0;
+	src = data;
+
+	if ((partial + len) > 63) {
+		u32 temp[SHA_WORKSPACE_WORDS];
+
+		if (partial) {
+			done = -partial;
+			memcpy(sctx->buffer + partial, data, done + 64);
+			src = sctx->buffer;
+		}
+
+		do {
+			sha_transform(sctx->state, src, temp);
+			done += 64;
+			src = data + done;
+		} while (done + 63 < len);
+
+		memset(temp, 0, sizeof(temp));
+		partial = 0;
+	}
+	memcpy(sctx->buffer + partial, src, len - done);
+}
+
+/* Add padding and return the message digest. */
+static void __init __sha1_final(struct sha1_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	u32 i, index, padlen;
+	__be64 bits;
+	static const u8 padding[64] = { 0x80, };
+
+	bits = cpu_to_be64(sctx->count << 3);
+
+	/* Pad out to 56 mod 64 */
+	index = sctx->count & 0x3f;
+	padlen = (index < 56) ? (56 - index) : ((64+56) - index);
+	__sha1_update(sctx, padding, padlen);
+
+	/* Append length */
+	__sha1_update(sctx, (const u8 *)&bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 5; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Wipe context */
+	memset(sctx, 0, sizeof *sctx);
+}
+#endif /* CONFIG_CRYPTO_SHA1 */
+
+#ifdef CONFIG_CRYPTO_SHA1
+void __init sha1_full(u8 *digest, const u8 *src, u32 len)
+{
+	int i;
+	u8 tmp;
+
+	struct sha1_ctx ctx;
+
+	__sha1_init(&ctx);
+	__sha1_update(&ctx, src, len);
+	__sha1_final(&ctx, digest);
+
+	for (i = 0; i < SHA1_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA1_DIGEST_SIZE - i - 1];
+		digest[SHA1_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+
+#define SHA256_DIGEST_SIZE	32
+#define SHA256_HMAC_BLOCK_SIZE	64
+
+static inline u32 Ch(u32 x, u32 y, u32 z)
+{
+	return z ^ (x & (y ^ z));
+}
+
+static inline u32 Maj(u32 x, u32 y, u32 z)
+{
+	return (x & y) | (z & (x | y));
+}
+
+#define e0(x)       (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22))
+#define e1(x)       (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25))
+#define s0(x)       (ror32(x, 7) ^ ror32(x,18) ^ (x >> 3))
+#define s1(x)       (ror32(x,17) ^ ror32(x,19) ^ (x >> 10))
+
+#define H0         0x6a09e667
+#define H1         0xbb67ae85
+#define H2         0x3c6ef372
+#define H3         0xa54ff53a
+#define H4         0x510e527f
+#define H5         0x9b05688c
+#define H6         0x1f83d9ab
+#define H7         0x5be0cd19
+
+static inline void LOAD_OP(int I, u32 *W, const u8 *input)
+{
+	W[I] = __be32_to_cpu( ((__be32*)(input))[I] );
+}
+
+static inline void BLEND_OP(int I, u32 *W)
+{
+	W[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];
+}
+
+static void __init __sha256_transform(u32 *state, const u8 *input)
+{
+	u32 a, b, c, d, e, f, g, h, t1, t2;
+	u32 W[64];
+	int i;
+
+	/* load the input */
+	for (i = 0; i < 16; i++)
+		LOAD_OP(i, W, input);
+
+	/* now blend */
+	for (i = 16; i < 64; i++)
+		BLEND_OP(i, W);
+    
+	/* load the state into our registers */
+	a=state[0];  b=state[1];  c=state[2];  d=state[3];
+	e=state[4];  f=state[5];  g=state[6];  h=state[7];
+
+	/* now iterate */
+	t1 = h + e1(e) + Ch(e,f,g) + 0x428a2f98 + W[ 0];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x71374491 + W[ 1];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xb5c0fbcf + W[ 2];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xe9b5dba5 + W[ 3];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x3956c25b + W[ 4];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x59f111f1 + W[ 5];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x923f82a4 + W[ 6];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xab1c5ed5 + W[ 7];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xd807aa98 + W[ 8];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x12835b01 + W[ 9];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x243185be + W[10];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x550c7dc3 + W[11];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x72be5d74 + W[12];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x80deb1fe + W[13];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x9bdc06a7 + W[14];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xc19bf174 + W[15];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xe49b69c1 + W[16];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xefbe4786 + W[17];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x0fc19dc6 + W[18];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x240ca1cc + W[19];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x2de92c6f + W[20];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x4a7484aa + W[21];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x5cb0a9dc + W[22];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x76f988da + W[23];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x983e5152 + W[24];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xa831c66d + W[25];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xb00327c8 + W[26];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xbf597fc7 + W[27];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0xc6e00bf3 + W[28];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xd5a79147 + W[29];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x06ca6351 + W[30];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x14292967 + W[31];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x27b70a85 + W[32];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x2e1b2138 + W[33];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x4d2c6dfc + W[34];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x53380d13 + W[35];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x650a7354 + W[36];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x766a0abb + W[37];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x81c2c92e + W[38];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x92722c85 + W[39];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xa2bfe8a1 + W[40];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xa81a664b + W[41];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xc24b8b70 + W[42];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xc76c51a3 + W[43];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0xd192e819 + W[44];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xd6990624 + W[45];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0xf40e3585 + W[46];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x106aa070 + W[47];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x19a4c116 + W[48];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x1e376c08 + W[49];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x2748774c + W[50];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x34b0bcb5 + W[51];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x391c0cb3 + W[52];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x4ed8aa4a + W[53];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x5b9cca4f + W[54];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x682e6ff3 + W[55];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x748f82ee + W[56];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x78a5636f + W[57];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x84c87814 + W[58];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x8cc70208 + W[59];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x90befffa + W[60];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xa4506ceb + W[61];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0xbef9a3f7 + W[62];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xc67178f2 + W[63];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	state[0] += a; state[1] += b; state[2] += c; state[3] += d;
+	state[4] += e; state[5] += f; state[6] += g; state[7] += h;
+
+	/* clear any sensitive info... */
+	a = b = c = d = e = f = g = h = t1 = t2 = 0;
+	memset(W, 0, 64 * sizeof(u32));
+}
+
+static void __init __sha256_init(struct sha256_ctx *sctx)
+{
+	sctx->state[0] = H0;
+	sctx->state[1] = H1;
+	sctx->state[2] = H2;
+	sctx->state[3] = H3;
+	sctx->state[4] = H4;
+	sctx->state[5] = H5;
+	sctx->state[6] = H6;
+	sctx->state[7] = H7;
+	sctx->count[0] = sctx->count[1] = 0;
+}
+
+static void __init __sha256_update(struct sha256_ctx *sctx, const u8 *data, unsigned int len)
+{
+	unsigned int i, index, part_len;
+
+	/* Compute number of bytes mod 128 */
+	index = (unsigned int)((sctx->count[0] >> 3) & 0x3f);
+
+	/* Update number of bits */
+	if ((sctx->count[0] += (len << 3)) < (len << 3)) {
+		sctx->count[1]++;
+		sctx->count[1] += (len >> 29);
+	}
+
+	part_len = 64 - index;
+
+	/* Transform as many times as possible. */
+	if (len >= part_len) {
+		memcpy(&sctx->buf[index], data, part_len);
+		__sha256_transform(sctx->state, sctx->buf);
+
+		for (i = part_len; i + 63 < len; i += 64)
+			__sha256_transform(sctx->state, &data[i]);
+		index = 0;
+	} else {
+		i = 0;
+	}
+	
+	/* Buffer remaining input */
+	memcpy(&sctx->buf[index], &data[i], len-i);
+}
+
+static void __init __sha256_final(struct sha256_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	__be32 bits[2];
+	unsigned int index, pad_len;
+	int i;
+	static const u8 padding[64] = { 0x80, };
+
+	/* Save number of bits */
+	bits[1] = cpu_to_be32(sctx->count[0]);
+	bits[0] = cpu_to_be32(sctx->count[1]);
+
+	/* Pad out to 56 mod 64. */
+	index = (sctx->count[0] >> 3) & 0x3f;
+	pad_len = (index < 56) ? (56 - index) : ((64+56) - index);
+	__sha256_update(sctx, padding, pad_len);
+
+	/* Append length (before padding) */
+	__sha256_update(sctx, (const u8 *)bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 8; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Zeroize sensitive information. */
+	memset(sctx, 0, sizeof(*sctx));
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+void __init sha256_full(u8 *digest, const u8 *src, u32 len)
+{
+	int i;
+	u8 tmp;
+	struct sha256_ctx ctx;
+
+	__sha256_init(&ctx);
+	__sha256_update(&ctx, src, len);
+	__sha256_final(&ctx, digest);
+
+	for (i = 0; i < SHA256_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA256_DIGEST_SIZE - i - 1];
+		digest[SHA256_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/sha.h linux-2.6.22.19/arch/mips/tangox/sha.h
--- linux-2.6.22.19.ref/arch/mips/tangox/sha.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/sha.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,35 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SHA_H__
+#define __SHA_H__
+
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_DIGEST_SIZE        20
+
+struct sha1_ctx {
+	u64 count;
+        u32 state[5];
+        u8 buffer[64];
+};
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+#define SHA256_DIGEST_SIZE      32
+
+struct sha256_ctx {
+	u32 count[2];
+        u32 state[8];
+        u8 buf[128];
+};
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/xenv.c linux-2.6.22.19/arch/mips/tangox/xenv.c
--- linux-2.6.22.19.ref/arch/mips/tangox/xenv.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/xenv.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,280 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include "setup.h"
+#include "xenv.h"
+#include "sha.h"
+
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#endif
+
+#if 1
+# define DPRINTK(fmt, args...)	printk(KERN_DEBUG "xenv: " fmt, ## args)
+#else
+# define DPRINTK(fmt, args...)
+#endif
+
+#if defined(CONFIG_TANGO2)
+#define XENV_DIGEST_SIZE   SHA1_DIGEST_SIZE
+void sha1_full(u8 *digest, const u8 *src, u32 len);
+#elif defined(CONFIG_TANGO3)
+#define XENV_DIGEST_SIZE   SHA256_DIGEST_SIZE
+void sha256_full(u8 *digest, const u8 *src, u32 len);
+#endif
+
+#define XENV_HDR_SIZE      (XENV_DIGEST_SIZE + 4)
+#define REC_SIZE(x)	   ((((u16)x[0] & 0xff) << 8) | ((u16)x[1] & 0xff))
+#define REC_ATTR(x)	   ((x[0] & 0xff) >> 4)
+
+#define xos_strlen(x)	   strlen(x)
+#define xos_strcmp(x,y)	   strcmp(x,y)
+#define xos_memcpy(x,y,z)  memcpy(x,y,z)
+
+void __init xenv_digest_full(u8 *digest, const u8 *src, u32 len)
+{
+#if defined(CONFIG_TANGO2)
+	sha1_full(digest, src, len);
+#elif defined(CONFIG_TANGO3)
+	sha256_full(digest, src, len);
+#endif
+}
+
+#if 0
+static void dump_digest(const u8 *digest)
+{
+	int i;
+	printk("Dump digest\n");
+	for (i = 0; i < XENV_DIGEST_SIZE; i++, digest++)
+		printk("%02x ", *digest);
+	printk("\n");
+}
+#endif
+
+/*
+ * check for valid XENV at given address
+ */
+int __init xenv_isvalid(u32 *base, u32 maxsize)
+{
+	u32 env_size = base[0];
+	u32 hash[XENV_DIGEST_SIZE/4];
+
+	if ((XENV_HDR_SIZE <= env_size) && (env_size <= maxsize)) {
+		memset(hash, 0, sizeof (hash));
+		xenv_digest_full((u8 *)hash, (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+		if (memcmp((const u8 *)(base + 1), hash, XENV_DIGEST_SIZE) != 0) {
+			DPRINTK("corrupted\n");
+			return -1;
+		}
+		/* valid xenv ! */
+		return env_size;
+	}
+	DPRINTK("runaway %d\n", env_size);
+	return -1;
+}
+
+int __init xenv_foreach(u32 *base, u32 size,
+			void (*cb)(char *recordname, void *data, u32 datasize))
+{
+	int i;
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	/* loop on each record name */
+	while (i < size) {
+		u16 rec_size;
+		char *p, *recordname;
+		void *data;
+		u32 key_len, data_len;
+
+		p = (char *)base + i;
+		rec_size = REC_SIZE(p);
+		recordname = p + 2;
+		key_len = strlen(recordname);
+		data = recordname + key_len + 1;
+		data_len = rec_size - 2 - key_len - 1;
+
+		cb(recordname, data, data_len);
+		i += rec_size;
+	}
+
+	return -1;
+}
+
+#ifdef CONFIG_TANGO3
+/* Use this to set xenv to lrrw */
+static int __init xenv_lookup(RMuint32 *base,RMuint32 size,RMascii *recordname)
+{
+	RMascii *p;
+	int i;
+	int env_size;
+	
+	env_size=xenv_isvalid((u32 *)base,size);
+	
+	if (env_size<0) 
+		return -2;
+	
+	// RMDBGLOG((LOCALDBG, "[%s]\n",recordname));
+	
+	p=(RMascii *)base;
+	i=XENV_HDR_SIZE; 			// jump over header
+	
+	while(i<env_size){
+		RMuint16 rec_size=((p[i]&0xf)<<8) + (((RMuint16)p[i+1])&0xff);
+
+		if (!xos_strcmp(recordname, p+i+2)) 
+			return i;
+		
+		i+=rec_size;
+	}
+	
+	return -1;
+}
+
+/* Use this to get xenv to lrrw/lrro */
+int __init xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize)
+{
+	RMascii *p = (RMascii *)base;
+	RMuint32 data_len;
+	RMuint32 key_len;
+	RMuint32 env_size;
+	
+	int i;	
+	
+	env_size=base[0];
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -2 /* RM_ERROR */;
+	if(i==-1) 
+		return -1 /* RM_NOT_FOUND */;
+
+	// else we found the record
+	key_len=xos_strlen(recordname);
+	data_len=((p[i] & 0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+	data_len-=2+key_len+1;
+	
+	if(data_len>*datasize) {
+		*datasize=data_len;
+
+		// RMDBGLOG((ENABLE,"cannot store result\n"));
+		return -3 /* RM_INSUFFICIENT_SIZE */;
+	}
+	
+	*datasize=data_len;
+	xos_memcpy(dst, p+i+2+key_len+1, data_len);
+
+	// RMDBGLOG((LOCALDBG, "found [%s], length %d\n",recordname,*datasize));
+
+	return 0 /* RM_OK */;
+}
+
+int __init xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize)
+{
+	RMascii *p;
+	RMuint32 env_size;
+	RMuint32 rec_attr;
+	RMuint32 rec_size;
+	RMuint32 key_len;
+	int i;
+
+	// RMDBGLOG((LOCALDBG, "[%s], length %d\n", recordname,datasize));
+	
+	p=(RMascii *)base;
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -1 /* RM_ERROR */;
+	env_size=base[0];
+
+	if(i>=0) {
+		// RMDBGLOG((LOCALDBG, "deleting record\n"));
+		
+		rec_attr=p[i]>>4;
+		rec_size=((p[i]&0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+			
+#if 0
+		if ((rec_attr==XENV_ATTR_RO)&&src) {
+			// RMDBGLOG((ENABLE,"wanna change ro record\n"));
+			return RM_INVALIDMODE;
+		}
+		
+		if (rec_attr==XENV_ATTR_OTP) {
+			// RMDBGLOG((ENABLE,"wanna change/clear otp record\n"));
+			return RM_INVALIDMODE;
+		}
+#endif
+
+		// delete the record. Supposes memcpy is implemented increasing.
+		xos_memcpy(p+i, p+i+rec_size, env_size-(i+rec_size));
+		env_size-=rec_size;
+	}
+		
+	// add the record at the end if needed.
+	if(src) {
+		i=env_size;
+		key_len=xos_strlen(recordname);
+		rec_size=2+key_len+1+datasize;
+
+		if((i+rec_size)>=size)
+			return -3 /* RM_INSUFFICIENT_SIZE */;
+		
+		p[i]=((attr&0xf)<<4) | ((rec_size>>8)&0xf);
+		p[i+1]=rec_size&0xff;
+		
+		xos_memcpy(p+i+2, recordname, key_len+1);
+		xos_memcpy(p+i+2+key_len+1, src, datasize);
+		
+		env_size+=rec_size;
+	}
+	
+	base[0]=env_size;
+	//full_sha256(base+1,(const RMuint8 *)(base+9),env_size-36,0);
+	xenv_digest_full((u8 *)(base+1), (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+
+	return 0 /* RM_OK */;
+}
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+void __init xenv_dump(u32 *base, u32 size)
+{
+	int i;
+	u32 records = 0;
+
+	printk("@%p\n", base);
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	while (i < size){
+		u8 rec_attr;
+		u16 rec_size;
+		char *p, *recordname, *x;
+		u32 key_len;
+
+		p = (char *)base + i;
+		rec_attr = REC_ATTR(p);
+		rec_size = REC_SIZE(p);
+		recordname = p + 2;
+		key_len = strlen(recordname);
+
+		printk("(0x%02x) [%s] =", rec_attr, recordname);
+		for (x = recordname + key_len + 1;
+		     x < recordname + rec_size - 2; x++)
+			printk(" %02x", (u8)*x);
+		printk(" .\n");
+
+		records++;
+		i += rec_size;
+	}
+
+	printk("%d records, %d bytes\n\n", records, size);
+}
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/xenv_config.c linux-2.6.22.19/arch/mips/tangox/xenv_config.c
--- linux-2.6.22.19.ref/arch/mips/tangox/xenv_config.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/xenv_config.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,802 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * Check and  read full xenv config  at boot if valid,  else will stop
+ * boot process or use failsafe values.
+ */
+
+#include "setup.h"
+#include "xenv.h"
+#include "xenvkeys.h"
+
+#include <linux/module.h>
+#include <asm/bootinfo.h>
+
+/*
+ * use CPU_remap1 to access XENV content
+ */
+#define TMP_REMAPPED_REG   CPU_remap1
+#define TMP_REMAPPED_BASE  CPU_remap1_address 
+#define TMP_REMAPPED_SIZE  0x00010000
+#define TMP_REMAPPED_MASK  ~(TMP_REMAPPED_SIZE-1)
+
+/*
+ * cached values of xenv content
+ */
+#define XENV_MAX_FLASH_PARTITIONS   16
+
+/*
+ * default is  to have one  partition on each  flash at offset  0 that
+ * span all the flash. If CONFIG_TANGOX_XENV_DEF_CSx_SIZE is set to 0,
+ * cs will be ignored.
+ */
+#ifdef CONFIG_TANGOX_XENV_READ_SAFE
+/* The data will be filled from XENV later */
+static u32 cs_flash_size[4] = { 0, 0, 0, 0 };
+static u32 flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = { { 0 }, { 0 }, { 0 }, { 0 }, };
+static u32 enabled_devices = 0;
+static u32 uart_baudrate = 0;
+static u32 uart_baudrates[3] = { 0, 0, 0 };
+static u32 uart_used_ports = 0;
+static u32 pcidev_irq_route[4] = { 0, 0, 0, 0 };
+static u32 uart_console_port = 0;
+#else
+static u32 cs_flash_size[4] = {
+	CONFIG_TANGOX_XENV_DEF_CS0_SIZE,
+	CONFIG_TANGOX_XENV_DEF_CS1_SIZE,
+	CONFIG_TANGOX_XENV_DEF_CS2_SIZE,
+	CONFIG_TANGOX_XENV_DEF_CS3_SIZE
+};
+
+static u32 flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = {
+	{ CONFIG_TANGOX_XENV_DEF_CS0_SIZE },
+	{ CONFIG_TANGOX_XENV_DEF_CS1_SIZE },
+	{ CONFIG_TANGOX_XENV_DEF_CS2_SIZE },
+	{ CONFIG_TANGOX_XENV_DEF_CS3_SIZE },
+};
+
+static u32 enabled_devices =
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID1 << PCI1_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID2 << PCI2_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID3 << PCI3_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID4 << PCI4_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ENET 
+	(CONFIG_TANGOX_XENV_DEF_ENET << ETHERNET_SHIFT) |
+#else
+	0 | 
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_FIP 
+	(CONFIG_TANGOX_XENV_DEF_FIP << FIP_SHIFT) |
+#else 
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CM 
+	(CONFIG_TANGOX_XENV_DEF_I2CM << I2CM_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CS 
+	(CONFIG_TANGOX_XENV_DEF_I2CS << I2CS_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_BMIDE 
+	(CONFIG_TANGOX_XENV_DEF_BMIDE << BMIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ISAIDE 
+	(CONFIG_TANGOX_XENV_DEF_ISAIDE << ISAIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_IR 
+	(CONFIG_TANGOX_XENV_DEF_IR << IR_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCIHOST
+	(CONFIG_TANGOX_XENV_DEF_PCIHOST << PCIHOST_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_USB 
+	(CONFIG_TANGOX_XENV_DEF_USB << USB_SHIFT)
+#else
+	0
+#endif
+	;
+
+static u32 uart_baudrate = CONFIG_TANGOX_XENV_DEF_BAUDRATE;
+static u32 uart_baudrates[3] = { CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE, };
+
+static u32 uart_used_ports = 
+#ifdef CONFIG_TANGOX_XENV_DEF_UART0
+		1 +
+#else
+		0 +
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_UART1
+		1;
+#else
+		0;
+#endif
+
+static u32 pcidev_irq_route[4] = { 
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+	CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+#else
+	0
+#endif
+};
+
+static u32 uart_console_port = CONFIG_TANGOX_XENV_DEF_CONSOLE_UART_PORT;
+#endif
+
+static u32 cs_flash_parts[4] = { 1, 1, 1, 1 };
+static u32 flash_parts_offset[4][XENV_MAX_FLASH_PARTITIONS] = { { 0 }, { 0 }, { 0 }, { 0 }, };
+static u32 scard_off_pin = 0;
+static u32 scard_cmd_pin = 0;
+static u32 scard_5v_pin = 0;
+#ifdef CONFIG_TANGO3
+static u32 scard1_off_pin = 0;
+static u32 scard1_cmd_pin = 0;
+static u32 scard1_5v_pin = 0;
+static u32 sata_channel_cfg = 0;
+#endif
+static u32 isaide_timing_slot = 0;
+static u32 isaide_irq = 0;
+
+static u32 xenv_gbus_addr = 0;
+
+/* mac address to use if xenv is not readable  */
+static const u8 def_mac_address[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x01 };
+static u8 mac_address[6];
+#ifdef CONFIG_TANGO3
+static u8 mac_address1[6];
+#endif
+
+/* for power saving (e.g. low frequency) */
+#ifdef CONFIG_TANGO2
+static u32 ps_pll3=0, ps_pll2=0, ps_pll1=0, ps_pll0=0, ps_mux=0, ps_d0cfg=0, ps_d1cfg=0, ps_d0delay=0, ps_d1delay=0;
+static u32 standby_pll3=0, standby_pll2=0, standby_pll1=0, standby_pll0=0, standby_mux=0, standby_d0cfg=0, standby_d1cfg=0, standby_d0delay=0, standby_d1delay=0;
+static u32 standby_gpiodir = 0, standby_gpiodata = 0;
+#endif
+
+#ifdef CONFIG_TANGO3
+#define MT3_HS_SIZE	140	/* sizeof(struct mt3_hw_settings_t) */
+static u32 ps_pll2=0, ps_pll0=0, ps_mt3_hs[MT3_HS_SIZE/sizeof(u32)];
+static u32 standby_pll2=0, standby_pll0=0, standby_mt3_hs[MT3_HS_SIZE/sizeof(u32)];
+static u32 standby_gpiodir = 0, standby_gpiodata = 0;
+#endif
+
+static char xenv_cmdline[CL_SIZE] = { 0 };
+
+#ifdef CONFIG_TANGO3
+static unsigned long zxenv[MAX_XENV_SIZE/sizeof(unsigned long)] __initdata = { 0 };
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_READ
+/*
+ * called for each entry found in xenv
+ */
+void __init xenv_val_cb(char *recordname, void *data, u32 datasize)
+{
+	char buf[64];
+	int i;
+
+#define CHECK_AND_STORE(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memcpy(&_var, data, _reqlen);				\
+		return;							\
+	}
+#define CHECK_AND_STORE1(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memset(&_var, 0, _reqlen);				\
+		memcpy(&_var, data, datasize);				\
+		return;							\
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ENABLED_DEVICES, 4, enabled_devices);
+	CHECK_AND_STORE(XENV_KEY_DEF_BAUDRATE, 4, uart_baudrate);
+	CHECK_AND_STORE(XENV_KEY_UART_USED_PORTS, 4, uart_used_ports);
+	CHECK_AND_STORE(XENV_KEY_CONSOLE_UART_PORT, 4, uart_console_port);
+
+	if (uart_console_port == 0) /* for backward compatibility */
+		uart_used_ports |= 1;
+
+	for (i = 0; i < 3; i++) {
+		sprintf(buf, XENV_KEYS_UART_BAUDRATE, i);
+		CHECK_AND_STORE(buf, 4, uart_baudrates[i]);
+	}
+
+	if (uart_baudrate == 0)
+		uart_baudrate = 115200; /* default 115200 */
+	if (uart_baudrates[0] == 0)
+		uart_baudrates[0] = uart_baudrate;
+	if (uart_baudrates[1] == 0)
+		uart_baudrates[1] = uart_baudrate;
+	if (uart_baudrates[2] == 0)
+		uart_baudrates[2] = uart_baudrate;
+
+	for (i = 1; i < 5; i++) {
+		sprintf(buf, XENV_KEYS_PCI_IRQ_ROUTE, i);
+		CHECK_AND_STORE(buf, 4, pcidev_irq_route[i - 1]);
+	}
+
+	CHECK_AND_STORE(XENV_KEY_SCARD_OFF, 4, scard_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_5V, 4, scard_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_CMD, 4, scard_cmd_pin);
+#ifdef CONFIG_TANGO3
+	CHECK_AND_STORE(XENV_KEY_SCARD1_OFF, 4, scard1_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_5V, 4, scard1_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_CMD, 4, scard1_cmd_pin);
+	CHECK_AND_STORE(XENV_KEY_SATA_CHANNEL_CFG, 4, sata_channel_cfg);
+#endif
+
+	for (i = 0; i < 4; i++) {
+		int j;
+
+		sprintf(buf, XENV_KEYS_CS_SIZE, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_size[i]);
+
+		sprintf(buf, XENV_KEYS_CS_PARTS, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_parts[i]);
+
+		for (j = 1; j < XENV_MAX_FLASH_PARTITIONS; j++) {
+
+			sprintf(buf, XENV_KEYS_CS_PART_SIZE, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_size[i][j - 1]);
+
+			sprintf(buf, XENV_KEYS_CS_PART_OFFSET, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_offset[i][j - 1]);
+		}
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_IRQ_ROUTE, 4, isaide_irq);
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_TIMING_SLOT, 4, isaide_timing_slot);
+
+	if (!strcmp(recordname, XENV_KEY_LINUX_CMD) &&
+	    datasize <= sizeof (xenv_cmdline) - 1) {
+		memcpy(xenv_cmdline, data, datasize);
+		xenv_cmdline[datasize] = 0;
+	}
+
+#ifdef CONFIG_TANGO2
+	CHECK_AND_STORE(XENV_KEY_PS_PLL3, 4, ps_pll3);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL1, 4, ps_pll1);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE(XENV_KEY_PS_MUX, 4, ps_mux);
+	CHECK_AND_STORE(XENV_KEY_PS_D0CFG, 4, ps_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D1CFG, 4, ps_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D0DELAY, 4, ps_d0delay);
+	CHECK_AND_STORE(XENV_KEY_PS_D1DELAY, 4, ps_d1delay);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL3, 4, standby_pll3);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL1, 4, standby_pll1);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_MUX, 4, standby_mux);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0CFG, 4, standby_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1CFG, 4, standby_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0DELAY, 4, standby_d0delay);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1DELAY, 4, standby_d1delay);
+#endif
+
+#ifdef CONFIG_TANGO3
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE1(XENV_KEY_PS_MT3_HS, MT3_HS_SIZE, ps_mt3_hs[0]);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE1(XENV_KEY_STANDBY_MT3_HS, MT3_HS_SIZE, standby_mt3_hs[0]);
+#endif
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_GPIODIR, 4, standby_gpiodir);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_GPIODATA, 4, standby_gpiodata);
+}
+
+/*
+ * try to read config from XENV
+ */
+static int __init xenv_read_content(void)
+{
+	unsigned long xenv_addr, old_remap;
+	int xenv_size, ret = 0;
+	uint32_t mac_lo, mac_hi;
+	/*
+	 * fetch XENV address
+	 */
+#ifdef CONFIG_TANGO3
+	unsigned int size, tmp, copy_size;
+	unsigned char *xenv_blk = (unsigned char *)zxenv;
+	xenv_gbus_addr = xenv_addr = gbus_read_reg32(REG_BASE_cpu_block + LR_ZBOOTXENV_LOCATION);
+#else
+	xenv_gbus_addr = xenv_addr = gbus_read_reg32(REG_BASE_cpu_block + LR_XENV_LOCATION);
+#endif
+	if (!xenv_addr)
+		return 1;
+
+	/*
+	 * got the xenv address in  gbus form, now convert it in remap
+	 * form so we can access it
+	 */
+	old_remap = gbus_read_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG);
+	gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, xenv_addr & TMP_REMAPPED_MASK);
+	iob();
+	xenv_addr = KSEG1ADDR(TMP_REMAPPED_BASE) + (xenv_addr & (TMP_REMAPPED_SIZE-1));
+
+#ifdef CONFIG_TANGO3
+	/*
+	 * may need to make a copy of XENV (if it acrosses remap boundary)
+	 */
+	xenv_size = *((int *)xenv_addr);
+	copy_size = TMP_REMAPPED_SIZE - (xenv_gbus_addr & (TMP_REMAPPED_SIZE-1));
+	if (xenv_size >= MAX_XENV_SIZE) { /* XENV too big */
+		ret = 1;
+		goto done;
+	} else if (copy_size < xenv_size) { /* across remap boundary */
+		memcpy(xenv_blk, (void *)xenv_addr, copy_size);
+		gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, (xenv_gbus_addr + TMP_REMAPPED_SIZE) & TMP_REMAPPED_MASK);
+		iob();
+		memcpy(xenv_blk + copy_size, (void *)KSEG1ADDR(TMP_REMAPPED_BASE), xenv_size - copy_size);
+		xenv_addr = (unsigned long)xenv_blk; /* use the copy */
+	}
+#endif
+
+	/*
+	 * check xenv sanity
+	 */
+	xenv_size = xenv_isvalid((u32 *)xenv_addr, MAX_XENV_SIZE);
+	if (xenv_size < 0) {
+		xenv_gbus_addr = xenv_addr = 0;
+		ret = 1;
+		goto done;
+	}
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+	xenv_dump((u32 *)xenv_addr, xenv_size);
+#endif
+
+	/*
+	 * ok, we can start to load each wanted value
+	 */
+	xenv_foreach((u32 *)xenv_addr, xenv_size, xenv_val_cb);
+
+	/*
+	 * load remaining values
+	 */
+#ifdef CONFIG_TANGO3
+	/* Getting information from LR_XENV2_RW */
+	mac_hi = mac_lo = 0x0; size = sizeof(unsigned int);
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int)))
+		mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+
+	mac_hi = mac_lo = 0x0; size = sizeof(unsigned int);
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int)))
+			mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address1, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address1 + 2, &mac_lo, 4);
+#else
+	mac_hi = gbus_read_reg32(REG_BASE_cpu_block + LR_ETH_MAC_HI);
+	mac_lo = gbus_read_reg32(REG_BASE_cpu_block + LR_ETH_MAC_LO);
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+#endif
+
+done:
+	gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, old_remap);
+	iob();
+
+	return ret;
+}
+#endif
+
+/*
+ * load default values and try to fetch xenv content
+ */
+int __init xenv_config(void)
+{
+#ifndef CONFIG_TANGOX_XENV_READ
+	/* will use default values */
+	return 0;
+#else
+	/*
+	 * try to load XENV content
+	 */
+	if (xenv_read_content() == 0) {
+		/* ok */
+		return 0;
+	}
+
+#ifndef CONFIG_TANGOX_XENV_READ_SAFE
+
+	/* fallback to failsafe values */
+	return 1;
+#else
+	/* stop boot process */
+	while (1)
+		cpu_relax();
+	/* not reached */
+	return 1;
+#endif
+
+#endif /* !CONFIG_TANGOX_XENV_READ */
+}
+
+
+/*
+ * helpers to access xenv configuration cached data
+ */
+
+/*
+ * enabled device query function
+ */
+#define BUILD_ENABLED(name, shift)					\
+int tangox_##name##_enabled(void)					\
+{									\
+	return (((enabled_devices >> shift) & 1) != 0) ? 1 : 0;	\
+} \
+EXPORT_SYMBOL(tangox_##name##_enabled);
+
+BUILD_ENABLED(isaide, ISAIDE_SHIFT)
+BUILD_ENABLED(bmide, BMIDE_SHIFT)
+BUILD_ENABLED(ir, IR_SHIFT)
+BUILD_ENABLED(fip, FIP_SHIFT)
+BUILD_ENABLED(usb, USB_SHIFT)
+BUILD_ENABLED(sdio, SDIO_SHIFT)
+BUILD_ENABLED(i2cm, I2CM_SHIFT)
+BUILD_ENABLED(i2cs, I2CS_SHIFT)
+BUILD_ENABLED(pci_host, PCIHOST_SHIFT)
+BUILD_ENABLED(sata, SATA_SHIFT)
+BUILD_ENABLED(gnet, GNET_SHIFT)
+
+int tangox_scard_enabled(int i)
+{
+#ifdef CONFIG_TANGO3
+	if (i != 0)
+		return((enabled_devices >> SCARD1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> SCARD_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_ethernet_enabled(int i)
+{
+#ifdef CONFIG_TANGO3
+	if (i != 0)
+		return((enabled_devices >> ETHERNET1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> ETHERNET_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_pcidev_enabled(int idsel)
+{
+	if (!tangox_pci_host_enabled())
+		return 0;
+
+	idsel--;
+	return (((enabled_devices >> (idsel + PCI1_SHIFT)) & 1) != 0) ? 1 : 0;
+}
+
+int tangox_pcidev_irq_map(int pci_idsel, int int_num)
+{
+	int route;
+	int irq;
+
+	route = pcidev_irq_route[pci_idsel - 1];
+
+	/* int_num: 0-3 = INTA-D */
+	irq = (int)((route >> (int_num * 8)) & 0x3);
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_irq_map(void)
+{
+	int irq = 0;
+
+	if (tangox_isaide_enabled() == 0)
+		return(-1);
+	irq = isaide_irq;
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_cs_select(void)
+{
+        int i;
+        unsigned long cs_config = (gbus_read_reg32(REG_BASE_host_interface + PB_CS_config) >> 12) & 0xf;
+
+        if (tangox_isaide_enabled() == 0)
+                return(-1);
+
+        for (i = 0; i < 4; i++) {
+                if ((cs_config & 0x1) != 0)
+                        return(i);
+                else
+                        cs_config >>= 1;
+        }
+        return(-1);
+}
+
+int tangox_isaide_timing_slot(void)
+{
+        return(isaide_timing_slot & 0x7);
+}
+
+EXPORT_SYMBOL(tangox_isaide_irq_map);
+EXPORT_SYMBOL(tangox_isaide_cs_select);
+EXPORT_SYMBOL(tangox_isaide_timing_slot);
+EXPORT_SYMBOL(tangox_scard_enabled);
+EXPORT_SYMBOL(tangox_ethernet_enabled);
+
+int tangox_ethernet_getmac(int idx, unsigned char *mac)
+{
+#ifdef CONFIG_TANGO3
+	if (idx != 0) {
+		/* filter broadcast & multicast addresses */
+		if (mac_address1[0] == 0x01 || mac_address1[0] == 0xff)
+			memcpy(mac, def_mac_address, 6);
+		else
+			memcpy(mac, mac_address1, 6);
+		return 0;
+	}
+#endif
+	/* filter broadcast & multicast addresses */
+	if (mac_address[0] == 0x01 || mac_address[0] == 0xff)
+		memcpy(mac, def_mac_address, 6);
+	else
+		memcpy(mac, mac_address, 6);
+	return 0;
+}
+
+int tangox_uart_baudrate(int uart)
+{
+	return uart_baudrates[uart];
+}
+
+int tangox_uart_console_port(void)
+{
+	return uart_console_port;
+}
+
+int tangox_uart_enabled(int uart)
+{
+	return (((uart_used_ports >= 3) || (uart_console_port == uart)) ? 1 : 0);
+}
+
+int tangox_flash_get_info(int cs, unsigned int *size, unsigned int *part_count)
+{
+	if (cs > 3)
+		return 1;
+
+	*size = cs_flash_size[cs];
+	*part_count = 0;
+	if (cs_flash_size[cs] > 0)
+		*part_count = cs_flash_parts[cs];
+
+	return 0;
+}
+
+int tangox_flash_get_parts(int cs, unsigned int offset[], unsigned int size[])
+{
+	int i;
+
+	if (!cs_flash_size[cs])
+		return 1;
+
+	for (i = 0; i < cs_flash_parts[cs]; i++) {
+		offset[i] = flash_parts_offset[cs][i];
+		size[i] = flash_parts_size[cs][i];
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(tangox_flash_get_info);
+EXPORT_SYMBOL(tangox_flash_get_parts);
+
+const char *tangox_xenv_cmdline(void)
+{
+	/* remove "" from command line */
+	if (xenv_cmdline[0] == '"') {
+		int len;
+
+		len = strlen(xenv_cmdline);
+		if (xenv_cmdline[len - 1] == '"')
+			xenv_cmdline[len - 1] = 0;
+		return xenv_cmdline + 1;
+	}
+	return xenv_cmdline;
+}
+
+#ifdef CONFIG_TANGO3
+int tangox_get_sata_channel_cfg(unsigned int *cfg)
+{
+	*cfg = sata_channel_cfg;
+	return 0;
+}
+EXPORT_SYMBOL(tangox_get_sata_channel_cfg);
+#endif
+
+int tangox_get_scard_info(int scard_no, int *pin_5v, int *pin_cmd, int *pin_off)
+{
+#ifdef CONFIG_TANGO3
+	if (scard_no != 0) {
+		*pin_5v = scard1_5v_pin;
+		*pin_off = scard1_off_pin;
+		*pin_cmd = scard1_cmd_pin;
+		return 0;
+	}
+#endif
+	*pin_5v = scard_5v_pin;
+	*pin_off = scard_off_pin;
+	*pin_cmd = scard_cmd_pin;
+	return 0;
+}
+
+/*
+ * show enabled devices according to xenv content
+ */
+void __init tangox_device_info(void)
+{
+	int i;
+
+	if (!xenv_gbus_addr) 
+		return;
+
+	printk(KERN_INFO "SMP86xx Enabled Devices under Linux/"
+	       "XENV 0x%08x = 0x%08x\n", xenv_gbus_addr, enabled_devices);
+
+	printk(KERN_INFO);
+	if (tangox_isaide_enabled())
+		printk(" ISA/IDE");
+	if (tangox_bmide_enabled())
+		printk(" BM/IDE");
+	if (tangox_pci_host_enabled())
+		printk(" PCIHost");
+	if (tangox_ethernet_enabled(0))
+		printk(" Ethernet");
+#ifdef CONFIG_TANGO3
+	if (tangox_ethernet_enabled(1))
+		printk(" Ethernet1");
+#endif
+	if (tangox_ir_enabled())
+		printk(" IR");
+	if (tangox_fip_enabled())
+		printk(" FIP");
+	if (tangox_i2cm_enabled())
+		printk(" I2CM");
+	if (tangox_i2cs_enabled())
+		printk(" I2CS");
+	if (tangox_sdio_enabled())
+		printk(" SDIO");
+	if (tangox_usb_enabled())
+		printk(" USB");
+	for (i = 1; i <= 6; i++) {
+		if (tangox_pcidev_enabled(i))
+			printk(" PCIDev%d", i);
+	}
+	if (tangox_sata_enabled())
+		printk(" SATA");
+	if (tangox_scard_enabled(0))
+		printk(" SCARD");
+#ifdef CONFIG_TANGO3
+	if (tangox_scard_enabled(1))
+		printk(" SCARD1");
+#endif
+	if (tangox_gnet_enabled())
+		printk(" GNET");
+	printk("\n");
+}
+
+#ifdef CONFIG_TANGO2
+void tangox_get_ps_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay)
+{
+	*pll3 = ps_pll3;
+	*pll2 = ps_pll2;
+	*pll1 = ps_pll1;
+	*pll0 = ps_pll0;
+	*mux = ps_mux;
+	*d0cfg = ps_d0cfg;
+	*d1cfg = ps_d1cfg;
+	*d0delay = ps_d0delay;
+	*d1delay = ps_d1delay;
+}
+
+void tangox_get_standby_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay, u32 *gpio_dir, u32 *gpio_data)
+{
+	*pll3 = standby_pll3;
+	*pll2 = standby_pll2;
+	*pll1 = standby_pll1;
+	*pll0 = standby_pll0;
+	*mux = standby_mux;
+	*d0cfg = standby_d0cfg;
+	*d1cfg = standby_d1cfg;
+	*d0delay = standby_d0delay;
+	*d1delay = standby_d1delay;
+	*gpio_dir = standby_gpiodir;
+	*gpio_data = standby_gpiodata;
+}
+#endif
+
+#ifdef CONFIG_TANGO3
+void tangox_get_ps_config(unsigned long *pll2, unsigned long *pll0, unsigned long *mt3_hw_settings)
+{
+	*pll2 = ps_pll2;
+	*pll0 = ps_pll0;
+	memcpy(mt3_hw_settings, ps_mt3_hs, MT3_HS_SIZE);
+}
+
+void tangox_get_standby_config(unsigned long *pll2, unsigned long *pll0, unsigned long *mt3_hw_settings, u32 *gpio_dir, u32 *gpio_data)
+{
+	*pll2 = standby_pll2;
+	*pll0 = standby_pll0;
+	*gpio_dir = standby_gpiodir;
+	*gpio_data = standby_gpiodata;
+	memcpy(mt3_hw_settings, standby_mt3_hs, MT3_HS_SIZE);
+}
+#endif
+
+EXPORT_SYMBOL(tangox_ethernet_getmac);
+EXPORT_SYMBOL(tangox_get_scard_info);
+EXPORT_SYMBOL(tangox_get_ps_config);
+EXPORT_SYMBOL(tangox_get_standby_config);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/xenv.h linux-2.6.22.19/arch/mips/tangox/xenv.h
--- linux-2.6.22.19.ref/arch/mips/tangox/xenv.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/xenv.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,99 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   xenv.h
+  @brief
+
+  The prototypes below act on a clear area respecting the xenv format.
+
+  (De)ciphering the  area, as well as committing  the changes (writing
+  the area to flash) are trivial add-ons on top of this API.
+
+  The underlying  implementation is not optimized for  speed (read and
+  write in  O(nrecords)). There  is no fragmentation  (data completely
+  rearranged at each write).
+
+  It is  not advised to repeatedly  act on flash stored  data, for the
+  device does  not support  unlimited read/write operations  (refer to
+  spec)
+
+  Power  loss when  committing the  changes cause  loss of  the stored
+  data.  This  can be avoided  by storing the  same data twice  to two
+  different sectors.
+
+  --------------------------------------------------------------------------
+  Specification   of   a   secure   storage   on   serial   flash   of
+  reboot-persistent data (xenv format)
+
+  We  describe a  way  to  concatenate (at  most  4KByte area  (12bits
+  limit)) variable  length records identified  by a string,  the `key'
+  (working much like Windows registry)
+
+  Page, seen as a byte array, is
+
+  0          4                   24                 env_size         4KB
+  | env_size | SHA-1 of following | rec0 | rec1 | .. | recn | xx xx .. |
+
+  The SHA-1 extent is env_size-24.
+
+  Description of a rec (bytes):
+
+  |4bits   12bits (2bytes)   | variable, NULL terminated | variable         |
+  attr     total record size   record name (string)        record value
+
+  attr =
+   XENV_ATTR_RW
+   XENV_ATTR_RO can be written once only but can be deleted
+   XENV_ATTR_OTP this record can be written once only and cannot be deleted
+  --------------------------------------------------------------------------
+
+  @author Emmanuel Michon
+  @date   2005-05-17
+*/
+
+#ifndef __XENV_H__
+#define __XENV_H__
+
+#include "setup.h"
+
+#define MAX_XENV_SIZE   16384
+
+/**
+   Check for compliance with xenv format
+
+   May be corrupted by:
+   - forgot to format
+   - power loss during sflash write
+   - intrusion
+
+   @param base
+   @param size
+   @return -ReturnValue-: env_size>=0 if valid, -1 if not.
+*/
+int xenv_isvalid(u32 *base, u32 maxsize);
+
+int xenv_foreach(u32 *base, u32 size,
+		 void (*cb)(char *recordname, void *data, u32 datasize));
+
+int xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize);
+int xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize);
+
+void xenv_dump(u32 *base, u32 size);
+
+#ifdef CONFIG_TANGO3
+/*
+ * XENV sizes LRRO/LRRW
+ */
+#define MAX_LR_XENV2_RO 768
+#define MAX_LR_XENV2_RW 768
+#endif
+
+#endif // __XENV_H__
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/xenvkeys.h linux-2.6.22.19/arch/mips/tangox/xenvkeys.h
--- linux-2.6.22.19.ref/arch/mips/tangox/xenvkeys.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/tangox/xenvkeys.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,222 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* 
+ * The keys defined in XENV, more can be added.
+ */
+
+#ifndef __XENV_KEYS_H__
+#define __XENV_KEYS_H__
+
+#define XENV_KEY_BOARD_ID           "a.board_id"
+#define XENV_KEY_CHIP_REV           "a.chip_rev"
+
+#define XENV_KEY_PREMUX             "a.premux"
+#define XENV_KEY_AVCLK_MUX          "a.avclk_mux"
+#define XENV_KEY_HOSTCLK_MUX        "a.hostclk_mux"
+#define XENV_KEY_IRQ_RISE_EDGE_LO   "a.irq_rise_edge_lo"
+#define XENV_KEY_IRQ_FALL_EDGE_LO   "a.irq_fall_edge_lo"
+#define XENV_KEY_GPIO_IRQ_MAP       "a.gpio_irq_map"
+
+#define XENV_KEY_DEF_BAUDRATE       "a.baudrate"
+#define XENV_KEY_CONSOLE_UART_PORT  "a.uart_console_port"
+#define XENV_KEY_UART_USED_PORTS    "a.uart_used_ports"
+
+#define XENV_KEY_PB_CS_CONFIG       "a.pb_cs_config"
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_PB_CS_CONFIG1      "a.pb_cs_config1"
+#define XENV_KEY_PB_CS_CTRL         "a.pb_cs_ctrl"
+#endif
+#define XENV_KEY_DEF_TIMING         "a.pb_def_timing"
+#define XENV_KEY_PB_TIMING0         "a.pb_timing0"
+#define XENV_KEY_PB_USE_TIMING0     "a.pb_use_timing0"
+#define XENV_KEY_PB_TIMING1         "a.pb_timing1"
+#define XENV_KEY_PB_USE_TIMING1     "a.pb_use_timing1"
+#define XENV_KEY_PB_TIMING2         "a.pb_timing2"
+#define XENV_KEY_PB_USE_TIMING2     "a.pb_use_timing2"
+#define XENV_KEY_PB_TIMING3         "a.pb_timing3"
+#define XENV_KEY_PB_USE_TIMING3     "a.pb_use_timing3"
+#define XENV_KEY_PB_TIMING4         "a.pb_timing4"
+#define XENV_KEY_PB_USE_TIMING4     "a.pb_use_timing4"
+#define XENV_KEY_PB_TIMING5         "a.pb_timing5"
+#define XENV_KEY_PB_USE_TIMING5     "a.pb_use_timing5"
+
+#define XENV_KEY_IRQ_RISE_EDGE_HI   "a.irq_rise_edge_hi"
+#define XENV_KEY_IRQ_FALL_EDGE_HI   "a.irq_fall_edge_hi"
+
+#define XENV_KEY_ENABLED_DEVICES    "a.enable_devices"
+
+#define XENV_KEY_ETH_MAC            "a.eth_mac"
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_ETH1_MAC           "a.eth1_mac"
+#endif
+
+#define XENV_KEY_SCARD_OFF          "a.scard_off_pin"
+#define XENV_KEY_SCARD_5V           "a.scard_5v_pin"
+#define XENV_KEY_SCARD_CMD          "a.scard_cmd_pin"
+
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_SCARD1_OFF         "a.scard1_off_pin"
+#define XENV_KEY_SCARD1_5V          "a.scard1_5v_pin"
+#define XENV_KEY_SCARD1_CMD         "a.scard1_cmd_pin"
+#endif
+
+#define XENV_KEY_ISAIDE_IRQ_ROUTE   "a.isaide_irq_route"
+#define XENV_KEY_ISAIDE_TIMING_SLOT "a.isaide_timing_slot"
+
+#define XENV_KEY_GPIO_DIR           "a.gpio_dir"
+#define XENV_KEY_GPIO_DATA          "a.gpio_data"
+
+#define XENV_KEY_LINUX_CMD          "a.linux_cmd"
+
+#define XENV_KEY_Z_BOOT_DEF         "z.default_boot"
+
+#define XENV_KEY_Z_PROD_TEST        "z.dt"
+#define XENV_KEY_Z_PROD_LOOPS       "z.prod_loops"
+#define XENV_KEY_Z_PROD_FTEST       "z.prod_ftest"
+#define XENV_KEY_Z_PROD_FSTART      "z.prod_fstart"
+#define XENV_KEY_Z_PROD_FEND        "z.prod_fend"
+#define XENV_KEY_Z_PROD_FSTEP       "z.prod_fstep"
+#define XENV_KEY_Z_PROD_RWIN        "z.prod_rwindow"
+#define XENV_KEY_Z_PROD_WWIN        "z.prod_wwindow"
+#define XENV_KEY_Z_PROD_CL          "z.prod_cl"
+#define XENV_KEY_Z_PROD_NBLOCKS     "z.prod_nblocks"
+
+#define XENV_KEY_YAMON_ENV          "y.env"
+#define XENV_KEY_YAMON_IPADDR       "y.ipaddr"
+#define XENV_KEY_YAMON_SUBNET       "y.subnetmask"
+#define XENV_KEY_YAMON_GATEWAY      "y.gateway"
+#define XENV_KEY_YAMON_START        "y.start"
+#define XENV_KEY_YAMON_STARTDELAY   "y.startdelay"
+
+#define XENV_KEYS_PCI_IRQ_ROUTE     "a.pcidev%d_irq_route"
+#define XENV_KEYS_CD_FREQUENCY      "a.cd%d_freq"
+#define XENV_KEYS_CD_DIV            "a.cd%d_div"
+#define XENV_KEYS_UART_GPIO_MODE    "a.uart%d_gpio_mode"
+#define XENV_KEYS_UART_GPIO_DIR     "a.uart%d_gpio_dir"
+#define XENV_KEYS_UART_GPIO_DATA    "a.uart%d_gpio_data"
+#define XENV_KEYS_UART_BAUDRATE     "a.uart%d_baudrate"
+#define XENV_KEYS_GPIO_PULSE        "a.gpio%d_pulse"
+
+#define XENV_KEYS_Z_BOOT_LOCATION   "z.boot%d"
+
+#define XENV_KEYS_CS_SIZE           "l.cs%d_size"
+#define XENV_KEYS_CS_PARTS          "l.cs%d_parts"
+
+#define XENV_KEYS_CS_PART_SIZE      "l.cs%d_part%d_size"
+#define XENV_KEYS_CS_PART_OFFSET    "l.cs%d_part%d_offset" 
+
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_SATA_CHANNEL_CFG   "a.sata_channel_cfg"
+#endif
+
+#ifdef CONFIG_TANGO2
+#define XENV_KEY_PS_PLL3            "a.ps.pll3"
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL1            "a.ps.pll1"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MUX             "a.ps.mux"
+#define XENV_KEY_PS_D0CFG           "a.ps.d0cfg"
+#define XENV_KEY_PS_D1CFG           "a.ps.d1cfg"
+#define XENV_KEY_PS_D0DELAY         "a.ps.d0delay"
+#define XENV_KEY_PS_D1DELAY         "a.ps.d1delay"
+
+#define XENV_KEY_STANDBY_PLL3       "a.standby.pll3"
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL1       "a.standby.pll1"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MUX        "a.standby.mux"
+#define XENV_KEY_STANDBY_D0CFG      "a.standby.d0cfg"
+#define XENV_KEY_STANDBY_D1CFG      "a.standby.d1cfg"
+#define XENV_KEY_STANDBY_D0DELAY    "a.standby.d0delay"
+#define XENV_KEY_STANDBY_D1DELAY    "a.standby.d1delay"
+#endif
+
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MT3_HS          "a.ps.mt3_hs"
+
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MT3_HS     "a.standby.mt3_hs"
+#endif
+
+#define XENV_KEY_STANDBY_GPIODIR    "a.standby.gpio_dir"
+#define XENV_KEY_STANDBY_GPIODATA   "a.standby.gpio_data"
+
+#ifndef CONFIG_SIGBLOCK_SUPPORT
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+#ifdef CONFIG_TANGO3
+#define SCARD1_SHIFT		19
+#define ETHERNET1_SHIFT		20
+#endif
+#endif
+
+/* Only used internally for LR_XENV2_RW and LR_XENV2_RO. Will be prefixed with z. when read off pfla */
+#ifdef CONFIG_TANGO3
+/* lrrw */
+#define XENV_LRRW_ETH_MACL	     "lrrw.maclo"
+#define XENV_LRRW_ETH_MACH	     "lrrw.machi"
+#define XENV_LRRW_ETH1_MACL	     "lrrw.mac1lo"
+#define XENV_LRRW_ETH1_MACH	     "lrrw.mac1hi"
+#define XENV_LRRW_KERNEL_END	     "lrrw.kend"
+
+#define XENV_LRRW_RUAMM0_GA          "lrrw.ruamm0_ga"
+#define XENV_LRRW_RUAMM1_GA          "lrrw.ruamm1_ga"
+
+#define XENV_LRRW_0_UZDATA_OFFSET    "lrrw.0.uzdata_offset"
+#define XENV_LRRW_0_ZDATA_OFFSET     "lrrw.0.zdata_offset"
+#define XENV_LRRW_0_DSP_OFFSET       "lrrw.0.dsp_offset"
+#define XENV_LRRW_0_XPU_OFFSET       "lrrw.0.xpu_offset"
+#define XENV_LRRW_1_UZDATA_OFFSET    "lrrw.1.uzdata_offset"
+#define XENV_LRRW_1_ZDATA_OFFSET     "lrrw.1.zdata_offset"
+#define XENV_LRRW_1_DSP_OFFSET       "lrrw.1.dsp_offset"
+#define XENV_LRRW_1_XPU_OFFSET       "lrrw.1.xpu_offset"
+
+#define XENV_LRRW_CHANNEL_INDEX_GA   "lrrw.channel_index_ga"
+#define XENV_LRRW_CHANNEL_INDEX_SIZE "lrrw.channel_index_size"
+#define XENV_LRRW_IOS_GA             "lrrw.ios_ga"
+#define XENV_LRRW_IOS_SIZE           "lrrw.ios_size"
+#define XENV_LRRW_XOS_PUBLIC_GA      "lrrw.xos_public_ga"
+#define XENV_LRRW_XOS_PUBLIC_SIZE    "lrrw.xos_public_size"
+#define XENV_LRRW_IHAPI_GA           "lrrw.ihapi_ga"
+#define XENV_LRRW_MM_VERSION         "lrrw.mm_version"
+
+/* For handshaking and setup purpose */
+#define XENV_HS_RUAMM0_OFFSET	     "a.ruamm0_offset"
+#define XENV_HS_RUAMM1_OFFSET	     "a.ruamm1_offset"
+#define XENV_HS_XOS_PUBLIC_SIZE      "a.xos_public_size"
+#define XENV_HS_IOS_SIZE	     "a.ios_size"
+
+/* lrro */
+#define XENV_LRRO_LOCKED	     "lrro.locked"
+
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/block/Kconfig linux-2.6.22.19/drivers/block/Kconfig
--- linux-2.6.22.19.ref/drivers/block/Kconfig	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/block/Kconfig	2009-04-24 10:51:33.000000000 -0700
@@ -406,6 +406,24 @@
 	  setups function - apparently needed by the rd_load_image routine
 	  that supposes the filesystem in the image uses a 1024 blocksize.
 
+config EMBEDDED_RAMDISK
+        bool "Embedded ramdisk"
+        default y
+        depends on BLK_DEV_INITRD=y && MIPS=y
+        help
+          Select this option if you want to build the ramdisk image into the
+          the final kernel binary.
+
+config EMBEDDED_RAMDISK_IMAGE
+        string "File name of the ramdisk"
+        default ""
+        depends on EMBEDDED_RAMDISK=y
+        help
+          This is the filename of the ramdisk image to be built into the
+          kernel.  Relative pathnames are relative to arch/mips/ramdisk/.
+          The ramdisk image is not part of the kernel distribution; you must
+          provide one yourself.
+
 config CDROM_PKTCDVD
 	tristate "Packet writing on CD/DVD media"
 	depends on !UML
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/input/serio/serio_raw.c linux-2.6.22.19/drivers/input/serio/serio_raw.c
--- linux-2.6.22.19.ref/drivers/input/serio/serio_raw.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/input/serio/serio_raw.c	2009-04-24 10:51:33.000000000 -0700
@@ -160,7 +160,7 @@
 {
 	struct serio_raw_list *list = file->private_data;
 	struct serio_raw *serio_raw = list->serio_raw;
-	char c;
+	char c = 0;
 	ssize_t retval = 0;
 
 	if (!serio_raw->serio)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/serial/8250.c linux-2.6.22.19/drivers/serial/8250.c
--- linux-2.6.22.19.ref/drivers/serial/8250.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/serial/8250.c	2009-04-24 10:51:33.000000000 -0700
@@ -41,6 +41,20 @@
 #include <linux/nmi.h>
 #include <linux/mutex.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#endif
+
+#ifdef CONFIG_TANGOX
+extern unsigned long tangox_get_sysclock(void);
+#endif
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -77,7 +91,11 @@
  * machine types want others as well - they're free
  * to redefine this in their header file.
  */
+#if 1 
 #define is_real_interrupt(irq)	((irq) != 0)
+#else
+#define is_real_interrupt(irq)	(0)
+#endif
 
 #ifdef CONFIG_SERIAL_8250_DETECT_IRQ
 #define CONFIG_SERIAL_DETECT_IRQ 1
@@ -354,8 +372,20 @@
 
 	case UPIO_MEM:
 	case UPIO_DWAPB:
-		return readb(up->port.membase + offset);
-
+#ifdef CONFIG_TANGOX
+        {
+                unsigned long v;
+
+                /* no EFR on tango2/tango3 */
+                if (offset == (UART_EFR << up->port.regshift))
+                        v = 0;
+                else
+                        v = gbus_read_reg32((u32)(up->port.membase +  offset));
+                return v;
+        }
+#else
+                return readb(up->port.membase + offset);
+#endif
 	case UPIO_RM9000:
 	case UPIO_MEM32:
 		return readl(up->port.membase + offset);
@@ -391,8 +421,39 @@
 		break;
 
 	case UPIO_MEM:
+#ifdef CONFIG_TANGOX
+		/*
+		 * we add  a special case for  UART_DL register, since
+		 * register content has a different meaning for us.
+		 */
+		if (offset == (UART_DL << up->port.regshift)) {
+			/* select right clock source */
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+			value = (tangox_get_sysclock() / up->port.uartclk);
+#else
+#ifdef CONFIG_TANGO2
+			value = (TANGOX_BASE_FREQUENCY / up->port.uartclk); 
+			if ((((TANGOX_BASE_FREQUENCY * 10) / up->port.uartclk) % 10) >= 5)
+				value++;
+#elif defined(CONFIG_TANGO3)
+			value = TANGO3_UART_FREQUENCY / up->port.uartclk;
+			if ((((TANGO3_UART_FREQUENCY * 10) / up->port.uartclk) % 10) >= 5)
+				value++;
+#else
+#error Unsupported platform.
+#endif
+#endif
+		}
+
+		/* no EFR on tango2/tango3 */
+		if (offset != (UART_EFR << up->port.regshift))
+			gbus_write_reg32((unsigned long)up->port.membase +
+				    offset, value);
+		break;
+#else
 		writeb(value, up->port.membase + offset);
 		break;
+#endif
 
 	case UPIO_RM9000:
 	case UPIO_MEM32:
@@ -456,14 +517,22 @@
 /* Uart divisor latch read */
 static inline int _serial_dl_read(struct uart_8250_port *up)
 {
+#ifdef CONFIG_TANGOX
+        return serial_inp(up, UART_DL);
+#else
 	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
+#endif
 }
 
 /* Uart divisor latch write */
 static inline void _serial_dl_write(struct uart_8250_port *up, int value)
 {
+#ifdef CONFIG_TANGOX
+        serial_outp(up, UART_DL, value);
+#else
 	serial_outp(up, UART_DLL, value & 0xff);
 	serial_outp(up, UART_DLM, value >> 8 & 0xff);
+#endif
 }
 
 #if defined (CONFIG_SERIAL_8250_AU1X00)
@@ -649,9 +718,11 @@
 		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
 	serial_outp(up, UART_MCR, UART_MCR_LOOP);
 	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+
 	old_dl = serial_dl_read(up);
 	serial_dl_write(up, 0x0001);
 	serial_outp(up, UART_LCR, 0x03);
+
 	for (count = 0; count < 256; count++)
 		serial_outp(up, UART_TX, count);
 	mdelay(20);/* FIXME - schedule_timeout */
@@ -680,6 +751,16 @@
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_DLAB);
 
+#ifdef CONFIG_TANGOX
+	old_dll = serial_inp(p, UART_DL) & 0xff;
+	old_dlm = serial_inp(p, UART_DL) >> 8;
+
+	serial_outp(p, UART_DL, 0);
+
+	id = serial_inp(p, UART_DL);
+
+	serial_outp(p, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
 
@@ -690,6 +771,7 @@
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
@@ -890,7 +972,6 @@
 			unsigned short quot;
 
 			serial_outp(up, UART_LCR, 0xE0);
-
 			quot = serial_dl_read(up);
 			quot <<= 3;
 
@@ -900,7 +981,6 @@
 			serial_outp(up, 0x04, status1);
 
 			serial_dl_write(up, quot);
-
 			serial_outp(up, UART_LCR, 0);
 
 			up->port.uartclk = 921600*16;
@@ -2135,9 +2215,7 @@
 	} else {
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	}
-
 	serial_dl_write(up, quot);
-
 	/*
 	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
 	 * is written without DLAB set, this mode will be disabled.
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/serial/8250_early.c linux-2.6.22.19/drivers/serial/8250_early.c
--- linux-2.6.22.19.ref/drivers/serial/8250_early.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/serial/8250_early.c	2009-04-24 10:51:33.000000000 -0700
@@ -103,8 +103,13 @@
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	dll = serial_in(port, UART_DL) & 0xff;
+	dlm = serial_in(port, UART_DL) >> 8;
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+#endif
 	serial_out(port, UART_LCR, lcr);
 
 	quot = (dlm << 8) | dll;
@@ -125,8 +130,12 @@
 	divisor = port->uartclk / (16 * device->baud);
 	c = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, c | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	serial_out(port, UART_DL, divisor & 0xffff);
+#else
 	serial_out(port, UART_DLL, divisor & 0xff);
 	serial_out(port, UART_DLM, (divisor >> 8) & 0xff);
+#endif
 	serial_out(port, UART_LCR, c & ~UART_LCR_DLAB);
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/serial/serial_core.c linux-2.6.22.19/drivers/serial/serial_core.c
--- linux-2.6.22.19.ref/drivers/serial/serial_core.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/serial/serial_core.c	2009-04-24 10:51:33.000000000 -0700
@@ -383,7 +383,7 @@
 		termios->c_cflag |= B9600;
 	}
 
-	return 0;
+	return baud;
 }
 
 EXPORT_SYMBOL(uart_get_baud_rate);
@@ -408,7 +408,7 @@
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
 
-	return quot;
+	return (quot ? quot : 1);
 }
 
 EXPORT_SYMBOL(uart_get_divisor);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/jffs2/super.c linux-2.6.22.19/fs/jffs2/super.c
--- linux-2.6.22.19.ref/fs/jffs2/super.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/fs/jffs2/super.c	2009-04-24 10:51:33.000000000 -0700
@@ -161,6 +161,7 @@
 	.name =		"jffs2",
 	.get_sb =	jffs2_get_sb,
 	.kill_sb =	jffs2_kill_sb,
+	.fs_flags =	FS_REQUIRES_DEV,
 };
 
 static int __init init_jffs2_fs(void)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/partitions/check.c linux-2.6.22.19/fs/partitions/check.c
--- linux-2.6.22.19.ref/fs/partitions/check.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/fs/partitions/check.c	2009-04-24 10:51:33.000000000 -0700
@@ -35,6 +35,7 @@
 #include "efi.h"
 #include "karma.h"
 #include "sysv68.h"
+#include "xenv_part.h"
 
 #ifdef CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(dev_t dev);
@@ -43,6 +44,9 @@
 int warn_no_part = 1; /*This is ugly: should make genhd removable media aware*/
 
 static int (*check_part[])(struct parsed_partitions *, struct block_device *) = {
+#ifdef CONFIG_XENV_PARTITION
+	xenv_partition,	/* Probe for XENV partition */
+#endif
 	/*
 	 * Probe partition formats with tables at disk address 0
 	 * that also have an ADFS boot block at 0xdc0.
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/partitions/Kconfig linux-2.6.22.19/fs/partitions/Kconfig
--- linux-2.6.22.19.ref/fs/partitions/Kconfig	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/fs/partitions/Kconfig	2009-04-24 10:51:33.000000000 -0700
@@ -249,3 +249,13 @@
 	  partition table format used by Motorola Delta machines (using
 	  sysv68).
 	  Otherwise, say N.
+
+config XENV_PARTITION
+	bool "XENV partition support" if PARTITION_ADVANCED 
+	depends on TANGO3
+	default TANGOX_XENV_READ 
+	help
+	  Say Y here if you would like to be able to read the partition
+	  information from XENV.
+	  Otherwise, say N.
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/partitions/Makefile linux-2.6.22.19/fs/partitions/Makefile
--- linux-2.6.22.19.ref/fs/partitions/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/fs/partitions/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -18,3 +18,4 @@
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
+obj-$(CONFIG_XENV_PARTITION) += xenv_part.o
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/partitions/xenv_part.c linux-2.6.22.19/fs/partitions/xenv_part.c
--- linux-2.6.22.19.ref/fs/partitions/xenv_part.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/fs/partitions/xenv_part.c	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,54 @@
+
+/*
+ * Converting XENV partition information to psudo HDD-like partitions.
+ */
+
+#ifndef CONFIG_TANGO3
+#error Not supported platform.
+#endif
+
+/* Only applicable to Tango3 */
+#include <asm/io.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#include "check.h"
+
+#include "xenv_part.h"
+
+/* XENV query function prototypes */
+extern int tangox_flash_get_info(int cs, unsigned int *size, unsigned int *part_count);
+extern int tangox_flash_get_parts(int cs, unsigned int offset[], unsigned int size[]);
+
+int xenv_partition(struct parsed_partitions *state, struct block_device *bdev)
+{
+	struct xenv_disk_marker *sdisk = bdev->bd_disk->private_data;
+	unsigned int cs, cs_part, cs_size;
+	unsigned int offsets[SDND_MINORS], sizes[SDND_MINORS];
+	int i;
+
+	if (sdisk == NULL)
+		goto out;
+	else if (sdisk->magic != SDND_MAGIC)
+		goto out;
+	else if ((cs = sdisk->cs) >= SDND_MAX_CS)
+		goto out;
+
+	tangox_flash_get_info(cs, &cs_size, &cs_part);
+
+	if ((cs_part == 0) || (cs_size == 0)) 
+		goto out;
+	else if (cs_part > (SDND_MINORS - 2))
+		cs_part = SDND_MINORS - 2;
+
+	tangox_flash_get_parts(cs, &offsets[0], &sizes[0]);
+	state->limit = SDND_MINORS - 1;
+
+	for (i = 0; i < cs_part; i++) 
+		put_partition(state, i + 1, offsets[i] / KERNEL_SECTOR_SIZE, sizes[i] / KERNEL_SECTOR_SIZE);
+
+	return 1;
+
+out:
+	return 0;
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/partitions/xenv_part.h linux-2.6.22.19/fs/partitions/xenv_part.h
--- linux-2.6.22.19.ref/fs/partitions/xenv_part.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/fs/partitions/xenv_part.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,7 @@
+
+#ifndef __XENV_PART_H__
+#define __XENV_PART_H__
+
+int xenv_partition(struct parsed_partitions *state, struct block_device *bdev);
+
+#endif /* __XENV_PART_H__ */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/addrspace.h linux-2.6.22.19/include/asm-mips/addrspace.h
--- linux-2.6.22.19.ref/include/asm-mips/addrspace.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/addrspace.h	2009-04-24 10:51:33.000000000 -0700
@@ -10,7 +10,7 @@
 #ifndef _ASM_ADDRSPACE_H
 #define _ASM_ADDRSPACE_H
 
-#include <spaces.h>
+/*#include <spaces.h> -- not used*/
 
 /*
  *  Configure language
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/barrier.h linux-2.6.22.19/include/asm-mips/barrier.h
--- linux-2.6.22.19.ref/include/asm-mips/barrier.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/barrier.h	2009-04-24 10:51:33.000000000 -0700
@@ -78,6 +78,31 @@
 #define __sync()	do { } while(0)
 #endif
 
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)(CKSEG1+MEM_BASE_dram_controller_0+FM_RESERVED))	\
+		: "memory")
+#elif defined(CONFIG_TANGO3)
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)(CKSEG1+CPU_REMAP_SPACE))	\
+		: "memory")
+#else
 #define __fast_iob()				\
 	__asm__ __volatile__(			\
 		".set	push\n\t"		\
@@ -88,6 +113,7 @@
 		: /* no output */		\
 		: "m" (*(int *)CKSEG1)		\
 		: "memory")
+#endif
 
 #define fast_wmb()	__sync()
 #define fast_rmb()	__sync()
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/bootinfo.h linux-2.6.22.19/include/asm-mips/bootinfo.h
--- linux-2.6.22.19.ref/include/asm-mips/bootinfo.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/bootinfo.h	2009-04-24 10:51:33.000000000 -0700
@@ -213,6 +213,12 @@
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
 #define  MACH_NEC_MARKEINS	0	/* NEC EMMA2RH Mark-eins	*/
 
+/*
+ * Valid machtype for group SIGMADESIGNS
+ */
+#define MACH_GROUP_SIGMADESIGNS	23	/* For SigmaDesigns Tango2/Tango3 board */
+#define  MACH_TANGOX		 1	/* Tango2/Tango3 */
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/bug.h linux-2.6.22.19/include/asm-mips/bug.h
--- linux-2.6.22.19.ref/include/asm-mips/bug.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/bug.h	2009-04-24 10:51:33.000000000 -0700
@@ -7,8 +7,15 @@
 
 #include <asm/break.h>
 
+#ifdef CONFIG_PRINTK
+int printk(const char * fmt, ...) __attribute__ ((format (printf, 1, 2)));
+#else
+static inline int printk(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+#endif
+
 #define BUG()								\
 do {									\
+	printk("<0> BUG on %s:%d (%s).\n", __FILE__, __LINE__, __FUNCTION__); \
 	__asm__ __volatile__("break %0" : : "i" (BRK_BUG));		\
 } while (0)
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/cacheflush.h linux-2.6.22.19/include/asm-mips/cacheflush.h
--- linux-2.6.22.19.ref/include/asm-mips/cacheflush.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/cacheflush.h	2009-04-24 10:51:33.000000000 -0700
@@ -57,10 +57,14 @@
 		__flush_anon_page(page, vmaddr);
 }
 
+#ifdef CONFIG_TANGOX
+extern void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
+#else
 static inline void flush_icache_page(struct vm_area_struct *vma,
 	struct page *page)
 {
 }
+#endif
 
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
 #define flush_cache_vmap(start, end)		flush_cache_all()
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/cpu-features.h linux-2.6.22.19/include/asm-mips/cpu-features.h
--- linux-2.6.22.19.ref/include/asm-mips/cpu-features.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/cpu-features.h	2009-04-24 10:54:06.000000000 -0700
@@ -92,6 +92,9 @@
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif
+#ifndef cpu_has_vtag_dcache
+#define cpu_has_vtag_dcache	(cpu_data[0].dcache.flags & MIPS_CACHE_VTAG)
+#endif
 #ifndef cpu_has_dc_aliases
 #define cpu_has_dc_aliases	(cpu_data[0].dcache.flags & MIPS_CACHE_ALIASES)
 #endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/delay.h linux-2.6.22.19/include/asm-mips/delay.h
--- linux-2.6.22.19.ref/include/asm-mips/delay.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/delay.h	2009-04-24 10:51:33.000000000 -0700
@@ -81,7 +81,12 @@
 
 #define __udelay_val cpu_data[raw_smp_processor_id()].udelay_val
 
+#ifdef CONFIG_TANGOX
+void tangox_udelay(unsigned usec);
+#define udelay(usecs) tangox_udelay(usecs)
+#else
 #define udelay(usecs) __udelay((usecs),__udelay_val)
+#endif
 
 /* make sure "usecs *= ..." in udelay do not overflow. */
 #if HZ >= 1000
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/dma.h linux-2.6.22.19/include/asm-mips/dma.h
--- linux-2.6.22.19.ref/include/asm-mips/dma.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/dma.h	2009-04-24 10:51:33.000000000 -0700
@@ -84,15 +84,21 @@
  * Deskstations or Acer PICA but not the much more versatile DMA logic used
  * for the local devices on Acer PICA or Magnums.
  */
-#ifdef CONFIG_SGI_IP22
+#if defined(CONFIG_SGI_IP22)
 /* Horrible hack to have a correct DMA window on IP22 */
 #include <asm/sgi/mc.h>
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + SGIMC_SEG0_BADDR + 0x01000000)
+#elif defined(CONFIG_TANGOX)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x20000000)
 #else
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
 #endif
 #define MAX_DMA_PFN		PFN_DOWN(virt_to_phys((void *)MAX_DMA_ADDRESS))
 
+#if defined(CONFIG_TANGOX)
+#define HAVE_ARCH_PCI_SET_DMA_MASK
+#endif
+
 /* 8237 DMA controllers */
 #define IO_DMA1_BASE	0x00	/* 8 bit slave DMA, channels 0..3 */
 #define IO_DMA2_BASE	0xC0	/* 16 bit master DMA, ch 4(=slave input)..7 */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/irq_regs.h linux-2.6.22.19/include/asm-mips/irq_regs.h
--- linux-2.6.22.19.ref/include/asm-mips/irq_regs.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/irq_regs.h	2009-04-24 10:51:33.000000000 -0700
@@ -17,5 +17,9 @@
 {
 	return current_thread_info()->regs;
 }
+static inline void set_irq_regs(struct pt_regs *regs)
+{
+        current_thread_info()->regs = regs;
+}
 
 #endif /* __ASM_IRQ_REGS_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/mach-tango2/irq.h linux-2.6.22.19/include/asm-mips/mach-tango2/irq.h
--- linux-2.6.22.19.ref/include/asm-mips/mach-tango2/irq.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/mach-tango2/irq.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,17 @@
+
+#ifndef __ASM_MACH_TANGO2_IRQ_H
+#define __ASM_MACH_TANGO2_IRQ_H
+
+#include <linux/config.h>
+
+#ifndef MIPS_CPU_IRQ_BASE
+#ifdef CONFIG_I8259
+#define MIPS_CPU_IRQ_BASE 16
+#else
+#define MIPS_CPU_IRQ_BASE 0
+#endif /* CONFIG_I8259 */
+#endif
+
+#define NR_IRQS 256
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/mach-tango2/param.h linux-2.6.22.19/include/asm-mips/mach-tango2/param.h
--- linux-2.6.22.19.ref/include/asm-mips/mach-tango2/param.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/mach-tango2/param.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,5 @@
+
+#ifndef __ASM_MACH_TANGO2_PARAM_H
+#define __ASM_MACH_TANGO2_PARAM_H
+
+#endif /* __ASM_MACH_TANGO2_PARAM_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/mach-tango2/spaces.h linux-2.6.22.19/include/asm-mips/mach-tango2/spaces.h
--- linux-2.6.22.19.ref/include/asm-mips/mach-tango2/spaces.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/mach-tango2/spaces.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,34 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO2_SPACES_H
+#define _ASM_MACH_TANGO2_SPACES_H
+
+#include <linux/config.h>
+
+#define CAC_BASE		0x90000000
+#define IO_BASE			0xa0000000
+#define UNCAC_BASE		0xa0000000
+#define MAP_BASE		0xc0000000
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO2_SPACES_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/mach-tango3/irq.h linux-2.6.22.19/include/asm-mips/mach-tango3/irq.h
--- linux-2.6.22.19.ref/include/asm-mips/mach-tango3/irq.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/mach-tango3/irq.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,17 @@
+
+#ifndef __ASM_MACH_TANGO3_IRQ_H
+#define __ASM_MACH_TANGO3_IRQ_H
+
+#include <linux/config.h>
+
+#ifndef MIPS_CPU_IRQ_BASE
+#ifdef CONFIG_I8259
+#define MIPS_CPU_IRQ_BASE 16
+#else
+#define MIPS_CPU_IRQ_BASE 0
+#endif /* CONFIG_I8259 */
+#endif
+
+#define NR_IRQS 256
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/mach-tango3/param.h linux-2.6.22.19/include/asm-mips/mach-tango3/param.h
--- linux-2.6.22.19.ref/include/asm-mips/mach-tango3/param.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/mach-tango3/param.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,5 @@
+
+#ifndef __ASM_MACH_TANGO3_PARAM_H
+#define __ASM_MACH_TANGO3_PARAM_H
+
+#endif /* __ASM_MACH_TANGO3_PARAM_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/mach-tango3/spaces.h linux-2.6.22.19/include/asm-mips/mach-tango3/spaces.h
--- linux-2.6.22.19.ref/include/asm-mips/mach-tango3/spaces.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/mach-tango3/spaces.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,34 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO3_SPACES_H
+#define _ASM_MACH_TANGO3_SPACES_H
+
+#include <linux/config.h>
+
+#define CAC_BASE		0x90000000
+#define IO_BASE			0xa0000000
+#define UNCAC_BASE		0xa0000000
+#define MAP_BASE		0xc0000000
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO3_SPACES_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/page.h linux-2.6.22.19/include/asm-mips/page.h
--- linux-2.6.22.19.ref/include/asm-mips/page.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/page.h	2009-04-24 10:55:41.000000000 -0700
@@ -70,7 +70,7 @@
 	extern void (*flush_data_cache_page)(unsigned long addr);
 
 	clear_page(addr);
-	if (pages_do_alias((unsigned long) addr, vaddr & PAGE_MASK))
+	if (cpu_has_vtag_dcache || pages_do_alias((unsigned long) addr, vaddr & PAGE_MASK))
 		flush_data_cache_page((unsigned long)addr);
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/hardware.h linux-2.6.22.19/include/asm-mips/tango2/hardware.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/hardware.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,118 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+
+// UART0
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+// UART0
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+// IDE interrupts
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+// MBUS interface
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+// GPIO
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+// UART GPIO
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	7   	/* 2^7 = 128MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<MAX_LOG2_PCIMEM_MAP)*7)>>3)	/* Max ~112MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x10000000UL)   /* base address of EM86xx PCI slave */
+
+// Peripheral bus Registers
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+// Bus Master IDE
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+#ifndef __ASSEMBLY__
+// Physical address mapping
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if (physaddr >= MEM_BASE_dram_controller_0_alias)
+		return(physaddr); /* for Tango2, it's the same */
+	else if (physaddr >= CPU_remap4_address) 
+		return(gbus_read_uint32(0, REG_BASE_cpu_block + CPU_remap4) + (physaddr - CPU_remap4_address));
+	else if (physaddr >= CPU_remap3_address) 
+		return(gbus_read_uint32(0, REG_BASE_cpu_block + CPU_remap3) + (physaddr - CPU_remap3_address));
+	else if (physaddr >= CPU_remap2_address) 
+		return(gbus_read_uint32(0, REG_BASE_cpu_block + CPU_remap2) + (physaddr - CPU_remap2_address));
+#endif
+	return(physaddr); 
+}
+
+// Inverted physical address mapping
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if ((mapaddr >= MEM_BASE_dram_controller_0_alias) && (mapaddr < MEM_BASE_dram_controller_1))
+		return(mapaddr); /* for Tango2, it's the same */
+	else {
+		unsigned long remap;
+		remap = gbus_read_uint32(0, REG_BASE_cpu_block + CPU_remap4);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap4_address + (mapaddr - remap));
+		remap = gbus_read_uint32(0, REG_BASE_cpu_block + CPU_remap3);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap3_address + (mapaddr - remap));
+		remap = gbus_read_uint32(0, REG_BASE_cpu_block + CPU_remap2);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap2_address + (mapaddr - remap));
+	}
+#endif
+	return(mapaddr); /* for Tango2, it's the same */
+}
+#endif
+		
+#endif //__HARDWARE_H
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/memcfg.h linux-2.6.22.19/include/asm-mips/tango2/memcfg.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/memcfg.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/memcfg.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,45 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* For more memcfg operations */
+
+#ifndef _MEMCFG_H_
+#define _MEMCFG_H_
+
+#include <linux/config.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_dram.h>
+
+static inline int is_valid_memcfg(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	if ((memcfg_ptr->signature) != MEMCFG_SIGNATURE)
+		return(0);
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	return((sum == 0) ? 1 : 0);
+}
+
+static inline void gen_memcfg_checksum(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	memcfg_ptr->checksum = 0;
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	memcfg_ptr->checksum = ~sum + 1;
+}
+
+#endif /* _MEMCFG_H_ */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/rmdefs.h linux-2.6.22.19/include/asm-mips/tango2/rmdefs.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/rmdefs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/rmdefs.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/tango2api.h linux-2.6.22.19/include/asm-mips/tango2/tango2api.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/tango2api.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/tango2api.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,118 @@
+/*
+ * include/asm-mips/tango2/tangoa2pi.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango2/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA1, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_UNUSED1, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_init(void);
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+
+int em86xx_mbus_setup_dma_common(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+void em86xx_mbus_setup_dma_linear(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int flags);
+void em86xx_mbus_setup_dma_double(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int addr2, unsigned int count2, unsigned int flags);
+void em86xx_mbus_setup_dma_rectangle(unsigned int regbase, unsigned int addr, unsigned int horiz, unsigned int lines, int skip, unsigned int flags);
+void em86xx_mbus_setup_dma_void(unsigned int regbase);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+#if defined(CONFIG_EM86XX_UART0_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART0_AS_GPIO_PARTIAL)
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+#endif
+#if defined(CONFIG_EM86XX_UART1_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART1_AS_GPIO_PARTIAL)
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/tango2_gbus.h linux-2.6.22.19/include/asm-mips/tango2/tango2_gbus.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/tango2_gbus.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/tango2_gbus.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,149 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+  Refer to bug #3644.
+
+  TLB-based implementation works on the ranges:
+  [0x00000000..0x20000000[ access thru kseg1
+  [0x20000000..0x2xxxxxxx (size  of dram1, a  parameter of ioremap())[
+  access thru tlb. Outside: unpredictable/oops.
+
+  Remap-based implementation does:
+  00xy b27b26..b0 to 101y(b27|x)b26..b0.
+  and works  everywhere excepted ranges:  [0x18000000..0x20000000[ and
+  [0x28000000..0xffffffff]
+
+  Test with
+  {
+	volatile int q=gbus_read_uint32(pGBus,0x1020212c); // correct
+	q=gbus_read_uint32(pGBus,0x1f20212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2020212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2720212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2820212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2f20212c);              // incorrect
+  }
+*/
+
+#ifndef __TANGO2_GBUS_H
+#define __TANGO2_GBUS_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	ext	\\res, \\addr, 29, 1				\n"
+	"	bnez	\\res, 1f					\n"
+	"	lui	\\tmp, 0xa000					\n"
+	"	or	\\res, \\tmp, \\addr				\n"
+	"	j	2f						\n"
+	"	nop							\n"
+	"1:								\n"
+	"	lui	\\tmp, 0x2000					\n"
+	"	sub	\\res, \\addr, \\tmp				\n"
+	"	lw	\\tmp, em86xx_tlb_dram1_map_base		\n"
+	"	add	\\res, \\tmp					\n"
+	"2:								\n"
+	"	.endm");
+
+#else
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	rotr	\\res, \\addr, 29				\n"
+	"	ins	\\res, \\res, 30, 1				\n"
+	"	or	\\res, 5					\n"
+	"	rotr	\\res, 3					\n"
+	"	.endm");
+#endif
+
+
+/*
+ * we just want to set kseg1 bit, most of the time address is known at
+ * compile time, so this will usually be reduced to 2 instructions
+ */
+
+#define BUILD_GBUS_READ(size)						\
+static inline RMuint32 gbus_read_dram_uint##size(struct gbus *pgbus,	\
+					    RMuint32 byte_address)	\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		return *((volatile RMuint##size *)KSEG1ADDR(byte_address)); \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		return *((volatile RMuint##size *)res);			\
+	}								\
+}
+
+BUILD_GBUS_READ(8);
+BUILD_GBUS_READ(16);
+BUILD_GBUS_READ(32);
+
+#define BUILD_GBUS_WRITE(size)						\
+static inline void gbus_write_dram_uint##size(struct gbus *pgbus,	\
+				     RMuint32 byte_address,		\
+				     RMuint##size data)			\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data; \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		*((volatile RMuint##size *)res) = data;			\
+	}								\
+}
+
+BUILD_GBUS_WRITE(8);
+BUILD_GBUS_WRITE(16);
+BUILD_GBUS_WRITE(32);
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_read_reg32(r)      __raw_readl((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg16(r)      __raw_readw((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg8(r)       __raw_readb((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg32(r, v)  __raw_writel(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg16(r, v)  __raw_writew(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg8(r, v)   __raw_writeb(v, (volatile void __iomem *)KSEG1ADDR(r))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO2_GBUS_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/tango2.h linux-2.6.22.19/include/asm-mips/tango2/tango2.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/tango2.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/tango2.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,64 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   tango2.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO2_H__
+#define __TANGO2_H__
+#include <linux/config.h>
+#include <asm/tango2/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_resources_tango2.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#endif
+/* Baudrate setting */
+#if defined(CONFIG_TANGO2_SMP863X)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO2_SMP863X)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO2_SMP863X)
+#define SYS_clkgen_pll        SYS_clkgen3_pll
+#endif
+
+#endif // __TANGO2_H__
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/hardware.h linux-2.6.22.19/include/asm-mips/tango3/hardware.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/hardware.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,137 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+
+// UART0
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+// UART1
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+// UART2
+#define CPU_uart2_gpio_dir	    (CPU_UART2_base + CPU_UART_GPIODIR)
+#define CPU_uart2_gpio_data	    (CPU_UART2_base + CPU_UART_GPIODATA)
+#define CPU_uart2_gpio_mode	    (CPU_UART2_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+#else
+#error "Unsupported Tango3 chip."
+#endif
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+// IDE interrupts
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+// MBUS interface
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+// GPIO
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+// UART GPIO
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	7   	/* 2^(7+3) = 1024MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<(MAX_LOG2_PCIMEM_MAP+3))*7)>>3)	/* Max ~896MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x40000000UL)   /* base address of EM86xx PCI slave */
+
+// Peripheral bus Registers
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+// Bus Master IDE
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+/* Only applicable to Tango3 */
+#define SDND_MAGIC		0x4d474953      /* SIGM */
+#define SDND_MINORS		16
+#define SDND_MAX_CS		4
+#define KERNEL_SECTOR_SIZE	512
+
+#ifndef __ASSEMBLY__
+
+struct xenv_disk_marker
+{
+	unsigned int magic; 	/* magic# */
+	unsigned int cs;
+};
+
+#ifdef CONFIG_PRINTK
+int printk(const char * fmt, ...) __attribute__ ((format (printf, 1, 2)));
+#else
+static inline int printk(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+#endif
+
+// Physical address mapping
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+	extern unsigned long phy_remap, max_remap_size;
+
+	/* for Tango3, another remap takes place */
+	if ((physaddr >= CPU_REMAP_SPACE) && (physaddr < (CPU_REMAP_SPACE + max_remap_size)))
+		return(phy_remap + (physaddr - CPU_REMAP_SPACE));
+	else {
+		printk("<3>" "dma_address conversion failure (0x%08lx in range 0x%08lx-0x%08lx)\n",
+			physaddr, (unsigned long)CPU_REMAP_SPACE, (unsigned long)CPU_REMAP_SPACE + max_remap_size);
+		return(physaddr); /* use whatever is specified */
+	}
+}
+
+// Inverted physical address mapping
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+	extern unsigned long phy_remap, max_remap_size;
+
+	if ((mapaddr >= phy_remap) && (mapaddr < (phy_remap + max_remap_size)))
+		return(CPU_REMAP_SPACE + (mapaddr - phy_remap));
+	else {
+		printk("<3>" "dma_address inversion failure (0x%08lx in range 0x%08lx-0x%08lx)\n",
+			mapaddr, phy_remap, phy_remap + max_remap_size);
+		return(mapaddr); /* use whatever is specified */
+	}
+}
+#endif
+
+#endif //__HARDWARE_H
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/memcfg.h linux-2.6.22.19/include/asm-mips/tango3/memcfg.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/memcfg.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/memcfg.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,45 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* For more memcfg operations */
+
+#ifndef _MEMCFG_H_
+#define _MEMCFG_H_
+
+#include <linux/config.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_dram.h>
+
+static inline int is_valid_memcfg(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	if ((memcfg_ptr->signature) != MEMCFG_SIGNATURE)
+		return(0);
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	return((sum == 0) ? 1 : 0);
+}
+
+static inline void gen_memcfg_checksum(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	memcfg_ptr->checksum = 0;
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	memcfg_ptr->checksum = ~sum + 1;
+}
+
+#endif /* _MEMCFG_H_ */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/rmdefs.h linux-2.6.22.19/include/asm-mips/tango3/rmdefs.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/rmdefs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/rmdefs.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/tango3api.h linux-2.6.22.19/include/asm-mips/tango3/tango3api.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/tango3api.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/tango3api.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,118 @@
+/*
+ * include/asm-mips/tango3/tango3api.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango3/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA1, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_SATA2, SBOX_MBUS_W2, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_init(void);
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+
+int em86xx_mbus_setup_dma_common(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+void em86xx_mbus_setup_dma_linear(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int flags);
+void em86xx_mbus_setup_dma_double(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int addr2, unsigned int count2, unsigned int flags);
+void em86xx_mbus_setup_dma_rectangle(unsigned int regbase, unsigned int addr, unsigned int horiz, unsigned int lines, int skip, unsigned int flags);
+void em86xx_mbus_setup_dma_void(unsigned int regbase);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+#if defined(CONFIG_EM86XX_UART0_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART0_AS_GPIO_PARTIAL)
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+#endif
+#if defined(CONFIG_EM86XX_UART1_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART1_AS_GPIO_PARTIAL)
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/tango3_gbus.h linux-2.6.22.19/include/asm-mips/tango3/tango3_gbus.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/tango3_gbus.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/tango3_gbus.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,41 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_GBUS_H
+#define __TANGO3_GBUS_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_read_reg32(r)      __raw_readl((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg16(r)      __raw_readw((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg8(r)       __raw_readb((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg32(r, v)  __raw_writel(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg16(r, v)  __raw_writew(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg8(r, v)   __raw_writeb(v, (volatile void __iomem *)KSEG1ADDR(r))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO3_GBUS_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/tango3.h linux-2.6.22.19/include/asm-mips/tango3/tango3.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/tango3.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/tango3.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,65 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   tango3.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO3_H__
+#define __TANGO3_H__
+#include <linux/config.h>
+#include <asm/tango3/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_resources_tango3.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#endif
+#define TANGO3_UART_FREQUENCY   7372800
+/* Baudrate setting */
+#if defined(CONFIG_TANGO3_SMP86XX)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO3_SMP86XX */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO3_SMP86XX */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define SYS_clkgen_pll        SYS_clkgen1_pll
+#endif
+
+#endif // __TANGO3_H__
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/linux/config.h linux-2.6.22.19/include/linux/config.h
--- linux-2.6.22.19.ref/include/linux/config.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/linux/config.h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,8 @@
+#ifndef _LINUX_CONFIG_H
+#define _LINUX_CONFIG_H
+/* This file is no longer in use and kept only for backward compatibility.
+ * autoconf.h is now included via -imacros on the commandline
+ */
+#include <linux/autoconf.h>
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/linux/jiffies.h linux-2.6.22.19/include/linux/jiffies.h
--- linux-2.6.22.19.ref/include/linux/jiffies.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/linux/jiffies.h	2009-04-24 10:51:33.000000000 -0700
@@ -134,7 +134,11 @@
  * Have the 32 bit jiffies value wrap 5 minutes after boot
  * so jiffies wrap bugs show up earlier.
  */
+#if defined(CONFIG_PRINTK_TIME)
+#define INITIAL_JIFFIES 0
+#else
 #define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
+#endif
 
 /*
  * Change timeval to jiffies, trying to avoid the
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/linux/serial_reg.h linux-2.6.22.19/include/linux/serial_reg.h
--- linux-2.6.22.19.ref/include/linux/serial_reg.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/linux/serial_reg.h	2009-04-24 10:51:33.000000000 -0700
@@ -15,12 +15,44 @@
 #define _LINUX_SERIAL_REG_H
 
 /*
- * DLAB=0
+ * smp863x has an 16550 uart, but registers have been messed up...
  */
+#ifdef CONFIG_TANGOX
+
 #define UART_RX		0	/* In:  Receive buffer */
-#define UART_TX		0	/* Out: Transmit buffer */
+#define UART_TX		1	/* Out: Transmit buffer */
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#define UART_LCR	5	/* Out: Line Control Register */
+#define UART_MCR	6	/* Out: Modem Control Register */
+#define UART_LSR	7	/* In:  Line Status Register */
+#define UART_MSR	8	/* In:  Modem Status Register */
+#define UART_SCR	9	/* I/O: Scratch Register */
+
+/* EFR does not exist on TANGOX,  we use a magic to catch accesses and
+ * make them nop */
+#define UART_EFR	42
+
+#else
 
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+#endif
+
+/*
+ * DLAB=0
+ */
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +62,6 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
-#define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -40,7 +71,6 @@
 
 #define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
 
-#define UART_FCR	2	/* Out: FIFO Control Register */
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -83,7 +113,6 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -99,7 +128,6 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
-#define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -110,7 +138,6 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
-#define UART_LSR	5	/* In:  Line Status Register */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -119,7 +146,6 @@
 #define UART_LSR_OE		0x02 /* Overrun error indicator */
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 
-#define UART_MSR	6	/* In:  Modem Status Register */
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -130,18 +156,25 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
-#define UART_SCR	7	/* I/O: Scratch Register */
 
 /*
  * DLAB=1
  */
+
+/*
+ * smp863x has DLM and DLM in one register
+ */
+#ifdef CONFIG_TANGOX
+#define UART_DL		10
+#define UART_CLKSEL	11	/* Clock selection */
+#else
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#endif
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
-#define UART_EFR	2	/* I/O: Extended Features Register */
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/init/Kconfig linux-2.6.22.19/init/Kconfig
--- linux-2.6.22.19.ref/init/Kconfig	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/init/Kconfig	2009-04-24 10:51:33.000000000 -0700
@@ -95,6 +95,14 @@
 
 	  which is done within the script "scripts/setlocalversion".)
 
+config IGNORE_COMPILE_INFO
+	bool "Ignore non constant compile time info"
+	default n
+	help
+	  This options makes  linux binary invariant across successive
+	  compilation by disabling inclusions of variant compile time
+	  data (build user, build_hostname, ...).
+
 config SWAP
 	bool "Support for paging of anonymous memory (swap)"
 	depends on MMU && BLOCK
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/init/Makefile linux-2.6.22.19/init/Makefile
--- linux-2.6.22.19.ref/init/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/init/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -27,7 +27,10 @@
 # mkcompile_h will make sure to only update the
 # actual file if its content has changed.
 
+mkcompile-y := $(srctree)/scripts/mkcompile_h
+mkcompile-$(CONFIG_IGNORE_COMPILE_INFO) := $(srctree)/scripts/mkcompile_fixed_h
+
 include/linux/compile.h: FORCE
 	@echo '  CHK     $@'
-	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkcompile_h $@ \
+	$(Q)$(CONFIG_SHELL) $(mkcompile-y) $@ \
 	"$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CONFIG_PREEMPT)" "$(CC) $(CFLAGS)"
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/Makefile linux-2.6.22.19/Makefile
--- linux-2.6.22.19.ref/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/Makefile	2009-04-24 10:51:33.000000000 -0700
@@ -4,6 +4,9 @@
 EXTRAVERSION = .19
 NAME = Holy Dancing Manatees, Batman!
 
+RELEASE_NAME	:= -19
+
+# *DOCUMENTATION*
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
 # More info can be located in ./README
@@ -314,8 +317,12 @@
 AFLAGS          := -D__ASSEMBLY__
 
 # Read KERNELRELEASE from include/config/kernel.release (if it exists)
+ifneq ($(LOCALVERSION),)
+KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(RELEASE_NAME)$(LOCALVERSION)
+else
 KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
-KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+endif
+KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(RELEASE_NAME)
 
 export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
 export ARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/mkcompile_fixed_h linux-2.6.22.19/mkcompile_fixed_h
--- linux-2.6.22.19.ref/mkcompile_fixed_h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/mkcompile_fixed_h	2009-04-24 10:51:33.000000000 -0700
@@ -0,0 +1,34 @@
+TARGET=$1
+ARCH=$2
+SMP=$3
+PREEMPT=$4
+CC=$5
+
+# Generate a temporary compile.h
+
+( echo /\* This file is auto generated \*/
+
+  echo \#define UTS_MACHINE \"$ARCH\"
+
+  echo \#define UTS_VERSION \"\"
+
+  echo \#define LINUX_COMPILE_TIME \"\"
+  echo \#define LINUX_COMPILE_BY \"\"
+  echo \#define LINUX_COMPILE_HOST \"\"
+
+  echo \#define LINUX_COMPILE_DOMAIN \"\"
+
+  echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
+) > .tmpcompile
+
+# Only replace the real compile.h if the new one is different,
+# in order to preserve the timestamp and avoid unnecessary
+# recompilations.
+
+if [ -r $TARGET ] && cmp -s .tmpcompile $TARGET; then
+   rm -f .tmpcompile
+else
+   echo "  UPD     $TARGET"
+   mv -f .tmpcompile $TARGET
+fi
+rm -f .tmpver.1 .tmpver.2
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/mm/page_alloc.c linux-2.6.22.19/mm/page_alloc.c
--- linux-2.6.22.19.ref/mm/page_alloc.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/mm/page_alloc.c	2009-04-24 10:51:33.000000000 -0700
@@ -1219,6 +1219,7 @@
 	int do_retry;
 	int alloc_flags;
 	int did_some_progress;
+	int num_retries = 0;
 
 	might_sleep_if(wait);
 
@@ -1363,6 +1364,12 @@
 
 nopage:
 	if (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit()) {
+		if (++num_retries < 16) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ);
+			goto rebalance;
+		}
+
 		printk(KERN_WARNING "%s: page allocation failure."
 			" order:%d, mode:0x%x\n",
 			p->comm, order, gfp_mask);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/README.1000.tangox.patch linux-2.6.22.19/README.1000.tangox.patch
--- linux-2.6.22.19.ref/README.1000.tangox.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/README.1000.tangox.patch	2009-04-24 10:56:34.000000000 -0700
@@ -0,0 +1,19 @@
+Feature:
+--------
+Core support for SMP86xx chips
+
+Prerequisite patch numbers:
+---------------------------
+0000
+
+Primary author:
+---------------
+YH Lin
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
+CONFIG_TANGOX (CONFIG_TANGO2 or CONFIG_TANGO3)
