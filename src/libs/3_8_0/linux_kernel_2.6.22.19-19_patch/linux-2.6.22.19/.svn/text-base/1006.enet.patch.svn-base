diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/Kconfig linux-2.6.22.19/drivers/net/Kconfig
--- linux-2.6.22.19.ref/drivers/net/Kconfig	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/net/Kconfig	2009-03-26 19:01:26.000000000 -0700
@@ -1239,6 +1239,24 @@
 	depends on IBM_EMAC && 440GX
 	default y
 
+config TANGO2_ENET
+	tristate "SMP863x Builtin Ethernet support"
+	depends on NET_ETHERNET && TANGO2 
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP863x integrated Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
+config TANGO2_ENET_OLD
+	tristate "SMP863x Builtin Ethernet support (old driver)"
+	depends on NET_ETHERNET && TANGO2 
+	help
+	 This option adds support  for the SMP863x integrated Ethernet
+	 controller. This  is the orignal driver from  Sigma with only
+	 small changes.
+
 config NET_PCI
 	bool "EISA, VLB, PCI and on board controllers"
 	depends on NET_ETHERNET && (ISA || EISA || PCI)
@@ -1889,6 +1907,16 @@
 
 if NETDEV_1000
 
+config TANGOX_ENET
+	tristate "SMP86xx Builtin Gigabit Ethernet support (SMP864x/SMP865x)"
+	depends on NET_ETHERNET && TANGO3
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP86xx integrated Gigabit Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
 config ACENIC
 	tristate "Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support"
 	depends on PCI
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/Makefile linux-2.6.22.19/drivers/net/Makefile
--- linux-2.6.22.19.ref/drivers/net/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/net/Makefile	2009-03-26 19:01:26.000000000 -0700
@@ -205,6 +205,13 @@
 
 obj-$(CONFIG_MACB) += macb.o
 
+# For SMP863x ethernet
+obj-$(CONFIG_TANGO2_ENET) += tango2_enet.o
+obj-$(CONFIG_TANGO2_ENET_OLD) += tango2_enet_old.o
+
+# For SMP86xx ethernet (Tango3)
+obj-$(CONFIG_TANGOX_ENET) += tangox_enet.o
+ 
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
 obj-$(CONFIG_TR) += tokenring/
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/tango2_enet.c linux-2.6.22.19/drivers/net/tango2_enet.c
--- linux-2.6.22.19.ref/drivers/net/tango2_enet.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/drivers/net/tango2_enet.c	2009-03-26 19:01:26.000000000 -0700
@@ -0,0 +1,1103 @@
+/*
+ * New driver for SMP863x builtin Ethernet mac
+ *
+ * This driver uses NAPI and generic linux MII support.
+ *
+ * Tx path limits the number of interrupt by reclaiming sent buffer in
+ * a timer.  In case  the tx starts  to go  faster, it will  switch to
+ * interrupt mode.
+ *
+ * Note that OOM condition is not handled correctly, and can leave the
+ * rx path  in bad  shape. down/up the  interface should make  it work
+ * again though. But anyway, it's not likely to happen.
+ *
+ * Copyright (C) 2005 Maxime Bizon <mbizon@freebox.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+
+#include "tango2_enet.h"
+
+#define PFX	"tango2_enet: "
+
+static struct net_device *gdev;
+static int gphy_id = -1;
+
+/*
+ * mdio read/write callback, can run from userspace or timer
+ */
+static __inline int enet_mdio_read(struct net_device *dev, int phy_id,
+				   int location)
+{
+	int val;
+
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+	enet_writel(ENET_MAC_MIIAR, MIIAR_ADDR(phy_id) | MIIAR_REG(location));
+	udelay(1);
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+	val = enet_readl(ENET_MAC_MIIDR);
+
+	return val;
+}
+
+static void enet_mdio_write(struct net_device *dev, int phy_id,
+				     int location, int val)
+{
+	enet_writel(ENET_MAC_MIIDR, val);
+	enet_writel(ENET_MAC_MIIAR,
+		    MIIAR_ADDR(phy_id) | MIIAR_REG(location) | MIIAR_WRITE);
+	udelay(1);
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+}
+
+/*
+ * enable/disable interrupt helpers
+ * need proper locks since we will call them from any context
+ */
+static __inline void enet_disable_interrupts(struct tango2_enet_priv *priv,
+					     int rx_only)
+{
+	unsigned long flags, val;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	if (rx_only) {
+		val = enet_readl(ENET_DMA_IER);
+		val &= ~IER_R;
+		enet_writel(ENET_DMA_IER, val);
+	} else
+		enet_writel(ENET_DMA_IER, 0);
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+static __inline void enet_enable_interrupts(struct tango2_enet_priv *priv,
+					    int rx_only)
+{
+	unsigned long flags, val;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	if (rx_only) {
+		val = enet_readl(ENET_DMA_IER);
+		val |= IER_R;
+		enet_writel(ENET_DMA_IER, val);
+	} else
+		enet_writel(ENET_DMA_IER, IER_NIS | IER_R | IER_T);
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+
+/*
+ * rx poll func, called by network core
+ */
+static int enet_poll(struct net_device *dev, int *budget)
+{
+	struct tango2_enet_priv *priv;
+	int limit, received;
+
+	priv = netdev_priv(dev);
+
+	/* calculate how many rx packet we are allowed to fetch */
+	limit = *budget;
+	if (*budget > dev->quota)
+		limit = dev->quota;
+	received = 0;
+
+	/* process no more than "limit" done rx */
+	do {
+		volatile struct enet_rx_desc *rx;
+		struct sk_buff *skb;
+		uint32_t rdes0_cache;
+		unsigned int len;
+
+		rx = &priv->rx_descs[priv->last_rx_desc];
+
+		/* we  need  multiple  read  on this  volatile,  avoid
+		 * memory access at each time */
+		rdes0_cache = rx->rdes0;
+		if (rdes0_cache & RDES0_OWN) {
+			break;
+		}
+
+		if (limit <= 0)
+			break;
+		--limit;
+
+		if (likely(skb = priv->rx_skbs[priv->last_rx_desc])) {
+
+			/* we don't handle multipacket frame */
+			if (!(rdes0_cache & RDES0_FIRST) ||
+			    !(rdes0_cache & RDES0_LAST)) {
+				/* we don't handle multipacket frame */
+				priv->stats.rx_errors++;
+				priv->stats.rx_length_errors++;
+				goto rearm;
+			}
+
+			/* check for CRC */
+			if (rdes0_cache & RDES0_CRC) {
+				priv->stats.rx_errors++;
+				priv->stats.rx_crc_errors++;
+				goto rearm;
+			}
+
+			/* sanity check on len field */
+			len = RDES0_FRAME_LEN(rdes0_cache);
+			if (rdes0_cache & (RDES0_TOO_LONG | RDES0_TRUNC) ||
+			    len > RX_BUF_SIZE) {
+				priv->stats.rx_errors++;
+				priv->stats.rx_length_errors++;
+				goto rearm;
+			}
+
+			/* check remaining error */
+			if (rdes0_cache & (RDES0_ERR_SUM | RDES0_COLLISION |
+					   RDES0_WATCHDOG_TMOUT |
+					   RDES0_MII_ERROR)) {
+				priv->stats.rx_errors++;
+				goto rearm;
+			}
+
+			/* ok, seems  valid, adjust skb  proto and len
+			 * and give it to kernel */
+			skb->dev = dev;
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_receive_skb(skb);
+
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += len;
+			dev->last_rx = jiffies;
+			priv->rx_skbs[priv->last_rx_desc] = NULL;
+			/* we will realloc an skb for this slot */
+		}
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (unlikely(!skb))
+			break;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->rdes2 = PHYSADDR(skb->data);
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[priv->last_rx_desc] = skb;
+
+rearm:
+		/* rearm descriptor */
+		wmb();
+		rx->rdes0 = RDES0_OWN;
+		priv->last_rx_desc++;
+		priv->last_rx_desc &= (ENET_RX_DESC_COUNT - 1);
+		received++;
+
+	} while (1);
+
+	dev->quota -= received;
+	*budget -= received;
+
+	if (limit <= 0) {
+		/* breaked, but there is still work to do */
+		return 1;
+	}
+
+        netif_rx_complete(dev);
+	enet_enable_interrupts(priv, 1);
+
+	return 0;
+}
+
+/*
+ * tx reclaim func. Called by timer or tx done tasklet to reclaim sent
+ * buffers.
+ */
+static void enet_tx_reclaim(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	volatile struct enet_tx_desc *tx;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	spin_lock(&priv->tx_lock);
+
+	while (priv->free_tx_desc_count < ENET_TX_DESC_COUNT) {
+		uint32_t tdes0_cache;
+		struct sk_buff *skb;
+
+		tx = &priv->tx_descs[priv->dirty_tx_desc];
+
+		tdes0_cache = tx->tdes0;
+		if (tdes0_cache & TDES0_OWN)
+			break;
+
+		skb = priv->tx_skbs[priv->dirty_tx_desc];
+		priv->stats.tx_packets++;
+
+		/* check  for  transmission  errors and  update  stats
+		 * accordingly */
+		if (tdes0_cache & (TDES0_ERR_SUM | TDES0_CARRIER_LOST |
+				   TDES0_NO_CARRIER | TDES0_LATE_COLLISION |
+				   TDES0_EXC_COLLISION | TDES0_HEARTBEAT |
+				   TDES0_EXC_DEFERAL | TDES0_UNDERFLOW)) {
+			priv->stats.tx_errors++;
+		} else {
+			priv->stats.tx_bytes += skb->len;
+		}
+
+		dev_kfree_skb(skb);
+		priv->tx_skbs[priv->dirty_tx_desc] = NULL;
+		priv->dirty_tx_desc++;
+		priv->dirty_tx_desc %= ENET_TX_DESC_COUNT;
+		priv->free_tx_desc_count++;
+	}
+
+	if (priv->free_tx_desc_count != 0 && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+}
+
+/*
+ * tx done timer callback, just call tx_done and reschedule timer
+ */
+static void enet_tx_reclaim_timer(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+	enet_tx_reclaim(data);
+
+	priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	add_timer(&priv->tx_reclaim_timer);
+}
+
+
+/*
+ * tx request callback
+ */
+static int enet_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	volatile struct enet_tx_desc *tx;
+	unsigned long tdes1_cache;
+
+	spin_lock(&priv->tx_lock);
+
+	priv = netdev_priv(dev);
+	tx = &priv->tx_descs[priv->next_tx_desc];
+
+	/* make sure the next free tx desc is available */
+	if (unlikely(priv->free_tx_desc_count == 0)) {
+		/* no, this  should not happen since  queue is stopped
+		 * before we run out of tx desc */
+		printk(KERN_WARNING PFX "no free tx desc to handle pkt\n");
+		netif_stop_queue(dev);
+		spin_unlock(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* fill the tx desc with this skb address */
+	tdes1_cache = (TDES1_FIRST | TDES1_LAST);
+	if (priv->next_tx_desc == ENET_TX_DESC_COUNT - 1)
+		tdes1_cache |= TDES1_TER;
+
+	/* if we  start to  run low  on free tx  desc, then  enable tx
+	 * interrupt to reclaim them faster */
+	if (priv->free_tx_desc_count == ENET_TX_DESC_LOW) {
+		tdes1_cache |= (TDES1_ENABLE_ISR);
+	}
+	tdes1_cache |= TDES1_TBS1(skb->len);
+
+	tx->tdes1 = tdes1_cache;
+	tx->tdes2 = PHYSADDR(skb->data);
+	dma_cache_wback((unsigned long)skb->data, skb->len);
+
+	/* keep a pointer to it for later and give it to dma  */
+	priv->tx_skbs[priv->next_tx_desc] = skb;
+	wmb();
+	tx->tdes0 = TDES0_OWN;
+
+	/* kick tx dma in case it was suspended */
+	wmb();
+	enet_writel(ENET_DMA_TPDR, 0x1);
+
+	priv->next_tx_desc++;
+	priv->next_tx_desc %= ENET_TX_DESC_COUNT;
+
+	/* if next  tx descriptor is not  clean, then we  have to stop
+	 * queue */
+	if (unlikely(--priv->free_tx_desc_count == 0))
+		netif_stop_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+
+	return NETDEV_TX_OK;
+}
+
+/*
+ * our  irq handler, just  ack it  and schedule  the right  tasklet to
+ * handle this
+ */
+static irqreturn_t enet_isr(int irq, void *dev_id)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	dev = (struct net_device *)dev_id;
+	priv = netdev_priv(dev);
+
+	/* fetch status & ack them */
+	val = enet_readl(ENET_DMA_SR);
+	enet_writel(ENET_DMA_SR, val);
+
+	/* handle interrupt */
+	if (val & SR_NIS) {
+		if (val & SR_T) {
+			tasklet_schedule(&priv->tx_reclaim_tasklet);
+		}
+
+		if (val & SR_R) {
+			if (netif_rx_schedule_prep(dev)) {
+				/* disable rx interrupt */
+				enet_disable_interrupts(priv, 1);
+
+				/* ack  any  interrupt  that may  have
+				 * arrived  between last ack  to avoid
+				 * reentering */
+				enet_writel(ENET_DMA_SR, SR_NIS | SR_R);
+				__netif_rx_schedule(dev);
+			}
+		}
+	}
+
+        return IRQ_HANDLED;
+}
+
+/*
+ * start/stop dma engine
+ */
+static __inline void enet_start_dma(struct tango2_enet_priv *priv)
+{
+	/* send start command to rx & tx dma */
+	enet_writel(ENET_DMA_CR, CR_SF | CR_SR | CR_ST);
+}
+
+static __inline void enet_stop_dma(struct tango2_enet_priv *priv)
+{
+	unsigned long val;
+
+	/* send stop command to rx & tx dma */
+	enet_writel(ENET_DMA_CR, 0);
+
+	/* wait for them to reach stopped state, should not be long */
+	do {
+		udelay(1);
+		val = enet_readl(ENET_DMA_SR);
+		if ((val & SR_TPS) && (val & SR_RPS))
+			break;
+	} while (1);
+}
+
+/*
+ * reconfigure mac for new link state
+ */
+static void enet_link_reconfigure(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	priv = netdev_priv(dev);
+
+	if (dev->flags & IFF_UP)
+		enet_stop_dma(priv);
+
+	/* reflect duplex status in dma register */
+	spin_lock(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MACCR);
+	if (priv->mii.full_duplex)
+		val |= MACCR_F;
+	else
+		val &= ~MACCR_F;
+	enet_writel(ENET_MAC_MACCR, val);
+	spin_unlock(&priv->maccr_lock);
+
+	if (dev->flags & IFF_UP)
+		enet_start_dma(priv);
+}
+
+/*
+ * link check timer callback
+ */
+static void enet_link_check(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	/* check for duplex change */
+	spin_lock(&priv->mii_lock);
+	ret = mii_check_media(&priv->mii, 1, 0);
+	spin_unlock(&priv->mii_lock);
+
+	if (ret)
+		enet_link_reconfigure(dev);
+
+	/* reschedule timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+}
+
+/*
+ * program given mac address in hw registers
+ */
+static int enet_set_mac_address(struct net_device *dev, void *addr)
+{
+	unsigned long hi_mac, low_mac;
+	struct sockaddr *sock = addr;
+
+	/* to make it safe, we won't do this while running */
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+
+	hi_mac = (dev->dev_addr[5] << 8) | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24)| (dev->dev_addr[2] << 16) |
+		(dev->dev_addr[1] << 8) | dev->dev_addr[0];
+
+	enet_writel(ENET_MAC_MACAHR, hi_mac);
+	enet_writel(ENET_MAC_MACALR, low_mac);
+
+	return 0;
+}
+
+/*
+ * update hash table to reflect new device multicast address list
+ */
+static void enet_set_multicast_list(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	struct dev_mc_list *mclist;
+	unsigned long val;
+	uint32_t mc_filter[2];
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* the link check timer might change MACCR, we need to protect
+	 * against it */
+	spin_lock_bh(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MACCR);
+
+        if (dev->flags & IFF_PROMISC) {
+                val |= MACCR_PR | MACCR_PM;
+	} else {
+		val &= ~MACCR_PR;
+		/* if we want all multicast or if address count is too
+		 * high, don't try to compute hash value */
+		if (dev->mc_count > 64 || dev->flags & IFF_ALLMULTI) {
+			val |= MACCR_PM;
+		}
+	}
+	enet_writel(ENET_MAC_MACCR, val);
+	spin_unlock_bh(&priv->maccr_lock);
+
+	/* we  don't  need  to  update  hash  table  if  we  pass  all
+	 * multicast */
+	if (val & MACCR_PM)
+		return;
+
+	mc_filter[0] = mc_filter[1] = 0;
+	mclist = dev->mc_list;
+
+	for (i = 0; i < dev->mc_count; i++) {
+		unsigned int n;
+		char *addr;
+
+		addr = mclist->dmi_addr;
+		mclist = mclist->next;
+		if (!(*addr & 1))
+			continue;
+
+		n = ether_crc(ETH_ALEN, addr) >> 26;
+		mc_filter[n >> 5] |= 1 << (n & 31);
+	}
+
+	enet_writel(ENET_MAC_MALR, mc_filter[0]);
+	enet_writel(ENET_MAC_MAHR, mc_filter[1]);
+}
+
+/*
+ * open callback
+ */
+static int enet_open(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	priv = netdev_priv(dev);
+
+	/* check link */
+	if (mii_check_media(&priv->mii, 1, 1))
+		enet_link_reconfigure(dev);
+
+	/* start rx & tx dma engine */
+	enet_start_dma(priv);
+
+	/* enable mac rx & tx */
+	val = enet_readl(ENET_MAC_MACCR);
+	val |= MACCR_TE | MACCR_RE;
+	enet_writel(ENET_MAC_MACCR, val);
+
+	/*
+	 * clear & enable interrupts, we want:
+	 * - receive complete
+	 * - transmit complete
+	 */
+	enet_writel(ENET_DMA_SR, SR_NIS | SR_R | SR_T);
+	enet_enable_interrupts(priv, 0);
+
+	/* start link check & tx reclaim timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+
+	priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	add_timer(&priv->tx_reclaim_timer);
+
+	/* and finally start tx queue */
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * stop callback
+ */
+static int enet_stop(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* stop link timer */
+	del_timer_sync(&priv->link_check_timer);
+
+	/* stop tx queue */
+	netif_stop_queue(dev);
+
+	/* wait for all tx buffers to be reclaimed */
+	while (priv->free_tx_desc_count != ENET_TX_DESC_COUNT)
+		yield();
+
+	/* stop tx reclaim timer */
+	del_timer_sync(&priv->tx_reclaim_timer);
+
+	/* disable all interrupts */
+	enet_disable_interrupts(priv, 0);
+
+	/* stop dma */
+	enet_stop_dma(priv);
+
+	/* stop mac rx & tx */
+	val = enet_readl(ENET_MAC_MACCR);
+	val &= ~(MACCR_TE | MACCR_RE);
+	enet_writel(ENET_MAC_MACCR, val);
+
+	/* while we were stopping it,  the rx dma may have filled some
+	 * buffer, consider it junk and rearm all descriptor */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		volatile struct enet_rx_desc *rx;
+
+		rx = &priv->rx_descs[i];
+		rx->rdes0 = RDES0_OWN;
+	}
+
+	/* make  the dma engine  restarts at  first descriptor  in the
+	 * list */
+	enet_writel(ENET_DMA_RBAR, PHYSADDR(priv->rx_descs));
+	enet_writel(ENET_DMA_TBAR, PHYSADDR(priv->tx_descs));
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->last_rx_desc = 0;
+
+	return 0;
+}
+
+/*
+ * get_stats callback
+ */
+static struct net_device_stats *enet_get_stats(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+
+	priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+/*
+ * ethtool callbacks
+ */
+static int enet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_gset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_sset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_nway_reset(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_nway_restart(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static u32 enet_get_link(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_link_ok(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static struct ethtool_ops enet_ethtool_ops = {
+	.get_settings		= enet_get_settings,
+	.set_settings		= enet_set_settings,
+	.nway_reset		= enet_nway_reset,
+	.get_link		= enet_get_link,
+};
+
+static int enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii);
+	ret = generic_mii_ioctl(&priv->mii, if_mii(rq), cmd, NULL);
+	spin_unlock_bh(&priv->mii);
+
+	return ret;
+}
+
+/*
+ * dma ring allocation is done here
+ */
+static int enet_dma_init(struct tango2_enet_priv *priv)
+{
+	unsigned int size;
+	int i;
+
+	/*
+	 * allocate rx descriptor list & rx buffers
+	 *
+	 * We allocate  skb now and fill buffer  with their addresses,
+	 * note that we reserve 4 bytes at beginning of data buffer to
+	 * store skb address.
+	 *
+	 */
+	size = ENET_RX_DESC_COUNT * sizeof (struct enet_rx_desc);
+	if (!(priv->rx_descs_cached = kmalloc(size, GFP_KERNEL)))
+		return -ENOMEM;
+	priv->rx_descs = (volatile struct enet_rx_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->rx_descs_cached);
+	dma_cache_wback_inv((unsigned long)priv->rx_descs_cached, size);
+
+	/*
+	 * initialize all rx descs
+	 */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		volatile struct enet_rx_desc *rx;
+		struct sk_buff *skb;
+
+		rx = &priv->rx_descs[i];
+		rx->rdes0 = RDES0_OWN;
+
+		rx->rdes1 = RDES1_RBS2(0) | RDES1_RBS1(RX_BUF_SIZE);
+		if (i == ENET_RX_DESC_COUNT - 1)
+			rx->rdes1 |= RDES1_RER;
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (!skb)
+			return -ENOMEM;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->rdes2 = PHYSADDR(skb->data);
+		rx->rdes3 = 0;
+
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[i] = skb;
+	}
+	priv->last_rx_desc = 0;
+
+	/*
+	 * allocate tx descriptor list
+	 *
+	 * We allocate  only the descriptor list and  prepare them for
+	 * further use. When tx is needed, we will set the right flags
+	 * and kick the dma.
+	 */
+	size = ENET_TX_DESC_COUNT * sizeof (struct enet_tx_desc);
+	if (!(priv->tx_descs_cached = kmalloc(size, GFP_KERNEL)))
+		return -ENOMEM;
+	priv->tx_descs = (volatile struct enet_tx_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->tx_descs_cached);
+	dma_cache_wback_inv((unsigned long)priv->tx_descs_cached, size);
+
+	/*
+	 * initialize tx descs
+	 */
+	for (i = 0; i < ENET_TX_DESC_COUNT; i++) {
+		volatile struct enet_tx_desc *tx;
+
+		tx = &priv->tx_descs[i];
+		tx->tdes0 = 0;
+		tx->tdes1 = 0;
+		if (i == ENET_TX_DESC_COUNT - 1)
+			tx->tdes1 |= TDES1_TER;
+		tx->tdes2 = 0;
+		tx->tdes3 = 0;
+	}
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->free_tx_desc_count = ENET_TX_DESC_COUNT;
+
+	/*
+	 * write rx desc list & tx desc list addresses in registers
+	 */
+	enet_writel(ENET_DMA_RBAR, PHYSADDR(priv->rx_descs));
+	enet_writel(ENET_DMA_TBAR, PHYSADDR(priv->tx_descs));
+
+	return 0;
+}
+
+/*
+ * free  all dma rings  memory, called  at uninit  time or  when error
+ * occurs at init time
+ */
+static void enet_dma_free(struct tango2_enet_priv *priv)
+{
+	int i;
+
+	/* note: kfree(NULL) is ok */
+	kfree(priv->rx_descs_cached);
+	kfree(priv->tx_descs_cached);
+
+	/* note: kfree_skb(NULL) is _not_ ok */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		if (priv->rx_skbs[i])
+			kfree_skb(priv->rx_skbs[i]);
+	}
+
+	for (i = 0; i < ENET_TX_DESC_COUNT; i++) {
+		if (priv->tx_skbs[i])
+			kfree_skb(priv->tx_skbs[i]);
+	}
+}
+
+/*
+ * mac hw init is done here
+ */
+static int enet_hw_init(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int loop;
+
+	priv = netdev_priv(dev);
+
+	/* reset phy */
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, BMCR_RESET);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_mdio_read(dev, priv->mii.phy_id,
+				     MII_BMCR) & BMCR_RESET))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR PFX "PHY reset does not complete...\n");
+		return -EBUSY;
+	}
+
+	/* reset dma engine */
+	enet_writel(ENET_DMA_BMR, BMR_SWR);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_readl(ENET_DMA_BMR) & BMR_SWR))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR PFX "dma engine does not exit reset...\n");
+		return -EBUSY;
+	}
+
+	/* set bus mode */
+	enet_writel(ENET_DMA_BMR, BMR_PBL(32));
+
+	/* enable MAC flow ctrl */
+	enet_writel(ENET_MAC_FCR, FCR_ENABLE);
+
+	/* configure MAC ctrller to do hash perfect filtering  */
+	enet_writel(ENET_MAC_MACCR, MACCR_ASTP | MACCR_HP);
+
+	/* clear hash table */
+	enet_writel(ENET_MAC_MAHR, 0xffffffff);
+	enet_writel(ENET_MAC_MALR, 0xffffffff);
+
+	return 0;
+}
+
+
+
+/*
+ * allocate  netdevice structure,  do  all dma  rings allocations  and
+ * register the netdevice
+ */
+extern int tangox_ethernet_getmac(int, unsigned char *);
+
+static int enet_probe(void)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+	int ret;
+	struct sockaddr sock;
+
+	printk(KERN_INFO PFX "ethernet driver for SMP863x internal mac\n");
+
+	/* allocate  netdevice structure  with enough  length  for our
+	 * context data */
+	dev = alloc_etherdev(sizeof (*priv));
+	if (!dev)
+		return -ENOMEM;
+
+	/* initialize private data */
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof (*priv));
+	spin_lock_init(&priv->tx_lock);
+	spin_lock_init(&priv->ier_lock);
+	spin_lock_init(&priv->maccr_lock);
+
+	/* init tx done tasklet */
+	tasklet_init(&priv->tx_reclaim_tasklet, enet_tx_reclaim,
+		     (unsigned long)dev);
+
+	/* init tx reclaim timer */
+	init_timer(&priv->tx_reclaim_timer);
+	priv->tx_reclaim_timer.data = (unsigned long )dev;
+	priv->tx_reclaim_timer.function = enet_tx_reclaim_timer;
+
+	/* init link check timer and mii lock */
+	init_timer(&priv->link_check_timer);
+	priv->link_check_timer.data = (unsigned long)dev;
+	priv->link_check_timer.function = enet_link_check;
+	spin_lock_init(&priv->mii_lock);
+
+	/* fill mii info */
+	priv->mii.dev = dev;
+	priv->mii.phy_id_mask = 0x1f;
+	priv->mii.reg_num_mask = 0x1f;
+	priv->mii.mdio_read = enet_mdio_read;
+	priv->mii.mdio_write = enet_mdio_write;
+
+	if (gphy_id != -1) {
+		/* phy id forced, just check for sanity */
+		if (gphy_id < 0 || gphy_id > 31) {
+			ret = -EINVAL;
+			goto err_free;
+		}
+		priv->mii.phy_id = gphy_id;
+
+	} else {
+		int i;
+
+		/* try to probe phy if not given */
+		for (i = 1; i < 32; i++) {
+			uint32_t id;
+			int val;
+
+			val = enet_mdio_read(dev, i, MII_PHYSID1);
+			id = (val << 16);
+			val = enet_mdio_read(dev, i, MII_PHYSID2);
+			id |= val;
+
+			if (id != 0xffffffff && id != 0x00000000)
+				break;
+		}
+
+		if (i == 32) {
+			printk(KERN_ERR PFX "unable to autodetect phy\n");
+			ret = -EIO;
+			goto err_free;
+		}
+
+		printk(KERN_ERR PFX "detected phy at address 0x%02x\n", i);
+		priv->mii.phy_id = i;
+	}
+
+	/* initialize hardware */
+	if ((ret = enet_hw_init(dev)))
+		goto err_free;
+
+	/* initialize dma rings */
+	if ((ret = enet_dma_init(priv)))
+		goto err_free;
+
+	/* register interrupt handler */
+	ret = request_irq(ENET_IRQ, enet_isr, IRQF_SHARED, "tango2_enet", dev);
+	if (ret)
+		goto err_free;
+	dev->irq = ENET_IRQ;
+
+	/* install driver callbacks and register netdevice */
+	dev->open = enet_open;
+	dev->stop = enet_stop;
+	dev->hard_start_xmit = enet_xmit;
+	dev->get_stats = enet_get_stats;
+	dev->set_mac_address = enet_set_mac_address;
+	dev->set_multicast_list = enet_set_multicast_list;
+	dev->poll = enet_poll;
+	dev->ethtool_ops = &enet_ethtool_ops;
+	dev->do_ioctl = enet_ioctl;
+	dev->weight = 16;
+
+	/* set default mac address */
+	tangox_ethernet_getmac(0, dev->dev_addr);
+	memcpy(&(sock.sa_data), dev->dev_addr, ETH_ALEN);
+	enet_set_mac_address(dev, &sock);
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR PFX "unable to register netdevice\n");
+		goto err_free;
+	}
+
+	printk(KERN_INFO PFX "mac address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	gdev = dev;
+	return 0;
+
+err_free:
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	enet_dma_free(priv);
+	free_netdev(dev);
+	return ret;
+}
+
+
+/*
+ * entry point, checks if ethernet is  enabled on the board and if so,
+ * probes it
+ */
+extern int tangox_ethernet_enabled(int);
+
+int __init tango2_enet_init(void)
+{
+	if (!tangox_ethernet_enabled(0)) {
+		printk(KERN_NOTICE PFX "ethernet support is disabled\n");
+		return -ENODEV;
+	}
+
+	return enet_probe();
+}
+
+/*
+ * exit func, stops hardware and unregisters netdevice
+ */
+void __exit tango2_enet_exit(void)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+
+	dev = gdev;
+
+	free_irq(dev->irq, dev);
+	unregister_netdev(dev);
+
+	priv = netdev_priv(dev);
+	enet_dma_free(priv);
+
+	free_netdev(dev);
+}
+
+
+module_init(tango2_enet_init);
+module_exit(tango2_enet_exit);
+
+MODULE_DESCRIPTION("SMP863x internal ethernet mac driver");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_LICENSE("GPL");
+MODULE_PARM_DESC(gphy_id, "PHY id, else autodetect");
+module_param(gphy_id, int, 0);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/tango2_enet.h linux-2.6.22.19/drivers/net/tango2_enet.h
--- linux-2.6.22.19.ref/drivers/net/tango2_enet.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/drivers/net/tango2_enet.h	2009-03-26 19:01:26.000000000 -0700
@@ -0,0 +1,313 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+  
+#ifndef __TANGO2_ENET_H
+#define __TANGO2_ENET_H
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+
+#include <asm/addrspace.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#else
+#error "Unknown architecture"
+#endif
+
+#define ENET_IRQ	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC_INT))
+
+/*
+ * number of rx/tx buffers available
+ * !!! MUST BE A POWER OF 2 !!!
+ */
+#define ENET_RX_DESC_COUNT	64
+#define ENET_TX_DESC_COUNT	64
+
+/*
+ * we enable tx  interrupt when there is equal to  this number of free
+ * tx desc. Keep it lower than ENET_TX_DESC_COUNT if you change it.
+ */
+#define ENET_TX_DESC_LOW	20
+
+/*
+ * sizeof rx buffers we give to the dma controller
+ */
+#define RX_BUF_SIZE		0x600
+
+/*
+ * ipv4 stack  assumes received  ip header is  32 bits aligned,  so we
+ * keep 2 bytes to align ip header
+ */
+#define SKB_RESERVE_SIZE	2
+
+/*
+ * we reclaim  transmited using a  timer, we switch to  interrupt mode
+ * under high load. this is the timer frequency
+ */
+#define TX_RECLAIM_TIMER_FREQ	(HZ / 100)
+
+/*
+ * link status  is polled on a regular  basis by a timer,  this is its
+ * frequency
+ */
+#define LINK_CHECK_TIMER_FREQ	(HZ)
+
+
+/*
+ * address space conversion
+ */
+#define CACHE_TO_NONCACHE(x)	KSEG1ADDR(x)
+#define PHYSADDR(x)		tangox_dma_address(CPHYSADDR(x))
+
+
+/*
+ * Mac/DMA registers offset, refer to documentation
+ */
+#define ENET_HOST_BASE		REG_BASE_host_interface
+
+/* mac registers */
+#define ENET_MAC_BASE		(ENET_HOST_BASE + 0x6000)
+#define ENET_MAC_MACCR		(ENET_MAC_BASE + 0x0)
+#define MACCR_F			(1 << 20)
+#define MACCR_PM		(1 << 19)
+#define MACCR_PR		(1 << 18)
+#define MACCR_HP		(1 << 13)
+#define MACCR_ASTP		(1 << 8)
+#define MACCR_TE		(1 << 3)
+#define MACCR_RE		(1 << 2)
+#define ENET_MAC_MACAHR		(ENET_MAC_BASE + 0x4)
+#define ENET_MAC_MACALR		(ENET_MAC_BASE + 0x8)
+#define ENET_MAC_MAHR		(ENET_MAC_BASE + 0xc)
+#define ENET_MAC_MALR		(ENET_MAC_BASE + 0x10)
+#define ENET_MAC_MIIAR		(ENET_MAC_BASE + 0x14)
+#define MIIAR_ADDR(x)		((x) << 11)
+#define MIIAR_REG(x)		((x) << 6)
+#define MIIAR_WRITE		(1 << 1)
+#define MIIAR_BUSY		(1 << 0)
+#define ENET_MAC_MIIDR		(ENET_MAC_BASE + 0x18)
+#define ENET_MAC_FCR		(ENET_MAC_BASE + 0x1c)
+#define FCR_ENABLE		(1 << 1)
+
+/* dma registers */
+#define ENET_DMA_BASE		(ENET_HOST_BASE + 0x7000)
+#define ENET_DMA_BMR		(ENET_DMA_BASE + 0x00)
+#define BMR_PBL(x)		((x & 0x3f) << 8)
+#define BMR_SWR			(1 << 0)
+#define ENET_DMA_TPDR		(ENET_DMA_BASE + 0x04)
+#define ENET_DMA_RPDR		(ENET_DMA_BASE + 0x08)
+#define ENET_DMA_RBAR		(ENET_DMA_BASE + 0x0c)
+#define ENET_DMA_TBAR		(ENET_DMA_BASE + 0x10)
+#define ENET_DMA_SR		(ENET_DMA_BASE + 0x14)
+#define SR_EB(x)		(((x) >> 23) & 0x3)
+#define SR_TS(x)		(((x) >> 20) & 0x7)
+#define SR_RS(x)		(((x) >> 17) & 0x7)
+#define SR_NIS			(1 << 16)
+#define SR_AIS			(1 << 15)
+#define SR_ERI			(1 << 14)
+#define SR_FBE			(1 << 13)
+#define SR_ETI			(1 << 12)
+#define SR_RWT			(1 << 11)
+#define SR_RPS			(1 << 8)
+#define SR_RU			(1 << 7)
+#define SR_R			(1 << 6)
+#define SR_UNF			(1 << 5)
+#define SR_TU			(1 << 4)
+#define SR_TPS			(1 << 1)
+#define SR_T			(1 << 0)
+#define ENET_DMA_CR		(ENET_DMA_BASE + 0x18)
+#define CR_SF			(1 << 21)
+#define CR_ST			(1 << 13)
+#define CR_SR			(1 << 1)
+#define ENET_DMA_IER		(ENET_DMA_BASE + 0x1c)
+#define IER_NIS			(1 << 16)
+#define IER_AIS			(1 << 15)
+#define IER_ERE			(1 << 14)
+#define IER_FBE			(1 << 13)
+#define IER_ETE			(1 << 10)
+#define IER_RWT			(1 << 9)
+#define IER_RS			(1 << 8)
+#define IER_RU			(1 << 7)
+#define IER_R			(1 << 6)
+#define IER_UE			(1 << 5)
+#define IER_TBU			(1 << 2)
+#define IER_TS			(1 << 1)
+#define IER_T			(1 << 0)
+#define ENET_DMA_CHRBA		(ENET_DMA_BASE + 0x54)
+
+
+/*
+ * rx dma descriptor definition
+ */
+struct enet_rx_desc {
+	unsigned long rdes0;
+	unsigned long rdes1;
+	unsigned long rdes2;
+	unsigned long rdes3;
+};
+
+#define RDES0_OWN		(1 << 31)
+#define RDES0_FILTER_FAIL	(1 << 30)
+#define RDES0_FRAME_LEN(x)	(((x) & 0x1fff0000) >> 16)
+#define RDES0_ERR_SUM		(1 << 15)
+#define RDES0_TRUNC		(1 << 14)
+#define RDES0_FIRST		(1 << 9)
+#define RDES0_LAST		(1 << 8)
+#define RDES0_TOO_LONG		(1 << 7)
+#define RDES0_COLLISION		(1 << 6)
+#define RDES0_WATCHDOG_TMOUT	(1 << 4)
+#define RDES0_MII_ERROR		(1 << 3)
+#define RDES0_CRC		(1 << 1)
+
+#define RDES1_DISABLE_ISR	(1 << 31)
+#define RDES1_RER		(1 << 25)
+#define RDES1_RCH		(1 << 24)
+#define RDES1_RBS2(x)		((x) << 11)
+#define RDES1_RBS1(x)		(x)
+
+
+
+/*
+ * tx dma descriptor definition
+ */
+struct enet_tx_desc {
+	uint32_t tdes0;
+	uint32_t tdes1;
+	uint32_t tdes2;
+	uint32_t tdes3;
+};
+
+#define TDES0_OWN		(1 << 31)
+#define TDES0_ERR_SUM		(1 << 15)
+#define TDES0_CARRIER_LOST	(1 << 11)
+#define TDES0_NO_CARRIER	(1 << 10)
+#define TDES0_LATE_COLLISION	(1 << 9)
+#define TDES0_EXC_COLLISION	(1 << 8)
+#define TDES0_HEARTBEAT		(1 << 7)
+#define TDES0_EXC_DEFERAL	(1 << 2)
+#define TDES0_UNDERFLOW		(1 << 1)
+
+#define TDES1_ENABLE_ISR	(1 << 31)
+#define TDES1_LAST	 	(1 << 30)
+#define TDES1_FIRST		(1 << 29)
+#define TDES1_DISABLE_FCS	(1 << 26)
+#define TDES1_TER	 	(1 << 25)
+#define TDES1_TCH	 	(1 << 24)
+#define TDES1_DISABLE_PADDING	(1 << 23)
+#define TDES1_TBS2(x)		((x) << 11)
+#define TDES1_TBS1(x)		(x)
+
+
+/*
+ * our private context
+ */
+struct tango2_enet_priv {
+
+	/*
+	 * rx related
+	 */
+
+	/* pointer to rx descriptor array */
+	volatile struct enet_rx_desc	*rx_descs;
+	struct enet_rx_desc		*rx_descs_cached;
+
+	/* last rx descriptor processed */
+	unsigned int			last_rx_desc;
+
+	/* we keep a list of skb given */
+	struct sk_buff			*rx_skbs[ENET_RX_DESC_COUNT];
+
+	/* ethernet device stats */
+	struct net_device_stats		stats;
+
+
+
+
+	/*
+	 * tx related
+	 */
+
+	/* access  to  tx related  dma  stuffs  is  protected by  this
+	 * spinlock, this is because we  access them via a tasklet and
+	 * a timer */
+	spinlock_t			tx_lock;
+
+	/* pointer to tx descriptor array */
+	volatile struct enet_tx_desc	*tx_descs;
+	struct enet_tx_desc		*tx_descs_cached;
+
+	/* index of current dirty tx descriptor */
+	unsigned int			dirty_tx_desc;
+
+	/* index of next clean tx descriptor to use */
+	unsigned int			next_tx_desc;
+
+	/* count of free tx desc to avoid its computation */
+	unsigned int			free_tx_desc_count;
+
+	/* list of sent skb */
+	struct sk_buff			*tx_skbs[ENET_TX_DESC_COUNT];
+
+	/* tx  done operation is  done under  these tasklet  and timer
+	 * context */
+	struct tasklet_struct		tx_reclaim_tasklet;
+	struct timer_list		tx_reclaim_timer;
+
+
+	/*
+	 * misc
+	 */
+
+	/* spinlock used to protect interrupt enable register */
+	spinlock_t			ier_lock;
+
+	/* spinlock used to protect maccr register */
+	spinlock_t			maccr_lock;
+
+	/* our mii state */
+	struct mii_if_info		mii;
+
+	/* mii access is protected by following spinlock */
+	spinlock_t			mii_lock;
+
+	/* link status is checked periodically by this timer */
+	struct timer_list		link_check_timer;
+};
+
+/*
+ * helpers to access registers
+ */
+
+static inline unsigned long enet_readl(unsigned long addr)
+{
+	unsigned long tmp = 0;
+	unsigned long res = gbus_read_reg32(addr);
+	extern int is_tango2_es6(void);
+	if (is_tango2_es6()) 
+		tmp = gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	return(res);
+}
+
+static inline void enet_writel(unsigned long addr, unsigned long data)
+{
+	gbus_write_reg32(addr, data);
+
+	/* some write  read sequence seems  to freeze completly  if no
+	 * barrier is done between each access. To be safe, we do this
+	 * after all write access */
+	iob();
+}
+
+#endif /* __TANGO2_ENET_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/tango2_enet_old.c linux-2.6.22.19/drivers/net/tango2_enet_old.c
--- linux-2.6.22.19.ref/drivers/net/tango2_enet_old.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/drivers/net/tango2_enet_old.c	2009-03-26 19:01:26.000000000 -0700
@@ -0,0 +1,2297 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+  
+/*
+ *  Embedded Ethernet driver for TANGO2 ES4 or above
+ */
+#ifdef BOOTLOADER
+#include "config.h"
+#include "version.h"
+#include "util.h"
+#include "net.h"
+#include "net_ipv4.h"
+#include "em86xxapi.h"
+#include "irqs.h"
+#include "errno.h"
+#include "uart.h"
+#include "memcfg.h"
+#else
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+//#include <linux/compatmac.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/memcfg.h>
+#else
+#include <asm/virtconvert.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/memcfg.h>
+#endif
+
+// Use kernel timer implementation for polling the link status
+// #define USE_KERNEL_TIMER
+
+#endif //BOOTLOADER
+
+#include "tango2_enet_old.h"
+
+#define DRV_NAME	"em86xx-eth"
+#define DRV_VERSION     "-0.0.0.0.1"
+
+/* Uncomment this for different messages */
+//#define ETH_DEBUG 
+#define ETH_ERRMSG 
+#define ETH_MSG
+//#define ETH_DBG_INOUT
+//#define DEBUG_RX_TX_STATE
+//#define DEBUG_MDIO
+
+#ifdef BOOTLOADER
+#define DRIVER "em86xx_eth"
+
+/* For static buffer allocation */
+// #define STATIC_BUF_ALLOC
+#define printk          uart_printf
+
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+#define MAX_ORDER	10
+
+#endif /* BOOTLOADER */
+
+/* For software filtering*/
+//#define USE_SW_FILTERING
+#define USE_HW_FILTERING
+
+#ifdef ETH_DEBUG
+#define DBG_PRINT	printk
+#else
+static void inline DBG_PRINT(const char *x, ...) { ; }
+#endif /* ETH_DEBUG */
+
+#ifdef ETH_ERRMSG
+#define ERR_PRINT	printk
+#else
+static void inline ERR_PRINT(const char *x, ...) { ; }
+#endif /* ETH_ERRMSG */
+
+#ifdef ETH_MSG
+#define MSG_PRINT	printk
+#else
+static void inline MSG_PRINT(const char *x, ...) { ; }
+#endif /* ETH_ERRMSG */
+
+#ifdef ETH_DBG_INOUT
+#define DBG_PRINT_INOUT_FUNC(x) printk("%s: %s\n", __func__, x);
+#define MSG_PRINT	printk
+#else
+static void inline DBG_PRINT_INOUT_FUNC(const char *x, ...) { ; }
+#endif /* ETH_ERRMSG */
+
+/* Hack: this is the mac address by default */
+#define DEF_MAC_HI	0x00000011
+#ifdef BOOTLOADER
+#define DEF_MAC_LO	0xdeadbeef
+#else
+#define DEF_MAC_LO	0xaabbccdd
+#endif
+
+/* Default maximum link wait */
+#ifdef USE_KERNEL_TIMER
+#define DEF_LINK_LOOP		0x10000
+#else
+#define DEF_LINK_LOOP		0x100
+#endif
+#define DEF_MAX_LINK_LOOP	(DEF_LINK_LOOP * 16)
+
+#define ETH_IRQ_FLAGS   (DmaIntNormal     | DmaIntAbnormal    | DmaIntRxStopped         | \
+		         DmaIntRxNoBuffer | DmaIntRxCompleted | DmaIeTxUnderflow        | \
+                         DmaIeTxStopped   | DmaIeTxCompleted) 
+/*	(DmaIntNormal	  | DmaIntAbnormal    | DmaIntRxStopped		| \
+			 DmaIntRxNoBuffer | DmaIntRxCompleted | DmaIntTxCompleted)
+*/
+#define ETH_RXTX_FLAGS	(DmaTxStart       | DmaRxStart	      | DmaStoreAndForward)
+
+#ifndef USE_HW_FILTERING 
+#define ETH_MAC_FLAGS   (MacTxEnable      |  MacRxEnable       | MacPromiscuousModeOn	| \
+                        MacPadStripEnable |  MacHashFilterOn   | MacPerfectFilterOff 	| \
+                        MacRetryEnable    |  MacHeartBeatOff)
+#else 
+#define ETH_MAC_FLAGS	(MacTxEnable   	  | MacRxEnable        | MacPromiscuousModeOff  | \
+			MacPadStripEnable | MacHashFilterOn    | MacPerfectFilterOn     | \
+                        MacRetryEnable    | MacMulticastFilterOn | MacHeartBeatOff)
+#define DEFAULT_BROADCAST_ADDRESS { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF }
+static void em86xx_eth_set_multicast_list(struct net_device *dev);
+#endif /*USE_HW_FILTERING*/
+
+#define MD_FRAME_FLAGS  (DescRxLast        | DescRxFirst)
+#define TX_DESC1_FLAGS 	(DescTxLast        | DescTxFirst        | DescChain             | \
+			 DescTxIntEnable)
+#define RX_ERROR_FLAGS  (DescFilteringFail | DescError		| DescRxTruncated	| \
+			 DescLengthError   | DescRxDamaged 	| DescRxLongFrame	| \
+			 DescRxCollision   | DescRxMiiError	| DescRxCrc)
+#define TX_ERROR_FLAGS  (DescTxLostCarrier | DescTxNoCarrier	| DescTxLateCollision 	| \
+			 DescTxExcCollisions| DescTxHeartbeatFail| DescTxUnderflow)
+
+#if defined(CONFIG_TANGOX) 
+extern int tangox_ethernet_getmac(int idx, unsigned char *mac);
+extern int tangox_ethernet_enabled(int);
+#endif
+
+#define PHY_10BASET_HD_ANAR  	 (CSMACD | BASET10 | FLOWCONTROL | RF)
+#define PHY_10BASET_FD_ANAR 	 (CSMACD | BASET10 | BASET10FD | FLOWCONTROL | RF)
+#define PHY_100BASET_HD_ANAR	 (CSMACD | BASET10 | BASET10FD | BASET100 | FLOWCONTROL | RF)
+#define PHY_100BASET_FD_ANAR	 (CSMACD | BASET10 | BASET10FD | BASET100 | BASET100FD | FLOWCONTROL | RF)
+
+/* Number of descriptors and buffer size */
+#define MIN_NUM_RDESC	8
+#define MIN_NUM_TDESC	8
+#define NUM_RDESC 	64
+#define NUM_TDESC	64
+#define R_BUF_SIZE	0x700	/* needs to be < 2KB */
+#define T_BUF_SIZE	0x700	/* needs to be < 2KB */
+
+#if (R_BUF_SIZE < (1 << 14))
+/* For multi-descriptor frame support: only when receive buffer size < 16384 */
+#define MULTI_DESCS_FRAME_SUPPORT
+#endif
+
+/* Private data for this ethernet device */
+typedef struct {
+	struct net_device_stats stats; /* stats */
+	unsigned long last_rxidx;      /* last rx idx to descriptor */
+	unsigned long next_txidx;      /* next tx idx to descriptor */
+
+
+	spinlock_t lock;
+	/* MII transceiver section. */
+	struct mii_if_info mii_if;
+        /* Mode selection */
+        int autoneg_active;
+        int phy_loopback;	
+
+	/* Descriptors and buffers: notice the alignments */
+#ifdef STATIC_BUF_ALLOC 
+	struct em86xx_desc eth_rxdsc[NUM_RDESC] __attribute__ ((__aligned__(16)));
+	struct em86xx_desc eth_txdsc[NUM_TDESC] __attribute__ ((__aligned__(16)));
+	unsigned char eth_rxbuf[NUM_RDESC * R_BUF_SIZE] __attribute__ ((__aligned__(16)));
+	unsigned char eth_txbuf[NUM_TDESC * T_BUF_SIZE] __attribute__ ((__aligned__(16)));
+#else
+	struct em86xx_desc *eth_rxdsc;
+	struct em86xx_desc *eth_txdsc;
+	unsigned char *eth_rxbuf;
+	unsigned char *eth_txbuf;
+	unsigned long desc_page;
+	unsigned long rxbuf_pages;
+	unsigned long txbuf_pages;
+#ifndef BOOTLOADER
+	unsigned long rxbuf_order;
+	unsigned long txbuf_order;
+#endif
+#endif
+
+	/* Number of descriptors */
+	unsigned long num_rxdesc;
+	unsigned long num_txdesc;
+
+/* The real data pointer to be accessed in non-cache region */
+	volatile struct em86xx_desc *rxdsc;
+	volatile struct em86xx_desc *txdsc;
+	volatile unsigned char *rxbuf;
+	volatile unsigned char *txbuf;
+
+	/* Reference count for device */
+	int dev_count;
+
+	int reset_flag;
+	int phy_id;
+	int stop_thread;
+
+#ifndef BOOTLOADER
+#ifdef USE_KERNEL_TIMER 
+	struct timer_list eth_timer;
+#endif
+	struct sk_buff **rx_skb_list;
+	int need_restart_tx_queue; 
+#endif
+
+} EM86XX_ETH_PRIV;
+
+/* For storing MAC address */
+static unsigned long def_mac_hi = DEF_MAC_HI;
+static unsigned long def_mac_lo = DEF_MAC_LO;
+unsigned long num_rxdesc_param = NUM_RDESC;
+unsigned long num_txdesc_param = NUM_TDESC;
+
+/* Default PHY address: -1 for search */
+static int phy_address = -1;
+/* Default to 100BaseT/FD*/
+
+static int em86xx_eth_reset_desc(struct net_device *dev, int *reset);
+
+#ifdef BOOTLOADER
+static void em86xx_eth_intr_handler(int irq, void *dev_id);
+#else
+static struct net_device em86xx_eth_dev;
+static irqreturn_t em86xx_eth_intr_handler(int irq, void *dev_id);
+static int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
+
+MODULE_AUTHOR("Craig Qu");
+MODULE_DESCRIPTION("Sigma Designs ethernet driver");
+MODULE_LICENSE("GPL");
+MODULE_PARM_DESC(phy_address, "PHY address connecting to the MAC.");
+module_param(def_mac_hi, int, 0);
+module_param(def_mac_lo, int, 0);
+module_param(phy_address, int, 0);
+#ifndef STATIC_BUF_ALLOC 
+module_param(num_rxdesc_param, int, 0);
+module_param(num_txdesc_param, int, 0);
+#endif
+#endif /* BOOTLOADER */
+
+#define TX_ERRORS       12
+#define TX_ERRORS_START 1
+
+#define RX_ERRORS       31
+#define RX_ERRORS_START 1
+
+static const char *rx_error_msg[RX_ERRORS]= {
+	NULL,
+	"A CRC error is detected.",
+	NULL,
+	"A receive error was detected during frame reception.",
+	NULL,NULL,
+	"The frame has seen a collision after the collision window.",
+	"The frame is longer than 1518 bytes.",
+	NULL,NULL,NULL,
+	"The frame is prematurely terminated before the collision window.",	
+	"The actual length does not match with the Length Type field of the incoming frame.",
+	NULL,
+	"No more descriptors for receive frame.",
+	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
+	"The frame failed the address recognizing filtering.",
+};
+
+static const int rx_stat_offset[RX_ERRORS] = {
+	-1,
+	(int)&(((struct net_device_stats *)0)->rx_crc_errors),
+	-1,-1,-1,-1,
+	(int)&(((struct net_device_stats *)0)->collisions),
+	-1,-1,-1,-1,-1,
+	(int)&(((struct net_device_stats *)0)->rx_length_errors),
+	-1,
+	(int)&(((struct net_device_stats *)0)->rx_over_errors),
+	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+}; 
+
+static const char *tx_error_msg[TX_ERRORS]= {
+	NULL,
+	"Late data arrival from the memory.",
+	"Excessive deferral.",
+	NULL,NULL,NULL,NULL,
+	"Heartbeat collision check failure.",
+	"Transmission aborted after 16 collisions.",
+	"Transmission aborted due to collision.",
+	"No carrier signal from the tranceiver.",
+	"Loss of carrier during transmission.",	
+};
+
+static const int tx_stat_offset[TX_ERRORS] = {
+	-1,
+	(int)&(((struct net_device_stats *)0)->tx_aborted_errors),
+	(int)&(((struct net_device_stats *)0)->tx_aborted_errors),
+	-1,-1,-1,-1,
+	(int)&(((struct net_device_stats *)0)->tx_heartbeat_errors),
+	(int)&(((struct net_device_stats *)0)->collisions),
+	(int)&(((struct net_device_stats *)0)->collisions),
+	(int)&(((struct net_device_stats *)0)->tx_carrier_errors),
+	(int)&(((struct net_device_stats *)0)->tx_carrier_errors),
+}; 
+
+/* Helper routine */
+static void wait_ms (int ms)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	if (!in_interrupt()) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+	} else {
+		mdelay(ms);
+	}
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+
+/* MDIO access routines - used by MII standard Linux API */
+static int mdio_read (struct net_device *dev, int phy_addr, int reg_num)
+{
+	u32 addr;
+	u16 ret;
+	int count;
+	
+#ifdef DEBUG_MDIO
+	DBG_PRINT("%s: start addr %d reg %d\n", __func__, phy_addr, reg_num);
+#endif
+    /* Wait while the PHY is busy */
+	for (count = 1000; count != 0; count--) {
+		if (!(em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy))
+			break;
+	}
+	/* Set PHY & register to read */
+	addr = ((phy_addr & 0x1F) << 11) | ((reg_num & 0x1F) << 6);
+	em86xx_write_reg(EM86XX_MIIAR_REG, addr);
+	/* Work-around Sigma-Designs MAC bug */
+	udelay(40);
+	/* Wait while PHY is busy */
+	for (count = 1000; count != 0; count--) {
+		if (!(em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy))
+			break;
+	}
+	ret = em86xx_read_reg(EM86XX_MIIDR_REG) & 0xFFFF;
+#ifdef DEBUG_MDIO
+	DBG_PRINT(" => %04x\n", ret);
+#endif
+	
+	return ret;
+}
+
+static void mdio_write (struct net_device *dev,
+                        int phy_addr, int reg_num, int value)
+{
+	u32 addr;
+	int count;
+	
+#ifdef DEBUG_MDIO
+	DBG_PRINT("%s: start addr %d reg %d val %04x\n",
+	       __func__, phy_addr, reg_num, value);
+#endif
+	/* Wait while the PHY is busy */
+	for (count = 1000; count != 0; count--) {
+		if (!(em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy))
+			break;
+	}
+	/* Set PHY & register to write */
+	addr = ((phy_addr & 0x1F) << 11) | ((reg_num & 0x1F) << 6) | (1 << 1);
+	em86xx_write_reg(EM86XX_MIIDR_REG, value);
+	em86xx_write_reg(EM86XX_MIIAR_REG, addr);
+
+	while (em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy);
+
+}
+
+static int dump_ethtool_cmd(struct ethtool_cmd *ep)
+{
+
+        printk("       Speed: ");
+        switch (ep->speed) {
+        case SPEED_10:
+                printk("10Mb/s\n");
+                break;
+        case SPEED_100:
+                printk("100Mb/s\n");
+                break;
+        case SPEED_1000:
+                printk("1000Mb/s\n");
+                break;
+        default:
+                printk("Unknown! (%i)\n", ep->speed);
+                break;
+        };
+
+        printk("       Duplex: ");
+        switch (ep->duplex) {
+        case DUPLEX_HALF:
+                printk("Half\n");
+                break;
+        case DUPLEX_FULL:
+                printk("Full\n");
+                break;
+        default:
+                printk("Unknown! (%i)\n", ep->duplex);
+                break;
+        };
+
+        printk("       Auto-negotiation: %s\n",
+                (ep->autoneg == AUTONEG_DISABLE) ?
+                "off" : "on");
+        return 0;
+}
+
+
+
+/* Routine to configure the PHY */
+void setup_phy (struct mii_if_info *mii_if)
+{
+	struct net_device *dev = mii_if->dev;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	u16 phy_cntl, phy_caps, ad_caps, status;
+	int timeout;
+	struct ethtool_cmd cmd = { ETHTOOL_GSET };
+	
+	DBG_PRINT_INOUT_FUNC("START");
+	phy_cntl = mdio_read(dev, mii_if->phy_id, MII_BMCR);
+
+	/* Avoid multiple instances */
+	if (private->autoneg_active || !(phy_cntl & BMCR_ANENABLE) )
+		return;
+
+	private->autoneg_active = 1;
+	/* Reset the PHY */
+	phy_cntl = BMCR_RESET;
+	if (private->phy_loopback)
+		phy_cntl |= BMCR_LOOPBACK;
+	DBG_PRINT("%s: Reset PHY\n", __func__);
+	mdio_write(dev, mii_if->phy_id, MII_BMCR, phy_cntl);
+	/* Wait up to 5 seconds for the reset to complete */
+	for (timeout = 10; timeout != 0; timeout--) {
+		phy_cntl = mdio_read(dev, mii_if->phy_id, MII_BMCR);
+		if (!(phy_cntl & BMCR_RESET))
+			break;
+		/* Wait 500 milliseconds */
+		wait_ms(500);
+	}
+	if (timeout == 0) {
+		DBG_PRINT("PHY reset timeout\n");
+		goto out;
+	}
+	/* Read phy & advertising capabilities */
+	DBG_PRINT("%s: set up caps\n", __func__);
+	phy_caps = mdio_read(dev, mii_if->phy_id, MII_BMSR);
+	ad_caps = ADVERTISE_CSMA;
+	if (phy_caps & BMSR_100BASE4)
+		ad_caps |= ADVERTISE_100BASE4;
+	if (phy_caps & BMSR_100FULL)
+		ad_caps |= ADVERTISE_100FULL;
+	if (phy_caps & BMSR_100HALF)
+		ad_caps |= ADVERTISE_100HALF;
+	if (phy_caps & BMSR_10FULL)
+		ad_caps |= ADVERTISE_10FULL;
+	if (phy_caps & BMSR_10HALF)
+		ad_caps |= ADVERTISE_10HALF;
+
+	/* Update auto-negociation advertisement register */
+	mdio_write(dev, mii_if->phy_id, MII_ADVERTISE, ad_caps);
+	/* Read the register back. Some (buggy) PHY won't negociate properly
+	 * if this is not done.
+	 */
+	status = mdio_read(dev, mii_if->phy_id, MII_ADVERTISE);
+	timeout = 30;
+	/* Restart auto-negociation with our new advertisement capabilities */
+	DBG_PRINT("%s: start autonegociation\n", __func__);
+ restart_autoneg:
+	phy_cntl = BMCR_ANRESTART | BMCR_ANENABLE;
+	if (private->phy_loopback)
+		phy_cntl |= BMCR_LOOPBACK;
+	mdio_write(dev, mii_if->phy_id, MII_BMCR, phy_cntl);
+	/* Wait for the auto-negociation to complete.
+	 * This can take up to 3 seconds.
+	 */
+	for (; timeout != 0; timeout--) {
+		status = mdio_read(dev, mii_if->phy_id, MII_BMSR);
+		if (status & BMSR_ANEGCOMPLETE)
+			break;
+		if (status & BMSR_RFAULT) {
+            /* In case of remote fault, restart negociation */
+			DBG_PRINT("%s: restart autonegociation\n", __func__);
+			goto restart_autoneg;
+		}
+		wait_ms(100);
+	}
+	status = mdio_read(dev, mii_if->phy_id, MII_BMSR);
+	if (!(status & BMSR_ANEGCOMPLETE))
+		DBG_PRINT("Auto-negociation timeout\n");
+	else if (status & BMSR_RFAULT)
+		DBG_PRINT("Auto-negociation remote fault\n");
+	else
+		DBG_PRINT("Auto-negociation done\n");
+
+	netdev_get_settings(dev, &cmd);
+	dump_ethtool_cmd(&cmd);
+ out:
+	private->autoneg_active = 0;
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+/* PHY detection */
+/* XXX: to be moved into mii.c */
+int phy_detect (struct net_device *dev, struct mii_if_info *mii_if)
+{
+	int phy_n;
+	int mii_status, phy_id1, phy_id2;
+	
+	DBG_PRINT_INOUT_FUNC("START");
+	mii_if->dev = dev;
+	mii_if->mdio_read = mdio_read;
+	mii_if->mdio_write = mdio_write;
+	mii_if->phy_id_mask = 0x1f;
+	mii_if->reg_num_mask = 0x1f;
+	mii_if->phy_id = -1; /* No PHY found */
+	for (phy_n = 0; phy_n < 32; phy_n++) {
+		DBG_PRINT("%s: check PHY %d\n", __func__, phy_n);
+		mii_status = mdio_read(dev, phy_n, MII_BMSR);
+		phy_id1 = mdio_read(dev, phy_n, MII_PHYSID1);
+		phy_id2 = mdio_read(dev, phy_n, MII_PHYSID2);
+		/* PHY_ID1 is zero in some realtek PHYs */
+		if (/*phy_id1 > 0 &&*/ phy_id1 < 0xFFFF && phy_id1 != 0x8000 &&
+		    phy_id2 > 0 && phy_id2 < 0xFFFF && phy_id2 != 0x8000 &&
+		    mii_status != 0xffff && mii_status != 0x0000) {
+			mii_if->advertising = mdio_read(dev, phy_n, 4);
+			mii_if->phy_id = phy_n;
+			DBG_PRINT(KERN_INFO "%s: MII PHY found at address %d, status "
+			       "0x%4.4x advertising %4.4x Link %4.4x.\n",
+			       dev->name, phy_n, mii_status, mii_if->advertising,
+			       mdio_read(dev, phy_n, 5));
+			/* set IFF_RUNNING */
+			if (mii_status & BMSR_LSTATUS) {
+				DBG_PRINT("%s: netif_carrier_on\n", __func__);
+				netif_carrier_on(dev);
+			}
+			else {
+				DBG_PRINT("%s: netif_carrier_off\n", __func__);
+				netif_carrier_off(dev);
+			}
+			break;
+		}
+	}
+	if (phy_n == 32) {
+		DBG_PRINT("failed to detect PHY\n");
+		return -1;
+	}
+	
+	DBG_PRINT_INOUT_FUNC("END");
+	return phy_n;
+}
+
+/* Getting MAC address from local RAM */
+static int get_mac_address(unsigned long *mac_lo, unsigned long *mac_hi)
+{
+	unsigned long cksum, lo, hi;
+	const unsigned char marker = 'M';
+	
+	DBG_PRINT_INOUT_FUNC("START");
+	lo = em86xx_read_reg(REG_BASE_cpu_block + LR_ETH_MAC_LO);
+	hi = em86xx_read_reg(REG_BASE_cpu_block + LR_ETH_MAC_HI);
+
+	if (((unsigned char)((hi >> 16) & 0xff)) != marker)
+		return(1); /* Not valid MAC */
+	cksum = ((lo & 0xff) + ((lo >> 8) & 0xff) + ((lo >> 16) & 0xff) + ((lo >> 24) & 0xff) + 
+		 (hi & 0xff) + ((hi >> 8) & 0xff)) & 0xff;
+	if (((hi >> 24) & 0xff) != cksum)
+		return(1); /* Not valid MAC */
+	*mac_lo = lo;
+	*mac_hi = hi & 0xffff;
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return(0); /* Got valid MAC */
+}
+
+/* Get the device mac address */
+static int em86xx_get_macaddr(unsigned char *addr)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+#if defined(CONFIG_TANGOX)
+	unsigned long hi, lo;
+	if (get_mac_address(&lo, &hi) == 0) {
+		*addr++ = (hi & 0x0000ff00) >> 8;
+		*addr++ = (hi & 0x000000ff);
+		*addr++ = (lo & 0xff000000) >> 24;
+		*addr++ = (lo & 0x00ff0000) >> 16;
+		*addr++ = (lo & 0x0000ff00) >> 8;
+		*addr   = (lo & 0x000000ff);
+	} else if (tangox_ethernet_getmac(0, addr) == 0) {
+		*addr++ = (def_mac_hi & 0x0000ff00) >> 8;
+		*addr++ = (def_mac_hi & 0x000000ff);
+		*addr++ = (def_mac_lo & 0xff000000) >> 24;
+		*addr++ = (def_mac_lo & 0x00ff0000) >> 16;
+		*addr++ = (def_mac_lo & 0x0000ff00) >> 8;
+		*addr   = (def_mac_lo & 0x000000ff);
+	}
+#else
+#ifdef BOOTLOADER
+	if(	mac_read(addr) == -1) {
+		*addr++ = (def_mac_hi & 0x0000ff00) >> 8;
+		*addr++ = (def_mac_hi & 0x000000ff);
+		*addr++ = (def_mac_lo & 0xff000000) >> 24;
+		*addr++ = (def_mac_lo & 0x00ff0000) >> 16;
+		*addr++ = (def_mac_lo & 0x0000ff00) >> 8;
+		*addr   = (def_mac_lo & 0x000000ff);
+	}
+#else
+#ifdef CONFIG_SD_BOOTLOADER_INTEGRATION
+	{
+		unsigned long lo, hi;
+
+		if (get_mac_address(&lo, &hi) == 0) {
+			def_mac_hi = hi;
+			def_mac_lo = lo;
+		}
+	}
+#endif
+	*addr++ = (def_mac_hi & 0x0000ff00) >> 8;
+	*addr++ = (def_mac_hi & 0x000000ff);
+	*addr++ = (def_mac_lo & 0xff000000) >> 24;
+	*addr++ = (def_mac_lo & 0x00ff0000) >> 16;
+	*addr++ = (def_mac_lo & 0x0000ff00) >> 8;
+	*addr   = (def_mac_lo & 0x000000ff);
+#endif /* BOOTLOADER */	
+#endif /* CONFIG_TANGOX */
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Setting up MAC address of ethernet PHY and device data */
+static int em86xx_set_mac(struct net_device *dev)
+{
+	unsigned long hi_mac, low_mac;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Set up device mac address */
+	if (em86xx_get_macaddr(dev->dev_addr))
+		return(-EIO);
+
+	if (!is_valid_ether_addr(dev->dev_addr))
+		MSG_PRINT("%s: bogus mac address detected.\n", dev->name);
+
+	hi_mac =  (dev->dev_addr[5] << 8)  | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24) | (dev->dev_addr[2] << 16) | 
+		  (dev->dev_addr[1] << 8)  | dev->dev_addr[0];
+
+	/* Set up MAC address */
+	em86xx_write_reg(EM86XX_MACAHR_REG, hi_mac);
+	em86xx_write_reg(EM86XX_MACALR_REG, low_mac);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+#ifndef BOOTLOADER
+/* Setting customized mac address */
+static int em86xx_eth_set_macaddr(struct net_device *dev, void *addr)
+{
+	unsigned long hi_mac, low_mac;
+	struct sockaddr *sock = addr;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Check if given address is valid ethernet MAC address */
+	if (!is_valid_ether_addr(sock->sa_data))
+		return(-EIO);
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+	netif_carrier_off(dev); /* Shutdown interface */
+
+	/* Save the customize mac address */
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+	hi_mac  = (dev->dev_addr[5] << 8) | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24)| (dev->dev_addr[2] << 16) | 
+		  (dev->dev_addr[1] << 8) | dev->dev_addr[0];
+
+	def_mac_hi = hi_mac;
+	def_mac_lo = low_mac;
+
+	/* Set up MAC address */
+	em86xx_write_reg(EM86XX_MACAHR_REG, hi_mac );
+	em86xx_write_reg(EM86XX_MACALR_REG, low_mac );
+
+	netif_carrier_on(dev);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+#endif /* BOOTLOADER */
+
+/* RTL8201BL is a single-port PHY with an MII/SNI. The MAC layer device can 
+   control a maximum of 31 devices, configured with different PHY addresses
+   (00001b to 11111b). We need to find out which PHY address is using in 
+   order to obtain the mode status after the auto-neotiation is completed.
+
+   There is a module parameter phy_address to be used to override this probe,
+   to set PHY address if one already knew it.
+*/
+static int em86xx_phy_probe(void)
+{
+
+        int phy_addr 	= 0;
+	u16 phy_id 	= 0;
+        u16 phy_status 	= 0;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	if (phy_address < 0) {
+		/* search for total of 31 possible mii phy addresses */
+		for (phy_addr = 1; phy_addr < 32; phy_addr++) {
+			phy_status = em86xx_mii_read(phy_addr,GEN_sts);
+
+			if (phy_status != 0xffff && phy_status != 0x0000)
+				break;
+		}
+	} else {
+		phy_addr = phy_address;
+		phy_status = em86xx_mii_read(phy_addr,GEN_sts);
+	}
+	phy_id =  em86xx_mii_read(phy_addr,GEN_id_lo);
+	MSG_PRINT("Found PHY %04x at Addr = %d Status=0x%x\n", phy_id, phy_addr, phy_status);
+ 
+	DBG_PRINT_INOUT_FUNC("END");
+	return phy_addr;
+}
+
+/* Initialize the ethernet link status, mac, and flow control */
+static int em86xx_link_config(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	struct mii_if_info *mii = &(private->mii_if);
+	unsigned long word = 0;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	// Turn off IRQ and stop receive/transmit 
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+	setup_phy(mii);
+
+	/* set the descriptor base address */
+	em86xx_write_reg(EM86XX_RLBAR_REG, PHYSADDR((u32)private->rxdsc) );
+	em86xx_write_reg(EM86XX_TLBAR_REG, PHYSADDR((u32)private->txdsc));
+
+	/* set bus mode: burst length = 32 | BLE | ~DBO */
+	word = (32 << 8) /*| (1 << 7) | (1 << 20)*/ ;
+	em86xx_write_reg(EM86XX_BMR_REG, word); 
+
+	/* enable MAC flow ctrl */
+	word = (1 << 1);
+	em86xx_write_reg(EM86XX_FCR_REG, word); 
+
+	/* configure MAC ctrller */
+	word = ETH_MAC_FLAGS;
+	word |= MacLoopbackOff; 
+        if (mii->full_duplex)
+                word |= MacFullDuplex;
+        else
+                word &= ~MacFullDuplex;
+	em86xx_write_reg(EM86XX_MACCR_REG, word);
+
+	/* Turn on the IRQ and start receive/transmit */
+	em86xx_write_reg(EM86XX_IER_REG, ETH_IRQ_FLAGS);
+	em86xx_write_reg(EM86XX_CR_REG, ETH_RXTX_FLAGS); 
+
+	netif_carrier_on(dev);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Ethernet hardware initialization */
+static int em86xx_eth_hw_init(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	int rc;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+	/* reset dma engine*/
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOn);
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOff);
+
+	if (em86xx_set_mac(dev))
+		return(-EIO);
+
+	/* stop MAC engine */
+	em86xx_write_reg(EM86XX_CR_REG, 0x0); 
+#ifndef USE_HW_FILTERING
+	/* set up multicast hash table to MCHTHR MCHTLR */
+	/* set multicast hash table to accept all */
+	em86xx_write_reg(EM86XX_MCHTHR_REG, 0xffffffff); 
+	em86xx_write_reg(EM86XX_MCHTLR_REG, 0xffffffff); 
+#else
+	/* clear hash table */
+        em86xx_write_reg( EM86XX_MCHTHR_REG, 0 );
+        em86xx_write_reg( EM86XX_MCHTLR_REG, 0 );
+
+	em86xx_eth_set_multicast_list(dev);
+#endif
+
+	/* resetting descriptors */
+#ifdef BOOTLOADER
+        if (em86xx_eth_reset_desc(dev, &private->reset_flag))
+#else
+        if (em86xx_eth_reset_desc(&em86xx_eth_dev, &private->reset_flag))
+#endif
+		return(-EIO);
+
+	/* configure PHY and speed */
+	rc = em86xx_link_config(dev);
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+#ifndef BOOTLOADER
+/* Monitor the status of link, re-do link initialization if necessary. */
+#ifdef USE_KERNEL_TIMER
+static void em86xx_eth_link_monitor(unsigned long dummy)
+#else
+static int em86xx_eth_link_monitor(void *dummy)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dummy;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+        int link;
+	int res;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+#ifndef USE_KERNEL_TIMER
+	daemonize("em86xx_eth");
+
+	while (private->stop_thread == 0) {
+#endif
+		spin_lock_irqsave(&private->lock, flags);
+		link = mii_link_ok(&private->mii_if);
+		spin_unlock_irqrestore(&private->lock, flags);
+		
+		if (netif_carrier_ok(dev) && !link) {			
+			MSG_PRINT("%s: detected link DOWN.\n", dev->name);
+			netif_carrier_off(dev);
+		}
+		else if (!netif_carrier_ok(dev) && link) {
+			MSG_PRINT("%s: detected link UP.\n", dev->name);
+			res = em86xx_eth_hw_init(dev);
+			netif_carrier_on(dev);
+		}
+
+#ifndef USE_KERNEL_TIMER
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ);
+	}
+#endif
+
+#ifdef USE_KERNEL_TIMER
+	/* Schedule for the next time */
+	mod_timer(&private->eth_timer, jiffies + HZ); 
+	DBG_PRINT_INOUT_FUNC("END (with timer)");
+#else
+	DBG_PRINT_INOUT_FUNC("END (IRQ)");
+	return(0);
+#endif
+}
+#endif
+
+/* Setting rx/tx descriptors */
+static void em86xx_eth_setup_desc(struct net_device *dev)
+{
+	register int i;
+	struct em86xx_desc *desc_ptr = NULL;
+	unsigned long base_addr = 0;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Setup rx descriptor */
+	desc_ptr = (struct em86xx_desc *)(private->rxdsc);
+	for (i = 0; i < (private->num_rxdesc - 1); i++, desc_ptr++) {
+		desc_ptr->desc3 = PHYSADDR((unsigned long)(desc_ptr + 1));
+		desc_ptr->desc1 = (DescChain | R_BUF_SIZE);
+  		desc_ptr->desc0 = DescOwnByDma; 
+	}
+	desc_ptr->desc3 = PHYSADDR((unsigned long)(private->rxdsc));
+	desc_ptr->desc1 = (DescChain | DescEndOfRing | R_BUF_SIZE);
+	desc_ptr->desc0 = DescOwnByDma; 
+
+	/* Setup tx descriptor */
+	desc_ptr = (struct em86xx_desc *)(private->txdsc); 
+	for (i =0;  i < (private->num_txdesc - 1); i++, desc_ptr++) {
+		desc_ptr->desc3 = PHYSADDR((unsigned long)(desc_ptr + 1));
+		desc_ptr->desc1 = (TX_DESC1_FLAGS | T_BUF_SIZE);
+  		desc_ptr->desc0 = DescOwnByCPU;
+	}
+	desc_ptr->desc3 = PHYSADDR((unsigned long)(private->txdsc));
+	desc_ptr->desc1 = (TX_DESC1_FLAGS | DescEndOfRing | T_BUF_SIZE);
+	desc_ptr->desc0 = DescOwnByCPU;
+
+	/* Point rx descriptor to buffer */
+	desc_ptr = (struct em86xx_desc *)(private->rxdsc);
+#ifdef BOOTLOADER 
+      	base_addr = PHYSADDR((unsigned long)(private->rxbuf)); 
+	for (i = 0; i < private->num_rxdesc; i++, desc_ptr++, base_addr += R_BUF_SIZE) 
+		desc_ptr->desc2 = base_addr;
+#else
+        for (i = 0; i < private->num_rxdesc; i++, desc_ptr++){
+                private->rx_skb_list[i] = dev_alloc_skb(R_BUF_SIZE);
+                skb_reserve(private->rx_skb_list[i], 2);
+                desc_ptr->desc2 = PHYSADDR((u32)private->rx_skb_list[i]->data);
+#ifdef CONFIG_NONCOHERENT_IO
+		dma_cache_inv((u32)private->rx_skb_list[i]->data, R_BUF_SIZE);
+#endif
+        }
+#endif
+
+	/* Point tx descriptor to buffer */
+	desc_ptr = (struct em86xx_desc *)(private->txdsc);
+        base_addr = PHYSADDR((unsigned long)(private->txbuf));
+	for (i = 0; i < private->num_txdesc; i++, desc_ptr++, base_addr += T_BUF_SIZE) 
+		desc_ptr->desc2 = base_addr;
+
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+/* Starting up the ethernet device */
+static int em86xx_eth_open(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	DBG_PRINT_INOUT_FUNC("END");
+	if ((dev == NULL) || (private == NULL))
+		return(-EIO);
+	DBG_PRINT("%s: starting interface.\n", dev->name);
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+	/*Get phy address*/
+	private->phy_id = em86xx_phy_probe();
+	em86xx_eth_hw_init(dev);
+
+#ifdef BOOTLOADER
+        dev->state = NETDEV_UP;
+#else
+#ifdef USE_KERNEL_TIMER 
+	/* Schedule timer for monitoring link status */
+	init_timer(&private->eth_timer);
+	private->eth_timer.function = em86xx_eth_link_monitor;
+	private->eth_timer.data = (unsigned long)dev;
+	mod_timer(&private->eth_timer, jiffies + HZ/10);
+#else
+	private->stop_thread = 0;
+	if (kernel_thread(em86xx_eth_link_monitor, dev, CLONE_FS|CLONE_FILES) < 0)
+		return(-ENODEV);
+#endif
+	netif_start_queue(dev);
+#endif /*BOOTLOADER*/
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Stopping the ethernet device */
+static int em86xx_eth_close(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	if (dev == NULL) {
+		DBG_PRINT_INOUT_FUNC("END");
+  		return(-EIO);
+	}
+
+	private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+#ifdef BOOTLOADER
+	dev->state = NETDEV_DOWN;
+#else
+
+#ifdef USE_KERNEL_TIMER
+	/* Kill timer */
+	del_timer_sync(&private->eth_timer);
+#else
+	private->stop_thread = 1;
+	schedule_timeout(5*HZ); /* Wait for kernel thread to terminate */
+#endif
+
+	/* Stop the transmit queue */
+	netif_stop_queue(dev);
+	netif_carrier_off(dev);
+
+#endif /*BOOTLOADER*/
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+#ifndef BOOTLOADER
+#ifdef USE_HW_FILTERING
+/* Setup multicast list */
+static void em86xx_eth_set_multicast_list(struct net_device *dev)
+{
+	/* Multicast hash filter */
+        u32 mc_filter[2] = { 0, 0 };
+        int i, rx_mode;
+ 	u8  broadcast_addr[6]  = DEFAULT_BROADCAST_ADDRESS;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	rx_mode =  em86xx_read_reg(EM86XX_MACCR_REG);  
+        DBG_PRINT(KERN_DEBUG"%s:   set_rx_mode(0x%x) done -- rx_mode=0x%x.\n",
+                           dev->name, dev->flags, rx_mode);
+
+        if (dev->flags & IFF_PROMISC) {
+                MSG_PRINT("%s: Promiscuous mode enabled.\n", dev->name);
+                rx_mode |= MacPromiscuousModeOn;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else {
+                struct dev_mc_list *mclist;
+		int n;
+                rx_mode &=  ~MacPromiscuousModeOn;
+                for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+                         i++, mclist = mclist->next){
+			n = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			mc_filter[n >> 5] |= 1 << (n & 31);
+		}
+		n = ether_crc(ETH_ALEN, broadcast_addr) >> 26;
+		mc_filter[n >> 5] |= 1 << (n & 31);
+        }
+	em86xx_write_reg(EM86XX_MACCR_REG, rx_mode );
+        em86xx_write_reg(EM86XX_MCHTLR_REG, mc_filter[0]);
+        em86xx_write_reg(EM86XX_MCHTHR_REG, mc_filter[1]);
+
+	DBG_PRINT_INOUT_FUNC("END");
+        return;
+}
+#endif
+#endif
+
+/* Transmit a packet */
+#ifdef BOOTLOADER
+static int em86xx_eth_tx(struct sk_buff *skb, struct net_device *dev, int async)
+#else
+static int em86xx_eth_tx(struct sk_buff *skb, struct net_device *dev)
+#endif
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	volatile struct em86xx_desc *desc_ptr;
+	struct net_device_stats *stats;
+	unsigned long length, err;
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&private->lock, flags);
+
+	if ((length = ((ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN)) > T_BUF_SIZE) {
+      		DBG_PRINT("em86xx_eth_tx: too big\n");
+		ret = -ENOMEM; 
+		goto out_unlock;
+	}
+
+	stats = &(private->stats);
+
+	/* Send packet to device */
+	desc_ptr = (volatile struct em86xx_desc *)(&private->txdsc[private->next_txidx]);
+	if ((desc_ptr->desc0 & DescOwnByDma) != 0) {
+		stats->tx_dropped++;
+		
+		/* cannot queue anymore */
+		netif_stop_queue(dev);
+		private->need_restart_tx_queue = 1;
+
+        	ERR_PRINT("%s desc_ptr=0x%x: tx error (descriptor not owned by CPU).\n",
+				 dev->name, (u32)desc_ptr);
+		ret = -EIO;
+		goto out_unlock;
+	} 
+
+	/* Check if previous transmission has error */
+	if ((err = (desc_ptr->desc0 & TX_ERROR_FLAGS)) != 0) {
+		int i;
+		ERR_PRINT("%s: got a tx error:0x%08lx\n", dev->name, desc_ptr->desc0);
+		for (i = TX_ERRORS_START; (i < TX_ERRORS) && (err != 0); i++) {
+			int *ptr;
+			if (err & (1 << i)) {
+				err &= ~(1<<i);
+				if (tx_error_msg[i] != NULL)
+					ERR_PRINT("%s\n",tx_error_msg[i]);
+				if (tx_stat_offset[i] >= 0) {
+					ptr = (int *)(((char *)stats) + tx_stat_offset[i]);
+					*ptr++;
+				}
+			}
+		}
+
+		/* Update stats */
+ 		stats->collisions += (desc_ptr->desc0 >> 3) & 15;
+		stats->tx_errors++;
+		stats->tx_packets--;
+		stats->tx_bytes -= (desc_ptr->desc1 & DescSize1Mask);
+	}
+
+	/* Copy packet data to tx buffer */
+//	DBG_PRINT("tx copy data from skb->data=0x%x to desc2=0x%x length=0x%x\n",
+//		(u32)skb->data, (u32)desc_ptr->desc2, (u32)length );
+
+	memcpy((void *)NON_CACHED(desc_ptr->desc2), skb->data, length);
+
+	/* Setup tx descriptor */
+	desc_ptr->desc1 = ( TX_DESC1_FLAGS | length );
+	if (private->next_txidx == (private->num_txdesc - 1))
+		desc_ptr->desc1 |=  DescEndOfRing ;
+	desc_ptr->desc0 |= DescOwnByDma;
+
+	/* Start transmission (should be in suspend mode already) */
+	em86xx_write_reg(EM86XX_TPDR_REG, 0x1);
+
+#ifdef BOOTLOADER
+        private->next_txidx = imodulus((private->next_txidx + 1), private->num_txdesc);
+#else
+	private->next_txidx = ((private->next_txidx + 1) % private->num_txdesc);
+	dev->trans_start = jiffies;
+#endif
+	/* Update stats */
+	stats->tx_packets++;
+	stats->tx_bytes += length;
+
+	/* Check to see if TX queue is full */
+	desc_ptr = (volatile struct em86xx_desc *)(&private->txdsc[private->next_txidx]);
+	if ((desc_ptr->desc0 & DescOwnByDma) != 0) {
+		/* cannot queue anymore */
+		netif_stop_queue(dev);
+		private->need_restart_tx_queue = 1;
+	} 
+
+	/* Free up socket buffer */
+#ifdef BOOTLOADER
+	async = 0;
+	skb_free(skb);
+#else
+	dev_kfree_skb(skb);
+#endif
+ out_unlock:
+	spin_unlock_irqrestore(&private->lock, flags);
+	return ret;
+}
+
+
+static inline int is_sw_filtered_packet(struct net_device *dev, unsigned char *data)
+{
+#ifdef USE_SW_FILTERING
+        if (((data[0] & 0x80) == 0) && (dev->dev_addr[5] != data[5])) {
+                return 1;
+	}
+        else {
+                return 0;
+	}
+#else
+        return 0;
+#endif
+}
+
+
+/* Receiving packet(s) */
+static int em86xx_eth_rx(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private;
+#ifdef BOOTLOADER
+	struct sk_buff *skb;
+#endif
+	struct net_device_stats *stats;
+	unsigned char *data;
+	volatile struct em86xx_desc *desc_ptr;
+	unsigned long length;
+	unsigned long dsc;
+	unsigned long count=0, cnt= 0, err;
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+	volatile struct em86xx_desc *mdf_desc_ptr;
+	long mdf_start = -1;
+#endif
+//	unsigned long flags;
+
+  	private = (EM86XX_ETH_PRIV *)dev->priv;
+  	stats = &(private->stats);
+
+	/* Go thru descriptors list until we ran out or encounterred
+	   the one being processed by DMA */
+#ifdef BOOTLOADER 
+	for (cnt = 0, count = private->last_rxidx; cnt < private->num_rxdesc; cnt++, count = imodulus(count + 1, private->num_rxdesc)) {
+#else
+	for (cnt = 0, count = private->last_rxidx; cnt < private->num_rxdesc; cnt++, count = ((count + 1) % private->num_rxdesc)) {
+#endif
+
+		desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[count]);
+	 	dsc = desc_ptr->desc0;
+
+	  	if ((dsc & DescOwnByDma) != 0) {
+    			/* DMA is processing this one, break out the loop */
+			break;
+    		}
+
+		/*filter out those are not for me */
+      		data = (unsigned char *)NON_CACHED(desc_ptr->desc2);
+		if (is_sw_filtered_packet(dev, data)
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+		    && (mdf_start < 0)
+#endif
+				) {
+			ERR_PRINT("%s: mac mismatched, dropped.\n", dev->name);
+		} else	if ((err = (dsc & RX_ERROR_FLAGS)) != 0)  {
+			int i;
+
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+			 /* First check are we in MDF mode */
+			 if (mdf_start >= 0) { /* Yes, we are */
+				 MSG_PRINT("%s: rx error in MDF mode (s:0x%x,c:0x%x)\n", dev->name, mdf_start, count);
+				 /* Something is wrong, drop all MDF related descriptors */
+				 for (i = mdf_start; i != count; i = (i + 1) % private->num_rxdesc) {
+					 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+					 mdf_desc_ptr->desc0 = DescOwnByDma;
+					 wmb();
+				 }
+				 mdf_start = -1; /* Reset so we're out of this mode */
+			 }
+#endif
+			/*Filtering fail is valid only when Last desc bit is set, 
+			  length is 64 bytes or longer and Receive All bit is set. */
+			if (dsc & DescFilteringFail) {		
+				unsigned long len, rx_mode;
+				len = (dsc & DescFrameLengthMask) >> DescFrameLengthShift;
+				rx_mode = em86xx_read_reg(EM86XX_MACCR_REG);
+				if(!((dsc & DescRxLast) && (len >= 64) && (rx_mode & MacFilterOff)))
+					goto sync_up;
+			}
+
+      			ERR_PRINT("%s: rx error 0x%08lx:%ld desc2=0x%08x\n", 
+				dev->name, dsc, count, (u32)desc_ptr->desc2);
+
+			for (i = RX_ERRORS_START; (i < RX_ERRORS) && (err != 0); i++) {
+				int *ptr;
+				if (err & (1 << i)) {
+					err &= ~(1<<i);
+					if (rx_error_msg[i] != NULL)
+						ERR_PRINT("%s\n", rx_error_msg[i]);
+					if (rx_stat_offset[i] >= 0) {
+						ptr = (int *)(((char *)stats) + rx_stat_offset[i]);
+						*ptr++;
+					}
+				}
+			}
+
+			/* We dropped any error descriptor */
+		        stats->rx_errors++;
+		 } else if ((dsc & MD_FRAME_FLAGS) != MD_FRAME_FLAGS) {
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+			 /* We encounterred multi-descriptor frame */
+			 if (((dsc & DescRxFirst) != 0) && ((dsc & DescRxLast) == 0)) {
+				 /* First descriptor of multi-descriptor frame */
+				 if (mdf_start >= 0) { 
+					 int i;
+					 MSG_PRINT("%s: MDF mode error at beginning (s:0x%x,c:0x%x)\n", dev->name, mdf_start, count);
+					 /* Something is wrong, drop all MDF related descriptors */
+					 for (i = mdf_start; i != count; i = (i + 1) % private->num_rxdesc) {
+						 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+						 mdf_desc_ptr->desc0 = DescOwnByDma;
+						 wmb();
+					 }
+				 }
+				 mdf_start = (long)count;
+				 continue; /* Loop until we can get the whole frame */
+			 } else if ((dsc & MD_FRAME_FLAGS) == 0) {
+				 if (mdf_start >= 0) {
+					 /* Interim descriptor within multi-descriptor frame */
+					 continue; /* Loop until we can get the whole frame */
+				 } else {
+					 MSG_PRINT("%s: MDF mode error (c:0x%x)\n", dev->name, count);
+					 /* Bogus: drop it */
+					 goto sync_up;
+				 }
+			 } else {
+				 /* Last descriptor of multi-descriptor frame */
+				 unsigned long mdf_size, length;
+				 long i, mdf_end;
+				 char *ptr, *mdf_data;
+				 struct sk_buff *mdf_skb;
+
+				 if (mdf_start < 0) {
+					 MSG_PRINT("%s: MDF mode error at the end (c:0x%x)\n", dev->name, count);
+					 /* Bogus: drop it */
+					 goto sync_up;
+				 }
+
+				 /* First we get the size of the frame, and allocate a new skb */
+				 length = mdf_size = (dsc & DescFrameLengthMask) >> DescFrameLengthShift;
+				 mdf_end = (count + 1) % private->num_rxdesc;
+#ifdef BOOTLOADER
+				 mdf_skb = skb_alloc(mdf_size);
+#else
+				 mdf_skb = dev_alloc_skb(mdf_size);
+#endif
+				 if (mdf_skb == NULL) {
+					 /* Error: no memory available, dropping all descriptors in this frame */
+					 stats->rx_dropped += (((mdf_start + private->num_rxdesc) - mdf_end) % private->num_rxdesc);
+					 for (i = mdf_start; i != mdf_end; i = (i + 1) % private->num_rxdesc) {
+						 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+						 mdf_desc_ptr->desc0 = DescOwnByDma;
+						 wmb();
+					 }
+				 } else {
+#ifndef BOOTLOADER
+					 skb_reserve(mdf_skb, 2);
+#endif
+					 stats->rx_bytes += mdf_size;
+					 stats->rx_packets += (((mdf_start + private->num_rxdesc) - mdf_end) % private->num_rxdesc);
+
+					 /* Collecting all descriptors into skb  */
+					 for (ptr = mdf_skb->data, i = mdf_start; i != mdf_end; i = (i + 1) % private->num_rxdesc) {
+						 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+						 mdf_data = (unsigned char *)NON_CACHED(mdf_desc_ptr->desc2);
+						 memcpy(ptr, mdf_data, (length > R_BUF_SIZE) ? R_BUF_SIZE : length);
+						 ptr += R_BUF_SIZE;
+						 length -= R_BUF_SIZE;
+						 mdf_desc_ptr->desc0 = DescOwnByDma;
+						 wmb();
+					 }
+					 mdf_skb->dev = dev;
+					 mdf_skb->len = mdf_size - 4;
+
+					 /* Send the frame back up */
+#ifdef BOOTLOADER
+					 skb_put(mdf_skb);
+#else
+					 mdf_skb->protocol = eth_type_trans(mdf_skb, dev);
+					 mdf_skb->ip_summed = CHECKSUM_NONE;
+					 dev->last_rx = jiffies;
+					 netif_rx(mdf_skb);
+#endif
+				 }
+				 mdf_start = -1;
+				 continue; /* No need go to the end of the loop */
+			}
+#else
+			/* We encounterred multi-descriptor frame */
+	        	DBG_PRINT("%s: multi-descriptor frame detected 0x%08lx\n", dev->name, dsc);
+		        /* Don't handle multi-descriptor frame */
+		        stats->rx_dropped++;
+#endif /* MULTI_DESCS_FRAME_SUPPORT */
+		 } else if ((length = ((dsc & DescFrameLengthMask) >> DescFrameLengthShift)) > R_BUF_SIZE) {
+			/* Should not happen for single-descriptor frame */
+      			ERR_PRINT("%s: rx dropped (size too large: %ld)\n", dev->name, length);
+			stats->rx_length_errors++;	
+			stats->rx_dropped++;
+#ifdef BOOTLOADER
+                 } else if ((skb = skb_alloc(length)) == NULL) {
+			ERR_PRINT("%s: rx dropped (memory unavailable)\n", dev->name);
+	        	stats->rx_dropped++;
+#endif
+		 } else {
+			 /* We got single descriptor frame */
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+			 /* First check are we in MDF mode */
+			 if (mdf_start >= 0) { /* Yes, we are */
+				 int i;
+				 /* Something is wrong, drop all MDF related descriptors */
+				 for (i = mdf_start; i != count; i = (i + 1) % private->num_rxdesc) {
+					 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+					 mdf_desc_ptr->desc0 = DescOwnByDma;
+				 }
+				 mdf_start = -1; /* Reset so we're out of this mode */
+			 }
+#endif
+#ifdef BOOTLOADER
+		  	 skb->dev = dev;
+                         skb->len = length - 4;
+                         memcpy(skb->data, data, length-4);
+                         skb_put(skb);
+
+                         /* Update stats */
+                         stats->rx_packets++;
+                         stats->rx_bytes += length;
+#else
+                         private->rx_skb_list[count]->dev = dev;
+                         private->rx_skb_list[count]->len = length-4;
+                         private->rx_skb_list[count]->protocol = eth_type_trans(private->rx_skb_list[count], dev);
+                         private->rx_skb_list[count]->ip_summed = CHECKSUM_NONE;
+
+                         /* Send the packet to kernel */
+                         netif_rx(private->rx_skb_list[count]);
+
+	        	 /* Update stats */
+		       	 stats->rx_packets++;
+		         stats->rx_bytes += length;
+		       	 dev->last_rx = jiffies;
+#endif /*BOOTLOADER*/
+  	 	}
+#ifndef BOOTLOADER
+                private->rx_skb_list[count] = dev_alloc_skb(R_BUF_SIZE);
+                skb_reserve(private->rx_skb_list[count], 2);
+                desc_ptr->desc2 = PHYSADDR((u32)private->rx_skb_list[count]->data);
+#ifdef CONFIG_NONCOHERENT_IO
+		dma_cache_inv((u32)private->rx_skb_list[count]->data, R_BUF_SIZE);
+#endif
+#endif
+
+sync_up:
+  		desc_ptr->desc0 = DescOwnByDma;
+		wmb();
+  	}
+
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+	/* This is the last desc we read */
+	if (mdf_start >= 0)
+		/* We haven't reached the end of multi-descriptor frame, mark it here
+		 * so we can come back and pick it up again */
+		private->last_rxidx = mdf_start; 
+	else
+		private->last_rxidx = count; 
+#else
+	/* This is the last desc we read */
+	private->last_rxidx = count; 
+#endif
+	/* make sure rx is not suspended */
+	em86xx_write_reg(EM86XX_RPDR_REG, 0x1);
+  	return cnt;
+}
+
+/* Resetting rx descriptor: error recovery for "rx buf unavailable" */
+static void em86xx_eth_reset_rx_buf(struct net_device *dev)
+{
+	register int i;
+	volatile struct em86xx_desc *desc_ptr = NULL;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	em86xx_clear_reg(EM86XX_CR_REG, DmaRxStart); 
+
+	/* Reset rx desc */
+	desc_ptr = (struct em86xx_desc *)(private->rxdsc); 
+	for (i = 0; i < private->num_rxdesc; i++, desc_ptr++) 
+		desc_ptr->desc0 = DescOwnByDma; 
+  	
+  	em86xx_write_reg(EM86XX_RPDR_REG,  0x1);
+	em86xx_set_reg(EM86XX_CR_REG, DmaRxStart); 
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+#ifndef BOOTLOADER
+/* Get the stats information */
+static struct net_device_stats *em86xx_eth_stats(struct net_device *dev)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	if (dev != NULL) {
+		DBG_PRINT_INOUT_FUNC("END");
+    		return(&(((EM86XX_ETH_PRIV *)dev->priv)->stats));
+	}
+  	else {
+		DBG_PRINT_INOUT_FUNC("END");
+    		return(NULL);
+	}
+
+}
+#endif
+
+/* Ethernet interrupt handler */
+#ifdef BOOTLOADER
+static void em86xx_eth_intr_handler(int irq, void *dev_id)
+#else
+static irqreturn_t em86xx_eth_intr_handler(int irq, void *dev_id)
+#endif
+{
+	int num_rx_desc_freed = 0;
+	unsigned long status;
+	struct net_device *dev = (struct net_device *)dev_id;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+#ifdef BOOTLOADER
+        if( memcmp(dev->name,DRIVER, sizeof(DRIVER)) != 0) 
+                return;
+#else
+        if (dev_id != (void *)&em86xx_eth_dev)
+                return IRQ_NONE;
+#endif
+        /* Check status */
+        status = em86xx_read_reg(EM86XX_SR_REG);
+
+        // clear all interrupt requests
+        em86xx_write_reg(EM86XX_SR_REG, status) ;
+
+        if (status & DmaIntNormal) {
+                if (status & DmaIntRxCompleted) {
+	                num_rx_desc_freed = em86xx_eth_rx(dev);
+		}
+                else if(status & DmaIntTxCompleted){
+			if(private->need_restart_tx_queue){
+				private->need_restart_tx_queue = 0;
+				netif_start_queue(dev);
+			}
+/*			else if (status & DmaIntTxCompleted ) {
+				ERR_PRINT("\t%s: DmaIntTxCompleted : Transmit completed (Normal)\n", dev->name);
+			}
+			else if (status & DmaIntTxNoBuffer ) {
+				ERR_PRINT("\t%s: DmaIntTxNoBuffer : Transmit buffer unavailable (Normal)\n", dev->name);
+			}
+			else if (status & DmaIntRxCompleted ) {
+				ERR_PRINT("\t%s: DmaIntRxCompleted : Completion of frame reception (Normal)\n", dev->name);
+			}
+			else if (status & DmaIntEarlyRx) {
+				ERR_PRINT("\t%s: DmaIntEarlyRx : Early receive interrupt (Normal)\n", dev->name);
+			}
+*/
+		}
+		else {
+                        ERR_PRINT("%s: unhandled NIS 0x%08lx\n", dev->name, status);
+		}
+	}
+ 
+	if (status & DmaIntAbnormal) { 
+                if (status & DmaIntRxNoBuffer) {
+			if (num_rx_desc_freed == 0)
+	                	num_rx_desc_freed = em86xx_eth_rx(dev);
+
+			if(num_rx_desc_freed == 0){
+                        	ERR_PRINT("%s: receive buffer unavailable 0x%08lx\n", dev->name, status);
+                        	em86xx_eth_reset_rx_buf(dev);			
+			}		
+                } else if (status & DmaIntRxStopped) {
+                        ERR_PRINT("%s: receive process stopped\n", dev->name);
+                        em86xx_set_reg(EM86XX_CR_REG, DmaRxStart); 
+                } else if (status & DmaIntTxStopped ) {
+                        ERR_PRINT("%s: transmit process stopped\n", dev->name);
+                        em86xx_write_reg(EM86XX_CR_REG, DmaTxStart); 
+                } else if (status & DmaIntTxUnderflow) {
+                        ERR_PRINT("%s: transmit underflow\n", dev->name);
+                } else if (status & DmaIntEarlyTx ) {
+                        ERR_PRINT("%s: Early transmit interrupt\n", dev->name);
+                } else if (status & DmaIntBusError ) {
+                        ERR_PRINT("%s: Fatal bus error\n", dev->name);
+			if (status & DmaRxAbort) {
+				ERR_PRINT("\t%s : DmaRxAbort : receiver bus abort\n", dev->name);
+			}
+			else if (status & DmaTxAbort) {
+				ERR_PRINT("\t%s : DmaTxAbort : transmitter bus abort\n", dev->name);
+			}
+                } else {
+                        ERR_PRINT("%s: unhandled AIS 0x%08lx\n", dev->name, status);
+                }
+        }
+ 
+	if ((status & (DmaIntAbnormal | DmaIntNormal)) == 0) {
+#ifdef DEBUG_RX_TX_STATE
+		unsigned long st;
+#endif
+                DBG_PRINT("%s: Unhandled SR 0x%08lx --> %s %s\n", dev->name, status, (status & DmaTxState)?"DmaTxState":"", (status & DmaRxState)?"DmaRxState":"");
+#ifdef DEBUG_RX_TX_STATE
+		if (status & DmaTxState) {
+			st = (status & DmaTxState);
+			ERR_PRINT("\t%s: DmaTxState : Transmit process state (status == 0x%X)\n", dev->name, st);
+			switch (st){
+			case DmaTxStopped:
+				ERR_PRINT("\t%s: DmaTxStopped : Stopped\n", dev->name);
+				break;
+			case DmaTxFetching:
+				ERR_PRINT("\t%s: DmaTxFetching : Running - fetching the descriptor\n", dev->name);
+				break;
+			case DmaTxWaiting:
+				ERR_PRINT("\t%s: DmaTxWaiting : Running - waiting for end of transmission\n", dev->name);
+				break;
+			case DmaTxReading:
+				ERR_PRINT("\t%s: DmaTxReading : Running - reading the data from memory\n", dev->name);
+				break;
+			case DmaTxSuspended:
+				ERR_PRINT("\t%s: DmaTxSuspended : Suspended\n", dev->name);
+				break;
+			case DmaTxClosing:
+				ERR_PRINT("\t%s: DmaTxClosing : Running - closing descriptor\n", dev->name);
+				break;
+			default:
+				ERR_PRINT("\t%s: UNKNOWN Tx state\n", dev->name);
+				break;
+			}
+		}
+		
+		if (status & DmaRxState) {
+			st = (status & DmaRxState);
+			ERR_PRINT("\t%s: DmaRxState : Receive process state (status == 0x%X)\n", dev->name, st);
+			switch (st){
+			case DmaRxStopped: 
+				ERR_PRINT("\t%s: DmaRxStopped : Stopped\n", dev->name); 
+				break;
+			case DmaRxFetching:
+				ERR_PRINT("\t%s: DmaRxFetching : Running - fetching the descriptor\n", dev->name); 
+				break;
+			case DmaRxChecking:
+				ERR_PRINT("\t%s: DmaRxChecking : Running - checking for end of packet \n", dev->name);
+				break;
+			case DmaRxWaiting:
+				ERR_PRINT("\t%s: DmaRxWaiting : Running - waiting for packet\n", dev->name);
+				break;
+			case DmaRxSuspended:
+				ERR_PRINT("\t%s: DmaRxSuspended : Suspended\n", dev->name);
+				break;
+			case DmaRxClosing:
+				ERR_PRINT("\t%s: DmaRxClosing : Running - closing descriptor\n", dev->name);
+				break;
+			case DmaRxFlushing:
+				ERR_PRINT("\t%s: DmaRxFlushing : Running - flushing the current frame\n", dev->name);
+				break;
+			case DmaRxQueuing:
+				ERR_PRINT("\t%s: DmaRxQueuing : Running - queuing the recieve frame into host memory\n", dev->name);
+				break;
+			default:
+				ERR_PRINT("\t%s: UNKNOWN Rx state\n", dev->name);
+				break;
+			}
+		}
+#endif
+        }
+	
+#ifdef BOOTLOADER
+	 return;
+#else
+        return IRQ_HANDLED;
+#endif
+ }
+
+static void netdev_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, "GBUS");
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+static int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+	int rc;
+
+	DBG_PRINT_INOUT_FUNC("START");
+        spin_lock_irqsave(&private->lock, flags);
+	rc = mii_ethtool_gset(&private->mii_if, cmd);
+        spin_unlock_irqrestore(&private->lock, flags);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+	int rc;
+
+	DBG_PRINT_INOUT_FUNC("START");
+        spin_lock_irqsave(&private->lock, flags);
+	rc = mii_ethtool_sset(&private->mii_if, cmd);
+        spin_unlock_irqrestore(&private->lock, flags);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static int netdev_nway_reset(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	int rc;
+	DBG_PRINT_INOUT_FUNC("START");
+	rc = mii_nway_restart(&private->mii_if);
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static u32 netdev_get_link(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	int rc;
+	DBG_PRINT_INOUT_FUNC("START");
+	rc = mii_link_ok(&private->mii_if);
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static u32 netdev_get_msglevel(struct net_device *dev)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+static void netdev_set_msglevel(struct net_device *dev, u32 value)
+{
+}
+
+static struct ethtool_ops netdev_ethtool_ops = {
+	.get_drvinfo		= netdev_get_drvinfo,
+	.get_settings		= netdev_get_settings,
+	.set_settings		= netdev_set_settings,
+	.nway_reset		= netdev_nway_reset,
+	.get_link		= netdev_get_link,
+	.get_msglevel		= netdev_get_msglevel,
+	.set_msglevel		= netdev_set_msglevel,
+	.get_sg			= ethtool_op_get_sg,
+	.get_tx_csum		= ethtool_op_get_tx_csum,
+};
+
+#ifndef BOOTLOADER
+/* Handling ioctl call */
+//static int em86xx_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+static int em86xx_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+#if 1
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        int ret;
+        unsigned long flags;
+
+        spin_lock_irqsave(&private->lock, flags);
+        ret = generic_mii_ioctl(&private->mii_if, if_mii(ifr), cmd, NULL);
+        spin_unlock_irqrestore(&private->lock, flags);
+
+        return ret;
+
+#else
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+	int ret = 0;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	struct ifr_data_struct
+ 	{
+		u32 unit;
+    		u32 addr;
+    		u32 data;
+  	} *req = (struct ifr_data_struct *)ifr->ifr_data;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	if (!netif_running(dev)) {
+		DBG_PRINT( "%s : ioctl, but device not running !!\n", dev->name);
+		return -EINVAL;
+	}
+
+        spin_lock_irqsave(&private->lock, flags);
+	
+	if( req->unit == 3 ) {
+		DBG_PRINT( "em86xx::read/write MII registers(%s, cmd=%08x) unit=0x%x  reg=0x%x\n", 
+			   dev->name, cmd, req->unit, req->addr );
+		ret = generic_mii_ioctl(&private->mii_if, data, cmd, NULL);
+	}
+	else {
+		switch( cmd ) {
+		case SIOCDEVPRIVATE:  
+			DBG_PRINT( "em86xx::read registers(%s, cmd=%08x) unit=0x%x  reg=0x%x\n", 
+				   dev->name, cmd, req->unit, req->addr );
+			
+			if( req->unit == 0 ){        /* Read register */
+      				req->data = em86xx_read_reg( req->addr );
+    			}
+			else if( req->unit == 1 ){   /* Read MAC register */
+      				req->data = em86xx_read_mac_reg( req->addr );
+    			}
+    			else if( req->unit == 2 ) {   /* Read DMA register */
+      				req->data = em86xx_read_dma_reg( req->addr );
+    			}
+			else {
+				DBG_PRINT( "Unknow read request : %d\n", req->unit);
+				ret = -EOPNOTSUPP;
+			}
+    			break;
+  		case SIOCDEVPRIVATE+1:                /* Write registers */
+			DBG_PRINT( "em86xx::write registers(%s, cmd=%08x) unit=0x%x reg=0x%x data=0x%x\n", 
+				    dev->name, cmd ,req->unit, req->addr, req->data);
+
+    			if( req->unit == 0 ) {        /* Write register */
+      				em86xx_write_reg( req->addr, req->data );
+    			}
+    			else if( req->unit == 1 ) {        /* Write MAC register */
+      				em86xx_write_mac_reg( req->addr, req->data );
+    			}
+    			else if( req->unit == 2 ) {   /* Write DMA register */
+      				em86xx_write_dma_reg( req->addr, req->data );
+    			}
+			else {
+				DBG_PRINT( "Unknow write request : %d\n", req->unit);
+				ret = -EOPNOTSUPP;
+			}
+    			break;			
+		default:
+			DBG_PRINT( "Unknow cmd : %d\n", cmd);
+    			ret = -EOPNOTSUPP;
+		}
+	}
+	
+        spin_unlock_irqrestore(&private->lock, flags);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return ret;
+#endif
+}
+#endif
+
+/* Kernel level ethernet initialization */
+static int em86xx_eth_init(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+	em86xx_write_reg(EM86XX_SR_REG, em86xx_read_reg(EM86XX_SR_REG));
+
+	if (dev == NULL)
+  		goto failed;
+
+	private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	/* Initialize private data */
+	spin_lock_init(&private->lock);
+	
+	private->rxdsc = (volatile struct em86xx_desc *)NON_CACHED((u32)private->eth_rxdsc);
+	private->txdsc = (volatile struct em86xx_desc *)NON_CACHED((u32)private->eth_txdsc);
+	private->rxbuf = (volatile unsigned char *)NON_CACHED((u32)private->eth_rxbuf);
+	private->txbuf = (volatile unsigned char *)NON_CACHED((u32)private->eth_txbuf);
+
+	/* Ethernet device initialization */
+#ifdef BOOTLOADER
+        /* Fill in the fields of the device structure with ethernet-generic values.*/
+//      dev->type               = ARPHRD_ETHER;
+        dev->mtu                = ETH_DATA_LEN; /* eth_mtu */
+        dev->addr_len           = ETH_ALEN;
+        memset(dev->broadcast, 0xff, ETH_ALEN);
+        dev->hard_header_len = ETH_HLEN;
+#else
+	ether_setup(dev);
+#endif
+
+	/* reset dma engine*/
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOn);
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOff);
+
+	if (em86xx_set_mac(dev))
+  		goto failed;
+
+	/* Hook up with handlers */
+#ifdef BOOTLOADER
+        dev->send_packet         = em86xx_eth_tx;
+        dev->open                = em86xx_eth_open;
+        dev->close               = em86xx_eth_close;
+#else
+	dev->get_stats		 = em86xx_eth_stats;
+	dev->hard_start_xmit	 = em86xx_eth_tx;
+	dev->open		 = em86xx_eth_open;
+	dev->stop		 = em86xx_eth_close;
+#ifdef USE_HW_FILTERING
+	dev->set_multicast_list  = em86xx_eth_set_multicast_list;
+#endif
+	dev->do_ioctl		 = em86xx_eth_ioctl;
+	dev->set_mac_address	 = em86xx_eth_set_macaddr;
+        dev->ethtool_ops         = &netdev_ethtool_ops;
+
+	dev->tx_queue_len = private->num_txdesc; 
+//	dev->flags &= ~IFF_MULTICAST;
+//	dev->flags |= IFF_DEBUG;
+#endif
+	DBG_PRINT("Detect PHY\n");
+	if (phy_detect(dev, &private->mii_if) < 0) {
+		DBG_PRINT_INOUT_FUNC("END");
+		return -ENODEV;
+	}
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+
+failed:
+	DBG_PRINT_INOUT_FUNC("END");
+	return(-EIO);
+}
+
+static int em86xx_eth_reset_desc(struct net_device *dev, int *reset)
+{
+	EM86XX_ETH_PRIV *private;
+	int i;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	if (dev == NULL)
+  		return(-EIO);
+	else
+		private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	if (*reset) {
+		memset((void*)&private->stats, 0, sizeof(struct net_device_stats));
+		memset((void*)&private->mii_if, 0, sizeof(struct mii_if_info));
+		private->autoneg_active = 0;
+		private->phy_loopback = 0;	
+
+#ifndef BOOTLOADER
+
+#ifdef USE_KERNEL_TIMER 
+		memset((void*)&private->eth_timer, 0, sizeof(struct timer_list));
+#endif
+		private->need_restart_tx_queue = 0; 
+#endif
+	}
+
+	*reset = 0;
+
+	/* Clear all tx/rx buffer memory */
+	memset((void *)(private->rxbuf), 0, private->num_rxdesc * R_BUF_SIZE);
+	memset((void *)(private->txbuf), 0, private->num_txdesc * T_BUF_SIZE);
+
+	/* Initialize the indices */
+	private->last_rxidx = 0;
+	private->next_txidx = 0;
+
+#ifndef BOOTLOADER
+	if (private->rx_skb_list != NULL) {
+		for (i = 0; i < private->num_rxdesc; i++) {
+			if (private->rx_skb_list[i] != NULL)
+				dev_kfree_skb(private->rx_skb_list[i]);
+		}
+	}
+	memset((void *)private->rx_skb_list, 0, sizeof(struct skb_buff *) * private->num_rxdesc);
+#endif
+
+	/* Intialize the descriptors */
+	em86xx_eth_setup_desc(dev);
+
+	phy_detect(dev, &private->mii_if);
+
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Driver installation: this is where the thing starts */
+#ifdef BOOTLOADER
+int em86xx_eth_probe(struct net_device *dev)
+#else
+static int __init em86xx_eth_startup(void)
+#endif
+{
+#ifndef BOOTLOADER
+	struct net_device *dev 	= &em86xx_eth_dev;
+#endif
+	int err = 0, i;
+	EM86XX_ETH_PRIV *private= NULL;
+#ifndef STATIC_BUF_ALLOC
+	unsigned long max_num_rxdsc, max_num_txdsc;
+	unsigned long rxbuf_size, txbuf_size;
+#endif
+
+	DBG_PRINT_INOUT_FUNC("START");
+#if defined(CONFIG_TANGOX)
+        if (tangox_ethernet_enabled(0) == 0) {
+                MSG_PRINT(KERN_WARNING "TangoX builtin ethernet is disabled.\n");
+                return(0);
+        }
+#endif
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+	em86xx_write_reg(EM86XX_SR_REG, em86xx_read_reg(EM86XX_SR_REG));
+
+	if(dev != NULL) {
+		if(dev->priv != NULL) {
+			private = (EM86XX_ETH_PRIV *)dev->priv;
+			if (private->dev_count != 0) {
+				err = -EIO;
+				goto failed;
+			} 
+		}
+	}
+
+	/* Allocate memory for private data */
+#ifdef BOOTLOADER
+        dev->priv = private = (EM86XX_ETH_PRIV *)malloc(sizeof(EM86XX_ETH_PRIV));//, GFP_KERNEL);
+#else
+	
+	DBG_PRINT("KMALLOC\n");
+	dev->priv = private = (EM86XX_ETH_PRIV *)kmalloc(sizeof(EM86XX_ETH_PRIV), GFP_KERNEL);
+#endif
+	if (dev->priv == NULL) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	memset(dev->priv, 0, sizeof(EM86XX_ETH_PRIV));
+
+	private->num_rxdesc = num_rxdesc_param;;
+	private->num_txdesc = num_txdesc_param;
+
+	DBG_PRINT("private->num_rxdesc = %lu, private->num_txdesc = %lu \n", private->num_rxdesc, private->num_txdesc);
+#ifndef STATIC_BUF_ALLOC	
+	DBG_PRINT("NON STATIC_BUF_ALLOC\n");
+	/* Validating module parameters */
+	max_num_rxdsc = max_num_txdsc = PAGE_SIZE / (2 * sizeof(struct em86xx_desc));
+ #ifdef BOOTLOADER
+	DBG_PRINT("BOOTLOADER\n");
+	if (((private->num_rxdesc < MIN_NUM_RDESC) || (private->num_rxdesc > max_num_rxdsc)) ||
+	    ((private->num_txdesc < MIN_NUM_TDESC) || (private->num_txdesc > max_num_txdsc))) {
+		err = -EIO;
+		goto failed;
+	} else if ((private->desc_page = NON_CACHED(malloc(PAGE_SIZE))) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	}
+ #else
+	DBG_PRINT("NOT BOOTLOADER\n");
+	if (((private->num_rxdesc < MIN_NUM_RDESC) || (private->num_rxdesc > max_num_rxdsc)) ||
+	    ((private->num_txdesc < MIN_NUM_TDESC) || (private->num_txdesc > max_num_txdsc))) {
+		err = -EIO;
+		goto failed;
+	} else if ((private->desc_page = __get_free_page(GFP_KERNEL | GFP_DMA)) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	} else if ((private->rx_skb_list = (struct skb_buff **)kmalloc(sizeof(struct skb_buff *) 
+				                 * private->num_rxdesc, GFP_KERNEL)) == NULL) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	memset((void *)private->rx_skb_list, 0, sizeof(struct skb_buff *) * private->num_rxdesc);
+ #endif
+
+	/* Split a page for both rx/tx descriptor */
+	private->eth_rxdsc = (struct em86xx_desc *)private->desc_page;
+	private->eth_txdsc = (struct em86xx_desc *)(private->desc_page + ((1 << PAGE_SHIFT) / 2));
+
+	/* Calculate the size needed for tx/rx -- aligned by pages */
+	rxbuf_size = private->num_rxdesc * R_BUF_SIZE;
+	txbuf_size = private->num_txdesc * T_BUF_SIZE;
+	if ((rxbuf_size & (PAGE_SIZE - 1)) != 0)
+		rxbuf_size = (rxbuf_size & PAGE_MASK) + PAGE_SIZE;
+	if ((txbuf_size & (PAGE_SIZE - 1)) != 0)
+		txbuf_size = (txbuf_size & PAGE_MASK) + PAGE_SIZE;
+	DBG_PRINT("txbuf_size = 0x%08lx, rxbuf_size = 0x%08lx\n", txbuf_size, rxbuf_size);
+
+ #ifndef BOOTLOADER
+	/* Calculate the order needed for tx/rx */
+	for (private->rxbuf_order = 0; private->rxbuf_order < MAX_ORDER; private->rxbuf_order++) {
+		if ((PAGE_SIZE * (1 << private->rxbuf_order)) >= rxbuf_size)
+			break;
+	}
+
+	for (private->txbuf_order = 0; private->txbuf_order < MAX_ORDER; private->txbuf_order++) {
+		if ((PAGE_SIZE * (1 << private->txbuf_order)) >= txbuf_size)
+			break;
+	}
+
+	if ((private->rxbuf_order >= MAX_ORDER) || (private->txbuf_order >= MAX_ORDER)) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	DBG_PRINT("private->txbuf_order = 0x%08lx, private->rxbuf_order = 0x%08lx\n", private->txbuf_order, private->rxbuf_order);
+ #endif
+		
+ #ifdef BOOTLOADER
+	if ((private->rxbuf_pages = NON_CACHED(malloc(rxbuf_size))) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	} else if ((private->txbuf_pages = NON_CACHED(malloc(txbuf_size))) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	}
+ #else
+	if ((private->rxbuf_pages = __get_free_pages(GFP_KERNEL | GFP_DMA, private->rxbuf_order)) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	} else if ((private->txbuf_pages = __get_free_pages(GFP_KERNEL | GFP_DMA, private->txbuf_order)) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	}
+ #endif
+
+	private->eth_rxbuf  = (unsigned char *)private->rxbuf_pages;
+	private->eth_txbuf  = (unsigned char *)private->txbuf_pages;
+#else
+	DBG_PRINT("STATIC_BUF_ALLOC\n");
+#endif
+
+#ifndef BOOTLOADER
+	SET_MODULE_OWNER(&em86xx_eth_dev);
+#endif
+
+	MSG_PRINT("Ethernet driver for EM86XX (v1.0)");
+        dev->irq = IRQ_ETHERNET;
+
+	private->reset_flag 	= 1;
+
+	/* Get a device name: normally it'll be eth0 */
+#ifdef BOOTLOADER
+        memcpy( dev->name, DRIVER, sizeof(DRIVER));
+
+        /* Register ISR */
+        em86xx_request_irq(IRQ_ETHERNET, em86xx_eth_intr_handler, dev);
+#else
+	if ((err = dev_alloc_name(&em86xx_eth_dev, "eth%d")) < 0){
+		printk("dev_alloc_name failed\n");
+  		goto failed;
+	}
+
+	/* Register ISR */
+	if ((err = request_irq(IRQ_ETHERNET, em86xx_eth_intr_handler, IRQF_SHARED, "ethernet", 
+      	 	 &em86xx_eth_dev)) != 0) {
+  		err = -EIO;
+		printk("request_irq failed\n");
+  		goto failed;
+	} else
+#endif 
+  		MSG_PRINT(" on %s (IRQ: %d)", dev->name, IRQ_ETHERNET);
+
+
+	if (em86xx_get_macaddr(dev->dev_addr)) {
+  		err = -EIO;
+		printk("get macaddr failed\n");
+  		goto failed;
+	}
+
+	MSG_PRINT("\n(MAC %02x", dev->dev_addr[0]);
+	for (i = 1; i < 6; i++)
+	  	MSG_PRINT(":%02x", dev->dev_addr[i]);
+	MSG_PRINT(", tx_desc/rx_desc = %ld/%ld), ", private->num_txdesc, private->num_rxdesc);
+	if (phy_address < 0)
+		MSG_PRINT("PHY probing enabled\n");
+	else
+		MSG_PRINT("PHY address: %d\n", phy_address);
+
+	/* Point to driver initialization routine and register the device with kernel */
+	dev->init = em86xx_eth_init;
+#ifdef BOOTLOADER
+        em86xx_eth_init(dev);
+	DBG_PRINT("AFTER em86xx_eth_init\n");
+        dev->state = NETDEV_DOWN;
+	DBG_PRINT("AFTER STATE\n");
+#else
+	if (register_netdev(dev) != 0) {
+  		err = -EIO;
+  		goto failed;
+	}
+#endif
+
+	MSG_PRINT("%s: driver installation completed.\n", dev->name);
+	private->dev_count++;
+	netif_carrier_off(dev); /* By default the carrier is off */
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+
+failed:
+  	if (dev->priv != NULL) {
+#ifdef BOOTLOADER
+                free(dev->priv);
+#else
+    		kfree(dev->priv);
+#endif
+    		dev->priv = NULL;
+  	}
+#ifndef STATIC_BUF_ALLOC
+#ifdef BOOTLOADER
+	if (private->desc_page   != 0)
+		free((void *)CACHED(private->desc_page));
+	if (private->rxbuf_pages != 0)
+		free((void *)CACHED(private->rxbuf_pages));
+	if (private->txbuf_pages != 0)
+		free((void *)CACHED(private->txbuf_pages));
+#else
+	if (private->desc_page   != 0)
+		free_page(private->desc_page);
+	if (private->rxbuf_pages != 0)
+		free_pages(private->rxbuf_pages, private->rxbuf_order);
+	if (private->txbuf_pages != 0)
+		free_pages(private->txbuf_pages, private->txbuf_order);
+	if (private->rx_skb_list != NULL);
+		kfree(private->rx_skb_list);
+#endif
+#endif
+  	MSG_PRINT("%s: driver installation failed.\n", dev->name);
+	DBG_PRINT_INOUT_FUNC("END");
+  	return(err);
+}
+
+#ifndef BOOTLOADER
+/* Uninstallation of drive */
+static void __exit em86xx_eth_shutdown(void)
+{
+	struct net_device *dev 	= &em86xx_eth_dev;
+	EM86XX_ETH_PRIV *private= NULL;
+#if defined(CONFIG_TANGOX)
+        if (tangox_ethernet_enabled(0) == 0) 
+                return;
+#endif
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	if (dev == NULL)
+  		return;
+	else
+		private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	if (private == NULL) {
+		return;
+	}
+
+	if (private->dev_count != 0) {
+		/* Turn off IRQ and stop receive/transmit */
+  		em86xx_write_reg(EM86XX_CR_REG, 0);
+  		em86xx_write_reg(EM86XX_IER_REG, 0);
+
+  		/* Unregister the device and ISR */
+  		free_irq(IRQ_ETHERNET, &em86xx_eth_dev);
+		unregister_netdev(&em86xx_eth_dev);
+
+		/* Set desc base address registers to 0 */
+		em86xx_write_reg(EM86XX_RLBAR_REG, 0);
+		em86xx_write_reg(EM86XX_TLBAR_REG, 0);
+#ifndef STATIC_BUF_ALLOC
+#ifdef BOOTLOADER
+		if (private->desc_page   != 0)
+			free((void *)CACHED(private->desc_page));
+		if (private->rxbuf_pages != 0)
+			free((void *)CACHED(private->rxbuf_pages));
+		if (private->txbuf_pages != 0)
+			free((void *)CACHED(private->txbuf_pages));
+#else
+		if (private->desc_page   != 0)
+			free_page(private->desc_page);
+		if (private->rxbuf_pages != 0)
+			free_pages(private->rxbuf_pages, private->rxbuf_order);
+		if (private->txbuf_pages != 0)
+			free_pages(private->txbuf_pages, private->txbuf_order);
+		if (private->rx_skb_list != NULL) {
+			int i;
+			for (i = 0; i < private->num_rxdesc; i++) {
+				if (private->rx_skb_list[i] != NULL)
+					dev_kfree_skb(private->rx_skb_list[i]);
+			}
+			kfree(private->rx_skb_list);
+		}
+#endif
+#endif
+		/* Free up memory */
+		if (em86xx_eth_dev.priv != NULL) {
+			kfree(em86xx_eth_dev.priv);
+			em86xx_eth_dev.priv = NULL;
+  		}
+	} 
+
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+/* Register startup/shutdown routines */
+module_init(em86xx_eth_startup);
+module_exit(em86xx_eth_shutdown);
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/tango2_enet_old.h linux-2.6.22.19/drivers/net/tango2_enet_old.h
--- linux-2.6.22.19.ref/drivers/net/tango2_enet_old.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/drivers/net/tango2_enet_old.h	2009-03-26 19:01:26.000000000 -0700
@@ -0,0 +1,829 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+  
+/*  
+ * Definitions used to for ethernet module.
+ */
+
+#ifndef __EM86XX_ETH_H__ 
+#define __EM86XX_ETH_H__ 
+
+#ifndef BOOTLOADER
+#include <asm/io.h>
+#include <linux/delay.h>
+#ifdef CONFIG_TANGOX
+#include <asm/addrspace.h>
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#endif
+#define NON_CACHED(x)		KSEG1ADDR((u32)(x))
+#define CACHED(x)		KSEG0ADDR((u32)(x))
+#define PHYSADDR(x)		tangox_dma_address(CPHYSADDR(x))
+#define IRQ_ETHERNET 		(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_ETH_MAC_INT)//38
+#elif defined(CONFIG_ARCH_TANGO15)
+#include <asm/arch/hardware.h>
+#define NON_CACHED(x)		em86xx_to_ncaddr((u32)(x))
+#define CACHED(x)		em86xx_to_caddr((u32)(x))
+#define PHYSADDR(x)		NON_CACHED(x)
+#else
+#error "Not support platform/architecture."
+#endif
+
+#include <asm/types.h>
+
+#else
+
+#include "config.h"
+#include "version.h"
+#include "hardware.h"
+#include "io.h"
+
+typedef unsigned int u32;
+typedef unsigned short int u16;
+typedef unsigned char u8;
+typedef int     bool;
+
+#define NON_CACHED(x)           (((u32)(x)) & 0x7fffffff)
+#define PHYSADDR(x)		NON_CACHED(x)
+
+struct net_device_stats
+{
+        unsigned long   rx_packets;             /* total packets received       */
+        unsigned long   tx_packets;             /* total packets transmitted    */
+        unsigned long   rx_bytes;               /* total bytes received         */
+        unsigned long   tx_bytes;               /* total bytes transmitted      */
+        unsigned long   rx_errors;              /* bad packets received         */
+        unsigned long   tx_errors;              /* packet transmit problems     */
+        unsigned long   rx_dropped;             /* no space in linux buffers    */
+        unsigned long   tx_dropped;             /* no space available in linux  */
+        unsigned long   multicast;              /* multicast packets received   */
+        unsigned long   collisions;
+
+        /* detailed rx_errors: */
+        unsigned long   rx_length_errors;
+        unsigned long   rx_over_errors;         /* receiver ring buff overflow  */
+        unsigned long   rx_crc_errors;          /* recved pkt with crc error    */
+        unsigned long   rx_frame_errors;        /* recv'd frame alignment error */
+        unsigned long   rx_fifo_errors;         /* recv'r fifo overrun          */
+        unsigned long   rx_missed_errors;       /* receiver missed packet       */
+
+        /* detailed tx_errors */
+        unsigned long   tx_aborted_errors;
+        unsigned long   tx_carrier_errors;
+        unsigned long   tx_fifo_errors;
+        unsigned long   tx_heartbeat_errors;
+        unsigned long   tx_window_errors;
+
+        /* for cslip etc */
+        unsigned long   rx_compressed;
+        unsigned long   tx_compressed;
+
+};
+
+static inline int is_valid_ether_addr( u8 *addr )
+{
+        const char zaddr[6] = {0,};
+
+        return !(addr[0]&1) && memcmp( addr, zaddr, 6);
+}
+
+#endif//BOOTLOADER
+
+#define EM86XX_HOST_BASE	REG_BASE_host_interface
+#define EM86XX_HOST_ETHMAC	0x00006000 
+#define EM86XX_HOST_ETHDMA	0x00007000 
+#define EM86XX_ETHDMA_BASE	CPHYSADDR(EM86XX_HOST_BASE + EM86XX_HOST_ETHDMA)
+#define EM86XX_BMR_REG		(EM86XX_ETHDMA_BASE + 0x0)
+#define EM86XX_TPDR_REG		(EM86XX_ETHDMA_BASE + 0x4)
+#define EM86XX_RPDR_REG		(EM86XX_ETHDMA_BASE + 0x8)
+#define EM86XX_RLBAR_REG	(EM86XX_ETHDMA_BASE + 0xc)
+#define EM86XX_TLBAR_REG	(EM86XX_ETHDMA_BASE + 0x10)
+#define EM86XX_SR_REG		(EM86XX_ETHDMA_BASE + 0x14)
+#define EM86XX_CR_REG		(EM86XX_ETHDMA_BASE + 0x18)
+#define EM86XX_IER_REG		(EM86XX_ETHDMA_BASE + 0x1c)
+#define EM86XX_MFCR_REG		(EM86XX_ETHDMA_BASE + 0x20)
+#define EM86XX_IFR_REG		(EM86XX_ETHDMA_BASE + 0x24) /*reserved ?*/
+#define EM86XX_TDVPAR_REG	(EM86XX_ETHDMA_BASE + 0x4c) /*reserved ?*/
+#define EM86XX_CHTBAR_REG	(EM86XX_ETHDMA_BASE + 0x50)
+#define EM86XX_CHRBAR_REG	(EM86XX_ETHDMA_BASE + 0x54)
+
+#define EM86XX_ETHMAC_BASE	CPHYSADDR(EM86XX_HOST_BASE + EM86XX_HOST_ETHMAC)
+#define EM86XX_MACCR_REG	(EM86XX_ETHMAC_BASE + 0x0)
+#define EM86XX_MACAHR_REG	(EM86XX_ETHMAC_BASE + 0x4)
+#define EM86XX_MACALR_REG	(EM86XX_ETHMAC_BASE + 0x8)
+#define EM86XX_MCHTHR_REG	(EM86XX_ETHMAC_BASE + 0xc)
+#define EM86XX_MCHTLR_REG	(EM86XX_ETHMAC_BASE + 0x10)
+#define EM86XX_MIIAR_REG	(EM86XX_ETHMAC_BASE + 0x14)
+#define EM86XX_MIIDR_REG	(EM86XX_ETHMAC_BASE + 0x18)
+#define EM86XX_FCR_REG		(EM86XX_ETHMAC_BASE + 0x1c)
+#define EM86XX_V1TR_REG		(EM86XX_ETHMAC_BASE + 0x20)
+#define EM86XX_V2TR_REG		(EM86XX_ETHMAC_BASE + 0x24)
+#define EM86XX_WUFF_REG	        (EM86XX_ETHMAC_BASE + 0x28)
+#define EM86XX_WUCS_REG		(EM86XX_ETHMAC_BASE + 0x2C)
+
+/* MII interface */
+#define MiiIfSpeed10M     	0x00000000
+#define MiiIfSpeed100M		0x00000004
+#define MiiIfExtPhyMii		0x00000000
+#define MiiIfExtPhyRmii		0x00000001
+#define MiiIfIntPhy    		0x00000002
+
+#ifndef __ASSEMBLY__ 
+
+/* Descriptor related ... */
+struct em86xx_desc {
+  volatile unsigned long desc0;
+  volatile unsigned long desc1;
+  volatile unsigned long desc2;
+  volatile unsigned long desc3;
+};
+
+/**********************************************************
+ * MAC110 Network interface registers
+ **********************************************************/
+
+enum MacControlReg      /* MAC Control register layout */
+{                                         /* Bit description                        R/W   Reset value */
+  MacFilterOff            = 0x80000000,     /* Receive all incoming packets         RW                */
+  MacFilterOn             = 0,              /* Receive filtered packets only                  0       */
+
+  MacBigEndian            = 0x40000000,     /* Big endian mode                      RW                */
+  MacLittleEndian         = 0,              /* Little endian                                  0       */
+
+  MacHeartBeatOff         = 0x10000000,     /* Heart beat signal quality disable    RW                */
+  MacHeartBeatOn          = 0,              /* Heart beat signal quality enable               0       */
+
+  MacSelectSrl            = 0x08000000,     /* Select SRL port                      RW                */
+  MacSelectMii            = 0,              /* Select MII port                                0       */
+
+  MacDisableRxOwn         = 0x00800000,     /* Disable receive own packets          RW                */
+  MacEnableRxOwn          = 0,              /* Enable receive own packets                     0       */
+
+  MacLoopbackExt          = 0x00400000,     /* External loopback                    RW                */
+  MacLoopbackInt          = 0x00200000,     /* Internal loopback                                      */
+  MacLoopbackOff          = 0,              /* Normal mode                                    00      */
+
+  MacFullDuplex           = 0x00100000,     /* Full duplex mode                     RW                */
+  MacHalfDuplex           = 0,              /* Half duplex mode                               0       */
+
+  MacMulticastFilterOff   = 0x00080000,     /* Pass all multicast packets           RW                */
+  MacMulticastFilterOn    = 0,              /* Pass filtered multicast packets                0       */
+
+  MacPromiscuousModeOn    = 0x00040000,     /* Receive all valid packets            RW        1       */
+  MacPromiscuousModeOff   = 0,              /* Receive filtered packets only                          */
+
+  MacFilterInverce        = 0x00020000,     /* Inverse filtering                    RW                */
+  MacFilterNormal         = 0,              /* Normal filtering                               0       */
+
+  MacBadFramesEnable      = 0x00010000,     /* Pass bad frames                      RW                */
+  MacBadFramesDisable     = 0,              /* Do not pass bad frames                         0       */
+
+  MacPerfectFilterOff     = 0x00008000,     /* Hash filtering only                  RW                */
+  MacPerfectFilterOn      = 0,              /* Both perfect and hash filtering                0       */
+
+  MacHashFilterOn         = 0x00002000,     /* perfom hash filtering                RW                */
+  MacHashFilterOff        = 0,              /* perfect filtering only                         0       */
+
+  MacLateCollisionOn      = 0x00001000,     /* Enable late collision control        RW                */
+  MacLateCollisionOff     = 0,              /* Disable late collision control                 0       */
+
+  MacBroadcastDisable     = 0x00000800,     /* Disable reception of broadcast frames RW               */
+  MacBroadcastEnable      = 0,              /* Enable broadcast frames                        0       */
+
+  MacRetryDisable         = 0x00000400,     /* Disable retransmission               RW                */
+  MacRetryEnable          = 0,              /* Enable retransmission                          0       */
+
+  MacPadStripEnable       = 0x00000100,     /* Pad stripping enable                 RW                */
+  MacPadStripDisable      = 0,              /* Pad stripping disable                          0       */
+
+  MacBackoff10            = 0,              /* Backoff Limit (not documented)       RW        00      */
+  MacBackoff8             = 0x00000040,     /* Backoff Limit (not documented)       RW        01      */
+  MacBackoff4             = 0x00000080,     /* Backoff Limit (not documented)       RW        10      */
+  MacBackoff1             = 0x000000c0,     /* Backoff Limit (not documented)       RW        11      */
+
+  MacDeferralCheckEnable  = 0x00000020,     /* Deferral check enable                RW                */
+  MacDeferralCheckDisable = 0,              /* Deferral check disable                         0       */
+
+  MacTxEnable             = 0x00000008,     /* Transmitter enable                   RW                */
+  MacTxDisable            = 0,              /* Transmitter disable                            0       */
+
+  MacRxEnable             = 0x00000004,     /* Receiver enable                      RW                */
+  MacRxDisable            = 0,              /* Receiver disable                               0       */
+};
+
+enum MiiRegisters
+{
+  GEN_ctl   = 0x00,	/* Basic Mode Control Register */
+			/* bit 0-7, 10: Reserved, 
+			   bit 8:  	Duplex Mode: 1=FD, 0=HD
+			   bit 9:	Restart Auto negotiation 1=restart, 0=normal operation
+			   bit11:	1=Power Down, 0=normal operation
+			   bit12:	1=enable auto-negotiation, bit13 and 8 will be ingnored
+					0=disable auto-negotiation, bit13 & 8 to determine the speed and mode
+			   bit13	1=100Mbps 0=10Mbps
+			   bit14	1=enable loopback 0=normal operation
+			   bit15	1=software reset  0=normal operation*/     	
+  GEN_sts   = 0x01,	/* Basic Mode Status Register  */
+			/* bit 0:	1=extended register capability 0=basic register capability only
+			   bit 1:	1=jabber condidtion detected 0=no jabber condition detected
+			   bit 2:	1=valid link established 0=no link
+			   bit 3:	1=Auto-negotiation ok 0=fail
+			   bit 4:	1=remote fault 0=no remote fault
+			   bit 5:	1=auto-negotiation process completed, 0=not completed
+			   bit 6:	MF Preamble suppression
+			   bit 7-10:	Reserved
+			   bit 11:	1=enable 10Base-T HD 0=suppress 10/HD
+			   bit 12:	1=enable 10Base-T FD 0=suppress 10/FD
+			   bit 13:	1=enable 100Base-T FD 0=suppress 100/FD
+			   bit 14:	1=enable 100Base-T FD 0=suppress 100/FD
+			   bit 15:	1=enable 100Base-T4 0=suppress 100-T4*/
+  GEN_id_hi = 0x02,	/* PHY Identifier Register 1   bit 0-15: High PHY identifier default=0000 for RTL8201BL*/
+  GEN_id_lo = 0x03,	/* PHY Identifier Register 2   bit 0-15: Low PHY identifier  default=8201 for RTL8201BL*/
+  AN_adv    = 0x04,	/* Auto-negotiation Advertisement Register */
+			/* bit 0-4:	Selector, only CSMA/CD<0001> is specified
+			   bit 5:	1=10Base-T is supported      0=10Base-T is not supported by local node
+			   bit 6:	1=10Base-T FD is supported   0=10Base-T FD is not supported by local node
+			   bit 7:	1=100Base-TX is supported    0=100Base-TX is not supported by local node
+			   bit 8:	1=100Base-TX FD is supported 0=100Base-TX FD is not supported by local node
+			   bit 9:	1=100Base-T4 is supported    0=100Base-T4 is not supported by local node
+			   bit10 :	1=iflow control is supported 0=flow control is not supported by local node
+			   bit11-12:	Reserved
+			   bit13:	1=advertise remote fault detectioncapability 0=do not advertise remote fault detection capability
+			   bit14:	1=ack reception of link partner capability data word 0=donot ack reception
+			   bit15:	1=transmitting the protocol specific data page 0=transmitting the primary capability data page*/
+  AN_lpa    = 0x05,	/* Auto-negotiation Link partner Ability Register */
+  AN_exp    = 0x06,	/* Auto-negotiation Expansion Register */
+  AN_np     = 0x07,	/* Auto-negotiation Next Page TX */
+  TST       = 0x19,     /* Test register, for checking link10/100 is established*/
+			/* bit 0:	1=Link 100Base Ok, 0=No 100Base link 
+			   bit 1:	1=Link 10Base Ok,  0=No 10Base link */
+
+};
+
+enum Mii_GEN_ctl
+{
+  RESET		= 0x8000,	/* Reset */
+  SPEED		= 0x2000,	/* 100 Mbit/s */
+  AUTONEG_ENB	= 0x1000,	/* Auto negotiation enabled */
+  POWER_DWN	= 0x800, 	/* Power-down enabled */
+  AUTONEG_REST	= 0x200,	/* Restart auto negotiation */
+  DUPLEX 	= 0x0100,	/* Duplex mode */
+};
+
+enum Mii_GEN_sts
+{
+  AUTOCMPLT 	= 0x0020,   	/* Autonegotiation completed */
+  LINK     	= 0x0004,   	/* Link status */
+};
+
+enum Mii_AN_adv
+{
+  CSMACD	= 0x1,		/* CSMA/CD protocol */
+  BASET10	= 0x20, 	/* 10 BaseT support */
+  BASET10FD	= 0x40, 	/* 10 BaseT full duplex support */
+  BASET100	= 0x80, 	/* 100 BaseT support */
+  BASET100FD	= 0x100, 	/* 100 BaseT full duplux support */
+  FLOWCONTROL	= 0x400, 	/* Flow control support */
+  RF		= 0x2000,	/* Remote fault support */
+};
+
+enum Mii_TST
+{
+  LINK100	= 0x1,		/* Link 100 status */
+  LINK10	= 0x2,		/* Link 10  status */
+};
+
+
+enum MacMiiAddrReg     		/* MII address register layout */
+{
+  MiiDevMask    = 0x0000F800,   /* MII device address */
+  MiiDevShift   = 11,
+
+  MiiRegMask    = 0x000007C0,   /* MII register */
+  MiiRegShift   = 6,
+
+  MiiWrite      = 0x00000002,   /* Write to register */
+  MiiRead       = 0,            /* Read from register */
+  MiiBusy       = 0x00000001,   /* MII interface is busy */
+};
+
+enum MacMiiDataReg     		/* MII address register layout */
+{
+  MiiDataMask   = 0x0000FFFF,   /* MII Data */
+};
+
+enum MacFlowControlReg 		/* MAC flow control register layout */
+{                                         /* Bit description                        R/W   Reset value */
+  MacPauseTimeMask        = 0xFFFF0000,   /* PAUSE TIME field in the control frame  RW      0000      */
+  MacPauseTimeShift       = 15,
+
+  MacControlFrameEnable   = 0x00000004,   /* Enable pass control frames to the host RW                */
+  MacControlFrameDisable  = 0,            /* Do not pass control frames to host               0       */
+
+  MacFlowControlEnable    = 0x00000002,   /* Enable flow control                    RW                */
+  MacFlowControlDisable   = 0,            /* Disable flow control                             0       */
+
+  MacSendPauseFrame       = 0x00000001,   /* send pause frame                       RW        0       */
+};
+
+/**********************************************************
+ * DMA Engine registers
+ **********************************************************/
+
+enum DmaBusModeReg         /* DMA bus mode register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaBigEndianDesc        = 0x00100000,   /* Big endian data buffer descriptors     RW                */
+  DmaLittleEndianDesc     = 0,            /* Little endian data descriptors                   0       */
+
+  DmaBurstLength32        = 0x00002000,   /* Dma burst length = 32                  RW                */
+  DmaBurstLength16        = 0x00001000,   /* Dma burst length = 16                                    */
+  DmaBurstLength8         = 0x00000800,   /* Dma burst length = 8                                     */
+  DmaBurstLength4         = 0x00000400,   /* Dma burst length = 4                                     */
+  DmaBurstLength2         = 0x00000200,   /* Dma burst length = 2                                     */
+  DmaBurstLength1         = 0x00000100,   /* Dma burst length = 1                                     */
+  DmaBurstLength0         = 0x00000000,   /* Dma burst length = 0                             0       */
+
+  DmaBigEndianData        = 0x00000080,   /* Big endian data buffers                RW                */
+  DmaLittleEndianData     = 0,            /* Little endian data buffers                       0       */
+
+  DmaDescriptorSkip16     = 0x00000040,   /* number of dwords to skip               RW                */
+  DmaDescriptorSkip8      = 0x00000020,   /* between two unchained descriptors                        */
+  DmaDescriptorSkip4      = 0x00000010,   /*                                                          */
+  DmaDescriptorSkip2      = 0x00000008,   /*                                                          */
+  DmaDescriptorSkip1      = 0x00000004,   /*                                                          */
+  DmaDescriptorSkip0      = 0,            /*                                                  0       */
+
+  DmaReceivePriorityOff   = 0x00000002,   /* equal rx and tx priorities             RW                */
+  DmaReceivePriorityOn    = 0,            /* Rx has prioryty over Tx                          0       */
+
+  DmaResetOn              = 0x00000001,   /* Reset DMA engine                       RW                */
+  DmaResetOff             = 0,            /*                                                  0       */
+};
+
+enum DmaStatusReg         /* DMA Status register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaRxAbort              = 0x01000000,   /* receiver bus abort                     R         0       */
+  DmaTxAbort              = 0x00800000,   /* transmitter bus abort                  R         0       */
+
+  DmaTxState              = 0x00700000,   /* Transmit process state                 R         000     */
+  DmaTxStopped            = 0x00000000,   /* Stopped                                                  */
+  DmaTxFetching           = 0x00100000,   /* Running - fetching the descriptor                        */
+  DmaTxWaiting            = 0x00200000,   /* Running - waiting for end of transmission                */
+  DmaTxReading            = 0x00300000,   /* Running - reading the data from memory                   */
+  DmaTxSuspended          = 0x00600000,   /* Suspended                                                */
+  DmaTxClosing            = 0x00700000,   /* Running - closing descriptor                             */
+
+  DmaRxState              = 0x000E0000,   /* Receive process state                  R         000     */
+  DmaRxStopped            = 0x00000000,   /* Stopped                                                  */
+  DmaRxFetching           = 0x00020000,   /* Running - fetching the descriptor                        */
+  DmaRxChecking           = 0x00040000,   /* Running - checking for end of packet                     */
+  DmaRxWaiting            = 0x00060000,   /* Running - waiting for packet                             */
+  DmaRxSuspended          = 0x00080000,   /* Suspended                                                */
+  DmaRxClosing            = 0x000A0000,   /* Running - closing descriptor                             */
+  DmaRxFlushing           = 0x000C0000,   /* Running - flushing the current frame                     */
+  DmaRxQueuing            = 0x000E0000,   /* Running - queuing the recieve frame into host memory     */
+
+  DmaIntNormal            = 0x00010000,   /* Normal interrupt summary               RW        0       */
+  DmaIntAbnormal          = 0x00008000,   /* Abnormal interrupt summary             RW        0       */
+
+  DmaIntEarlyRx           = 0x00004000,   /* Early receive interrupt (Normal)       RW        0       */
+  DmaIntBusError          = 0x00002000,   /* Fatal bus error (Abnormal)             RW        0       */
+  DmaIntEarlyTx           = 0x00000400,   /* Early transmit interrupt (Abnormal)    RW        0       */
+  DmaIntRxStopped         = 0x00000100,   /* Receive process stopped (Abnormal)     RW        0       */
+  DmaIntRxNoBuffer        = 0x00000080,   /* Receive buffer unavailable (Abnormal)  RW        0       */
+  DmaIntRxCompleted       = 0x00000040,   /* Completion of frame reception (Normal) RW        0       */
+  DmaIntTxUnderflow       = 0x00000020,   /* Transmit underflow (Abnormal)          RW        0       */
+  DmaIntTxNoBuffer        = 0x00000004,   /* Transmit buffer unavailable (Normal)   RW        0       */
+  DmaIntTxStopped         = 0x00000002,   /* Transmit process stopped (Abnormal)    RW        0       */
+  DmaIntTxCompleted       = 0x00000001,   /* Transmit completed (Normal)            RW        0       */
+};
+
+enum DmaControlReg        /* DMA control register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaStoreAndForward      = 0x00200000,   /* Store and forward                      RW        0       */
+  DmaTxStart              = 0x00002000,   /* Start/Stop transmission                RW        0       */
+  DmaTxSecondFrame        = 0x00000004,   /* Operate on second frame                RW        0       */
+  DmaRxStart              = 0x00000002,   /* Start/Stop reception                   RW        0       */
+};
+
+enum  DmaInterruptReg     /* DMA interrupt enable register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaIeNormal            = DmaIntNormal     ,   /* Normal interrupt enable                 RW        0       */
+  DmaIeAbnormal          = DmaIntAbnormal   ,   /* Abnormal interrupt enable               RW        0       */
+
+  DmaIeEarlyRx           = DmaIntEarlyRx    ,   /* Early receive interrupt enable          RW        0       */
+  DmaIeBusError          = DmaIntBusError   ,   /* Fatal bus error enable                  RW        0       */
+  DmaIeEarlyTx           = DmaIntEarlyTx    ,   /* Early transmit interrupt enable         RW        0       */
+  DmaIeRxStopped         = DmaIntRxStopped  ,   /* Receive process stopped enable          RW        0       */
+  DmaIeRxNoBuffer        = DmaIntRxNoBuffer ,   /* Receive buffer unavailable enable       RW        0       */
+  DmaIeRxCompleted       = DmaIntRxCompleted,   /* Completion of frame reception enable    RW        0       */
+  DmaIeTxUnderflow       = DmaIntTxUnderflow,   /* Transmit underflow enable               RW        0       */
+  DmaIeTxNoBuffer        = DmaIntTxNoBuffer ,   /* Transmit buffer unavailable enable      RW        0       */
+  DmaIeTxStopped         = DmaIntTxStopped  ,   /* Transmit process stopped enable         RW        0       */
+  DmaIeTxCompleted       = DmaIntTxCompleted,   /* Transmit completed enable               RW        0       */
+};
+
+/**********************************************************
+ * DMA Engine descriptors
+ **********************************************************/
+
+enum DmaDescriptorStatus    /* status word of DMA descriptor */
+{
+  DescOwnByDma          = 0x80000000,   /* Descriptor is owned by DMA engine  */
+  DescOwnByCPU          = 0x0,          /* Descriptor is owned by CPU  */
+
+  DescFilteringFail	= 0x40000000,   /* Filtering fail*/
+
+  DescFrameLengthMask   = 0x3FFF0000,   /* Receive descriptor frame length */
+  DescFrameLengthShift  = 16,
+
+  DescError             = 0x00008000,   /* Error summary bit  - OR of the following bits:    v  */
+
+  DescRxTruncated       = 0x00004000,   /* Rx - no more descriptors for receive frame        E  */
+  DescLengthError	= 0x00001000,   /* Rx - length doesn't match 			     E	*/
+  DescRxDamaged         = 0x00000800,   /* Rx - frame was damaged by a collision             E  */
+  DescRxMulticast       = 0x00000400,   /* Rx - received frame is multicast                     */
+  DescRxFirst           = 0x00000200,   /* Rx - first descriptor of the frame                   */
+  DescRxLast            = 0x00000100,   /* Rx - last descriptor of the frame                    */
+  DescRxLongFrame       = 0x00000080,   /* Rx - frame is longer than 1518 bytes              E  */
+  DescRxCollision       = 0x00000040,   /* Rx - frame was damaged by a collision             E  */
+  DescRxFrameEther      = 0x00000020,   /* Rx - Frame type - Ethernet, otherwise 802.3          */
+  DescRxMiiError        = 0x00000008,   /* Rx - error reported by MII interface              E  */
+  DescRxDribbling       = 0x00000004,   /* Rx - frame contains noninteger multiple of 8 bits    */
+  DescRxCrc             = 0x00000002,   /* Rx - CRC error                                    E  */
+
+  DescTxTimeout         = 0x00004000,   /* Tx - Transmit jabber timeout                      E  */
+  DescTxLostCarrier     = 0x00000800,   /* Tx - carrier lost during tramsmission             E  */
+  DescTxNoCarrier       = 0x00000400,   /* Tx - no carrier signal from the tranceiver        E  */
+  DescTxLateCollision   = 0x00000200,   /* Tx - transmission aborted due to collision        E  */
+  DescTxExcCollisions   = 0x00000100,   /* Tx - transmission aborted after 16 collisions     E  */
+  DescTxHeartbeatFail   = 0x00000080,   /* Tx - heartbeat collision check failure               */
+  DescTxCollMask        = 0x00000078,   /* Tx - Collision count                                 */
+  DescTxCollShift       = 3,
+  DescTxExcDeferral     = 0x00000004,   /* Tx - excessive deferral                           E  */
+  DescTxUnderflow       = 0x00000002,   /* Tx - late data arrival from the memory            E  */
+  DescTxDeferred        = 0x00000001,   /* Tx - frame transmision deferred                      */
+};
+
+enum DmaDescriptorLength    /* length word of DMA descriptor */
+{
+  DescTxIntEnable       = 0x80000000,   /* Tx - interrupt on completion                         */
+  DescTxLast            = 0x40000000,   /* Tx - Last segment of the frame                       */
+  DescTxFirst           = 0x20000000,   /* Tx - First segment of the frame                      */
+  DescTxDisableCrc      = 0x04000000,   /* Tx - Add CRC disabled (first segment only)           */
+
+  DescEndOfRing         = 0x02000000,   /* End of descriptors ring                              */
+  DescChain             = 0x01000000,   /* Second buffer address is chain address               */
+
+  DescSize2Mask         = 0x003FF800,   /* Buffer 2 size                                        */
+  DescSize2Shift        = 11,
+  DescSize1Mask         = 0x000007FF,   /* Buffer 1 size                                        */
+  DescSize1Shift        = 0,
+};
+
+/**********************************************************
+ * Initial register values
+ **********************************************************/
+
+enum InitialRegisters
+{
+  MacControlInitFdx       /* Full-duplex mode with perfect filter on */
+                          = MacFilterOn           | MacLittleEndian         | MacHeartBeatOn      | MacSelectMii
+                          | MacEnableRxOwn        | MacLoopbackOff          | MacFullDuplex       | MacMulticastFilterOn
+                          | MacPromiscuousModeOff | MacFilterNormal         | MacBadFramesDisable | MacPerfectFilterOn
+                          | MacHashFilterOff      | MacLateCollisionOff     | MacBroadcastEnable  | MacRetryEnable
+                          | MacPadStripDisable    | MacDeferralCheckDisable | MacTxEnable         | MacRxEnable,
+
+  MacFlowControlInitFdx   /* Full-duplex mode */
+                          = MacControlFrameDisable | MacFlowControlEnable,
+
+  MacControlInitHdx       /* Half-duplex mode with perfect filter on */
+                          = MacFilterOn           | MacLittleEndian         | MacHeartBeatOn      | MacSelectMii
+                          | MacDisableRxOwn       | MacLoopbackOff          | MacHalfDuplex       | MacMulticastFilterOn 
+                          | MacPromiscuousModeOff | MacFilterNormal         | MacBadFramesDisable | MacPerfectFilterOn
+                          | MacHashFilterOff      | MacLateCollisionOff     | MacBroadcastEnable  | MacRetryEnable
+                          | MacPadStripDisable    | MacDeferralCheckDisable | MacTxEnable         | MacRxEnable,
+
+  MacFlowControlInitHdx   /* Half-duplex mode */
+                          = MacControlFrameDisable | MacFlowControlDisable,
+
+  DmaBusModeInit          /* Little-endian mode */
+                          = DmaLittleEndianDesc   | DmaBurstLength8         | DmaLittleEndianData | DmaDescriptorSkip2
+                          | DmaReceivePriorityOn  | DmaResetOff,
+
+  DmaControlInit100       /* 100 Mb/s mode */
+                          = DmaStoreAndForward,
+
+  DmaControlInit10        /* 10 Mb/s mode */
+                          = DmaStoreAndForward,
+
+                          /* Interrupt groups */
+  DmaIntErrorMask         = DmaIntBusError,           /* Error */
+  DmaIntRxAbnMask         = DmaIntRxNoBuffer,         /* receiver abnormal interrupt */
+  DmaIntRxNormMask        = DmaIntRxCompleted,        /* receiver normal interrupt   */
+  DmaIntRxStoppedMask     = DmaIntRxStopped,          /* receiver stopped */
+  DmaIntTxAbnMask         = DmaIntTxUnderflow,        /* transmitter abnormal interrupt */
+  DmaIntTxNormMask        = DmaIntTxCompleted,        /* transmitter normal interrupt */
+  DmaIntTxStoppedMask     = DmaIntTxStopped,          /* receiver stopped */
+
+  DmaIntEnable            = DmaIeNormal | DmaIeAbnormal
+                          | DmaIntErrorMask
+                          | DmaIntRxAbnMask | DmaIntRxNormMask | DmaIntRxStoppedMask
+                          | DmaIntTxAbnMask | DmaIntTxNormMask | DmaIntTxStoppedMask,
+
+  DmaIntDisable           = 0,
+};
+
+/* some status test functions */
+static inline int em86xx_dma_rx_valid( u32 Status )
+{
+  return ( (Status & DescError) == 0 )      /* no errors, whole frame is in the buffer */
+      && ( (Status & DescRxFirst) != 0 )
+      && ( (Status & DescRxLast) != 0 );
+}
+
+static inline u32 em86xx_dma_rx_length( u32 Status )
+{
+  return (Status & DescFrameLengthMask) >> DescFrameLengthShift;
+}
+
+static inline int em86xx_dma_rx_collisions( u32 Status )
+{
+  if( Status & (DescRxDamaged | DescRxCollision) ) return 1;
+    return 0;
+}
+
+static inline int em86xx_dma_rx_crc( u32 Status )
+{
+  if( Status & DescRxCrc ) return 1;
+    return 0;
+}
+
+static inline int em86xx_dma_tx_valid( u32 Status )   /* Test the status word if the descriptor is valid */
+{
+  return ( (Status & DescError) == 0 );
+}
+
+static inline int em86xx_dma_tx_collisions( u32 Status )
+{
+  return (Status & DescTxCollMask) >> DescTxCollShift;
+}
+
+static inline int em86xx_dma_tx_aborted( u32 Status )
+{
+  if( Status & (DescTxLateCollision | DescTxExcCollisions )) return 1;
+    return 0;
+}
+
+static inline int em86xx_dma_tx_carrier( u32 Status )
+{
+  if( Status & (DescTxLostCarrier | DescTxNoCarrier )) return 1;
+    return 0;
+}
+
+static inline int em86xx_rdesc_owned_by_host(volatile struct em86xx_desc *desc)
+{
+  return((desc->desc0 & 0x80000000) ? 0 : 1);
+}
+
+static inline int em86xx_rdesc_last_desc(volatile struct em86xx_desc *desc)
+{
+  return(desc->desc0 & 0x00000100);
+}
+
+static inline int em86xx_rdesc_first_desc(volatile struct em86xx_desc *desc)
+{
+  return(desc->desc0 & 0x00000200);
+}
+
+static inline unsigned long em86xx_rdesc_frame_len(volatile struct em86xx_desc *desc)
+{
+  return((desc->desc0 & 0x3fff0000) >> 16);
+}
+
+static inline int em86xx_tdesc_owned_by_host(volatile struct em86xx_desc *desc)
+{
+  return((desc->desc0 & 0x80000000) ? 0 : 1);
+}
+
+static u32 __inline__ em86xx_read_reg( u32 Reg )
+{
+#ifdef CONFIG_TANGOX
+	u32 data = gbus_read_reg32(Reg);
+	u32 tmp = 0;
+	extern int is_tango2_es6(void);
+	if (is_tango2_es6()) 
+		tmp = gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+#else
+        u32 data = __raw_readl(Reg);
+#endif
+
+//        printk("read data=0x%08x from addr=0x%08x\n", data, Reg);
+        return data;
+}
+
+static u32 em86xx_read_mac_reg(u32 Reg)
+{
+	return em86xx_read_reg( EM86XX_ETHMAC_BASE + Reg );
+}
+
+static u32 em86xx_read_dma_reg(u32 Reg)
+{
+	return em86xx_read_reg( EM86XX_ETHDMA_BASE + Reg );
+}
+
+static void __inline__ em86xx_write_reg( u32 Reg, u32 Data )
+{
+//       printk("write data=0x%08x to addr=0x%08x\n", Data, Reg);
+#ifdef CONFIG_TANGOX
+        gbus_write_reg32(Reg, Data); iob();
+#else
+        __raw_writel(Data,Reg);
+#endif
+}
+
+static void em86xx_write_mac_reg(u32 Reg, u32 Data)
+{
+	em86xx_write_reg( EM86XX_ETHMAC_BASE + Reg, Data );
+}
+
+static void em86xx_write_dma_reg(u32 Reg, u32 Data)
+{
+	em86xx_write_reg( EM86XX_ETHDMA_BASE + Reg, Data );
+}
+
+
+static void __inline__ em86xx_set_reg( u32 reg, u32 data )
+{
+
+#ifdef CONFIG_TANGOX
+	data |= gbus_read_reg32(reg);
+	gbus_write_reg32(reg, data); iob();
+#else
+	data |= __raw_readl(reg);
+	__raw_writel(data, reg);
+#endif
+}
+
+static void __inline__ em86xx_clear_reg( u32 reg, u32 data )
+{
+#ifdef CONFIG_TANGOX
+	gbus_write_reg32(reg, (gbus_read_reg32(reg) & (~data))); iob();
+#else
+	__raw_writel(( __raw_readl(reg) & (~data)), reg);
+#endif
+}
+
+
+/* There are two registers, MII address (EM86XX_MIIAR_REG) and 
+   MII data (EM86XX_MIIDR_REG), for accessing PHY registers.
+
+   In order to access  mii register data, one need to program the
+   MII address and wait till MII not busy.
+   
+   MII address register description:
+	bit 31-16	reserved
+	bit 15-11	PHY address
+	bit 10-6	MII Register one want to access 
+	bit 1		0:MII read 1:MII write
+	bit 0		0:MII not busy 1:MII busy
+*/
+static inline u16 em86xx_mii_read(int phy_addr, u8 Reg )
+{
+        u32 addr;
+        u16 data;
+
+#ifdef CONFIG_TANGOX
+	u32 count = 100;
+#endif
+
+        addr = ((phy_addr << MiiDevShift) & MiiDevMask) |
+        	((Reg << MiiRegShift) & MiiRegMask);
+        em86xx_write_reg(EM86XX_MIIAR_REG, addr );
+
+#ifdef CONFIG_TANGOX
+	do{
+		udelay(1);
+		count --;
+		if(count == 0) break;
+	} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#else
+        do{} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#endif
+
+        data = em86xx_read_reg(EM86XX_MIIDR_REG ) & 0xFFFF;
+/* 	printk("em86xx_mii_read: addr %d - reg %d - value: %04x\n", */
+/* 	       phy_addr, Reg, data); */
+        return data;
+}
+
+#ifndef BOOTLOADER
+static void em86xx_mii_write(int phy_addr, u8 Reg, u16 Data )
+{
+        u32 addr;
+
+#ifdef CONFIG_TANGOX
+	u32 count = 100;
+#endif
+
+        em86xx_write_reg( EM86XX_MIIDR_REG, Data );
+        addr = ((phy_addr << MiiDevShift) & MiiDevMask) |
+               ((Reg << MiiRegShift) & MiiRegMask) |
+                 MiiWrite;
+
+        em86xx_write_reg( EM86XX_MIIAR_REG, addr );
+
+#ifdef CONFIG_TANGOX
+	do{
+		udelay(1);
+		count --;
+		if(count == 0) break;
+	} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#else
+        do{} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#endif
+
+/* 	printk("em86xx_write_read: addr %d - reg %d - data: %04x\n", */
+/* 	       phy_addr, Reg, Data); */
+
+}
+#endif
+#if 0 /* for debug purpose*/
+static void mac_dump(void)
+{
+	int i;
+	u32 data, addr;
+	addr = 0;
+	printk("*********************** MAC Registers *************************\n");
+        for(i = 0; i < 12; i++) {
+		data = em86xx_read_mac_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+}
+static void dma_dump(void)
+{
+	int i;
+	u32 data, addr;
+	addr = 0;
+	printk("*********************** DMA Registers *************************\n");
+        for(i = 0; i < 24; i++) {
+		data = em86xx_read_dma_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+
+}
+static void rx_desc_dump(void)
+{
+	int i;
+	u32 data, addr;
+	addr = em86xx_read_reg(EM86XX_RLBAR_REG);
+	printk("*********************** RX DESC *************************\n");
+        for(i = 0; i < 128; i++) {
+		data = em86xx_read_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+}
+static void tx_desc_dump(void) 
+{
+	int i;
+	u32 data, addr;
+	addr = em86xx_read_reg(EM86XX_TLBAR_REG);
+	printk("*********************** TX DESC *************************\n");
+        for(i = 0; i < 128; i++) {
+		data = em86xx_read_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+}
+#endif /* #if 0*/
+#endif /* !__ASSEMBLY__ */
+#endif /* __EM86XX_ETH_H__ */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/tangox_enet.c linux-2.6.22.19/drivers/net/tangox_enet.c
--- linux-2.6.22.19.ref/drivers/net/tangox_enet.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/drivers/net/tangox_enet.c	2009-03-26 19:02:01.000000000 -0700
@@ -0,0 +1,1650 @@
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * Driver for tangox SMP864x/SMP865x builtin Ethernet Mac.
+ * The Driver makes use of the tango2_enet framework
+ * written by Maxime Bizon.
+ *
+ * This driver uses NAPI and generic linux MII support.
+ *
+ * Tx path limits the number of interrupt by reclaiming sent buffer in
+ * a timer.  In case  the tx starts  to go  faster, it will  switch to
+ * interrupt mode.
+ *
+ * Note that OOM condition is not handled correctly, and can leave the
+ * rx path  in bad  shape. down/up the  interface should make  it work
+ * again though. But anyway, it's not likely to happen.
+ *
+ * Copyright (C) 2005 Maxime Bizon <mbizon@freebox.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+
+#include "tangox_enet.h"
+
+#define PFX	"tangox_enet: "
+
+//#define ETH_DEBUG 1 
+#ifdef ETH_DEBUG
+#define DBG	printk
+#else
+static void inline DBG(const char *x, ...) { ; }
+#endif /* ETH_DEBUG */
+
+/* for multicast support */
+#define ENABLE_MULTICAST
+
+/* for tx desc chaining*/
+#undef ENABLE_TX_CHAINING
+
+/* how many MAC cores we have */
+#define NUM_MAC_CORES	2
+
+struct eth_mac_core {
+	unsigned long enet_mac_base;
+	int phy_id;
+	const int irq;
+	struct net_device *gdev;
+	const char *name;
+};
+
+static struct eth_mac_core eth_mac_cores[NUM_MAC_CORES] = {
+	{ REG_BASE_host_interface + 0x6000, -1, ENET_IRQ0, NULL, "tangox_enet0" },
+	{ REG_BASE_host_interface + 0x6800, -1, ENET_IRQ1, NULL, "tangox_enet1" }
+};
+
+static int mac_cores = 3; /* enabled both cores */
+static int phyid_0 = -1;
+static int phyid_1 = -1;
+
+static __inline void enet_start_rx(struct tangox_enet_priv *priv);
+static __inline void enet_stop_rx(struct tangox_enet_priv *priv);
+
+/*
+ * mdio read/write callback, can run from userspace or timer
+ */
+
+#define MDIO_TIMEOUT	1000
+
+static __inline int enet_mdio_read(struct net_device *dev, int phy_id,
+				   int location)
+{
+	int val, i;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (enet_readl(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	val = MIIAR_ADDR(phy_id) | MIIAR_REG(location);
+	enet_writel(ENET_MDIO_CMD1(priv->enet_mac_base), val);
+
+	udelay(10);
+
+	enet_writel(ENET_MDIO_CMD1(priv->enet_mac_base), val | MDIO_CMD_GO);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (enet_readl(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	val = enet_readl(ENET_MDIO_STS1(priv->enet_mac_base));
+	if (val & MDIO_STS_ERR)
+		return -1;
+
+	return val & 0xffff;
+
+err_out:
+	return -1;
+}
+
+static void enet_mdio_write(struct net_device *dev, int phy_id,
+				     int location, int val)
+{
+	int i, tmp;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (enet_readl(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	tmp = MIIAR_DATA(val) | MIIAR_ADDR(phy_id) | MIIAR_REG(location);
+	enet_writel(ENET_MDIO_CMD1(priv->enet_mac_base), tmp);
+
+	udelay(10);
+
+	enet_writel(ENET_MDIO_CMD1(priv->enet_mac_base), tmp | MDIO_CMD_WR);
+
+	udelay(10);
+
+	enet_writel(ENET_MDIO_CMD1(priv->enet_mac_base), tmp | MDIO_CMD_WR | MDIO_CMD_GO);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (enet_readl(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	return;
+
+err_out:
+	return;
+}
+
+/* statistic counter read and write functions
+ * 44 counters are included for tracking 
+ * occurences of frame status evernts.
+ */
+static unsigned long enet_stat_read(struct net_device *dev, unsigned char index)
+{
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+	enet_writeb(ENET_STAT_INDEX(priv->enet_mac_base), index);
+	return enet_readl(ENET_STAT_DATA1(priv->enet_mac_base));
+}
+
+static void enet_stat_write(struct net_device *dev, unsigned long val, unsigned char index)
+{
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+	enet_writeb(ENET_STAT_INDEX(priv->enet_mac_base), index);
+	enet_writel(ENET_STAT_DATA1(priv->enet_mac_base), val);
+}
+
+static __inline int enet_rx_error(unsigned long report)
+{
+	if (report & (RX_FCS_ERR | RX_FRAME_LEN_ERROR | 
+#ifndef ENABLE_MULTICAST
+		RX_MULTICAST_PKT |
+#endif
+		RX_LENGTH_ERR | RX_LATE_COLLISION | 
+		RX_FIFO_OVERRUN | RX_RUNT_PKT)) 
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * rx poll func, called by network core
+ */
+static int enet_poll(struct net_device *dev, int *budget)
+{
+	struct tangox_enet_priv *priv;
+	volatile struct enet_desc *rx, *rx1;
+	int limit, received;
+	unsigned int rx_eoc;
+
+	priv = netdev_priv(dev);
+	rx_eoc = priv->rx_eoc;
+
+	/* calculate how many rx packet we are allowed to fetch */
+	limit = *budget;
+	if (*budget > dev->quota)
+		limit = dev->quota;
+	received = 0;
+
+	/* process no more than "limit" done rx */
+	while (limit > 0) {
+		struct sk_buff *skb;
+		volatile u32 *r_addr;
+		u32 report_cache;
+		unsigned int len = 0;
+		int pkt_dropped = 0;
+
+		rx = &priv->rx_descs[priv->last_rx_desc];
+
+		/* we need multiple read on this volatile, avoid
+		 * memory access at each time */
+		r_addr = (volatile u32 *)KSEG1ADDR((u32)&(priv->rx_report[priv->last_rx_desc]));
+		report_cache = __raw_readl(r_addr);
+
+#ifdef ETH_DEBUG
+		if (rx->config & DESC_EOC) {
+			/* should not happen */
+			printk("%s i=0x%x rx=0x%x report=0x%x config=0x%x limit=0x%x\n", 
+				__FUNCTION__, priv->last_rx_desc, rx, report_cache, rx->config, limit);
+		}
+#endif
+		if (report_cache == 0){ 
+			uint32_t *next_r_addr;
+			uint32_t next_report_cache;
+			next_r_addr = (uint32_t *)KSEG1ADDR((u32)&(priv->rx_report[(priv->last_rx_desc+1)%RX_DESC_COUNT]));
+			next_report_cache = __raw_readl(next_r_addr);
+
+			/*check see if next one on error*/
+			if(!enet_rx_error(next_report_cache))
+				break;
+		}
+
+		--limit;
+
+		if (likely((skb = priv->rx_skbs[priv->last_rx_desc]) != NULL)) {
+
+			len = RX_BYTES_TRANSFERRED(report_cache);
+			if((report_cache ==0) ||enet_rx_error(report_cache)){
+
+#ifndef ENABLE_MULTICAST
+				if (report_cache & RX_MULTICAST_PKT){ 
+					DBG("%s RX_MULTICAST_PKT report=0x%x\n", __FUNCTION__, report_cache);				
+					priv->stats.rx_length_errors++;
+				}
+#endif
+				if (report_cache & RX_FCS_ERR) {
+					DBG("%s RX_FCS_ERR report=0x%x\n", __FUNCTION__, report_cache);				
+					priv->stats.rx_crc_errors++;
+				}
+
+				if (report_cache & RX_LATE_COLLISION){ 
+					DBG("%s RX_LATE_COLLSION report=0x%x\n", __FUNCTION__, report_cache);				
+				}
+
+				if (report_cache &  RX_FIFO_OVERRUN ){ 
+					DBG("%s RX_FIFO_OVERRUN report=0x%x\n", __FUNCTION__, report_cache);				
+				}
+
+				if (report_cache & RX_RUNT_PKT) {
+					DBG("%s RX_RUNT_PKT report=0x%x\n", __FUNCTION__, report_cache);				
+				}
+
+				if (report_cache & (RX_FRAME_LEN_ERROR | RX_LENGTH_ERR) ||
+				     len > RX_BUF_SIZE) {
+					priv->stats.rx_length_errors++;
+				}
+
+				priv->stats.rx_errors++;
+				pkt_dropped = 1;
+				goto done_checking;
+
+			} else {
+
+				/* ok, seems  valid, adjust skb  proto and len
+				 * and give it to kernel */
+				skb->dev = dev;
+				skb_put(skb, len);
+				skb->protocol = eth_type_trans(skb, dev);
+				netif_receive_skb(skb);
+#ifdef ETH_DEBUG
+				if(len > 0){
+					int i;
+					DBG("-----received data------\n");
+					for (i=0; i< len; i++){
+						if(i%16==0 && i>0)
+							DBG("\n");
+						DBG("%02x ", skb->data[i]);					
+					}
+					DBG("\n--------------------------\n");
+				}
+#endif
+			}
+done_checking:
+			rx_eoc = priv->last_rx_desc;
+
+			if (pkt_dropped)
+				goto rearm;
+
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += len;
+			dev->last_rx = jiffies;
+			priv->rx_skbs[priv->last_rx_desc] = NULL;
+			/* we will re-alloc an skb for this slot */
+		}
+
+		if (unlikely((skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE)) == NULL)) {
+			printk("%s: failed to allocation sk_buff.\n", priv->name);
+			rx->config = DESC_BTS(2) | DESC_EOF/* | DESC_ID*/;
+			mb();
+			break;
+		}
+
+		rx->config = RX_BUF_SIZE | DESC_BTS(2) | DESC_EOF/* | DESC_ID*/;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->s_addr = PHYSADDR((void*)(skb->data));
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[priv->last_rx_desc] = skb;
+
+rearm:
+		/* rearm descriptor */
+		__raw_writel(0, r_addr);
+		priv->last_rx_desc++;
+		priv->last_rx_desc %= RX_DESC_COUNT;
+		received++;
+
+	}
+
+	if (received != 0) {
+		rx = &priv->rx_descs[rx_eoc];
+		rx->config |= DESC_EOC;
+		mb();
+		rx1 = &priv->rx_descs[priv->rx_eoc];
+		rx1->config &= ~DESC_EOC; 
+		mb();
+		priv->rx_eoc = rx_eoc;
+	
+		dev->quota -= received;
+		*budget -= received;
+	}
+
+	enet_start_rx(priv);
+
+	if (limit <= 0) {
+		/* breaked, but there is still work to do */
+		return 1;
+	}
+
+	netif_rx_complete(dev);
+	return 0;
+}
+
+/*
+ * tx request callback
+ */
+static int enet_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	volatile struct enet_desc *tx=NULL, *ptx=NULL;
+	unsigned long tconfig_cache;
+	unsigned long val = 0;
+	volatile u32 *r_addr;
+	int len = 0;
+	int tx_busy = 0;
+	unsigned char *txbuf;
+
+	priv = netdev_priv(dev);
+	spin_lock(&priv->tx_lock);
+
+	val = enet_readl(ENET_TXC_CR(priv->enet_mac_base)) & 0xffff;
+#ifndef ENABLE_TX_CHAINING
+#define MAX_TX_TIMEOUT	100	/* usec */
+	for (len = 0; len < MAX_TX_TIMEOUT; len++) {
+		val = enet_readl(ENET_TXC_CR(priv->enet_mac_base)) & 0xffff;
+		if (val & TCR_EN)
+			udelay(1);
+		else
+			break;
+	}
+	if (len >= MAX_TX_TIMEOUT) {
+		priv->stats.tx_dropped++;
+		spin_unlock(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+#else
+	if (val & TCR_EN){ 
+		//BUG_ON(skb == NULL);
+		tx_busy = 1;
+		if (priv->pending_tx < 0)
+			priv->pending_tx = priv->next_tx_desc;
+	} 
+
+	if (tx_busy && (priv->pending_tx >= 0) && (priv->pending_tx_cnt >= (TX_DESC_COUNT -1))) {
+		DBG(KERN_WARNING PFX "no more tx desc can be scheduled in pending queue.\n");
+		netif_stop_queue(dev);
+		spin_unlock(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+		
+	if (skb == NULL) {
+		unsigned int last_tx;		
+		last_tx = (priv->next_tx_desc - 1 + TX_DESC_COUNT) % TX_DESC_COUNT;
+		tx = &priv->tx_descs[last_tx];
+		tx->config |= DESC_EOC;
+		priv->tx_eoc = last_tx;
+		mb();
+		goto tx_pending;
+	}
+#endif
+	len = skb->len;
+	tx = &priv->tx_descs[priv->next_tx_desc];
+
+	/* fill the tx desc with this skb address */
+	tconfig_cache = 0;
+	tconfig_cache |= DESC_BTS(2);
+	tconfig_cache |= DESC_EOF;
+	tconfig_cache |= len; 
+
+	if (((unsigned long)(skb->data) & 0x7) != 0) { /* not align by 8 bytes */
+		txbuf = priv->tx_bufs[priv->next_tx_desc];
+		memcpy(txbuf, skb->data, len); 
+		dma_cache_wback((unsigned long)txbuf, len);
+		tx->s_addr = PHYSADDR((void *)txbuf);
+	} else {
+		dma_cache_wback((unsigned long)skb->data, len);
+		tx->s_addr = PHYSADDR(skb->data);
+	}
+
+	if (tx_busy != 0) {
+		tx->n_addr = PHYSADDR((void *)&(priv->tx_descs[(priv->next_tx_desc + 1) % TX_DESC_COUNT]));
+	} else {
+		tx->n_addr = 0;
+		tconfig_cache |= DESC_EOC;
+		priv->tx_eoc = priv->next_tx_desc;
+	}
+	tx->config = tconfig_cache;
+
+	/* keep a pointer to it for later and give it to dma  */
+	priv->tx_skbs[priv->next_tx_desc] = skb;
+
+	r_addr = (volatile u32 *)KSEG1ADDR((u32)(&(priv->tx_report[priv->next_tx_desc])));
+	__raw_writel(0, r_addr);
+	priv->next_tx_desc++;
+	priv->next_tx_desc %= TX_DESC_COUNT;
+
+#ifdef ETH_DEBUG
+	{
+	int i;			
+ 	for(i=0; i<len; i++){
+		if(i%16==0 && i>0)
+			DBG("\n");
+		DBG("%02x ", txbuf[i] & 0xff);
+	}
+	DBG("\n");
+
+	DBG("DESC Mode:  TXC_CR=0x%x  desc_addr=0x%x s_addr=0x%x n_addr=0x%x r_addr=0x%x config=0x%x\n",
+			enet_readl(ENET_TXC_CR(priv->enet_mac_base)), tx,
+			tx->s_addr, tx->n_addr,
+			tx->r_addr, tx->config); 
+	}
+#endif
+
+tx_pending:
+	if (tx_busy == 0) {
+		if (priv->pending_tx >= 0) {
+			ptx = &priv->tx_descs[priv->pending_tx];
+			len = ptx->config & 0xffff;
+
+			enet_writel(ENET_TX_DESC_ADDR(priv->enet_mac_base), PHYSADDR((void *)ptx));
+			priv->reclaim_limit = priv->pending_tx;
+			priv->pending_tx = -1;
+		} else {
+			priv->reclaim_limit = (priv->next_tx_desc - 1 + TX_DESC_COUNT) % TX_DESC_COUNT;
+			enet_writel(ENET_TX_DESC_ADDR(priv->enet_mac_base), PHYSADDR((void *)tx));
+		}
+
+		enet_writel(ENET_TX_SAR(priv->enet_mac_base), 0);
+		enet_writel(ENET_TX_REPORT_ADDR(priv->enet_mac_base), 0);
+
+		/* kick tx dma in case it was suspended */
+		val |= TCR_EN; 
+		val |= TCR_BTS(2); 
+		val |= (len << 16); 
+		enet_writel(ENET_TXC_CR(priv->enet_mac_base), val);
+
+		/* no pending at this stage*/
+		priv->pending_tx_cnt = 0;
+	} else 
+		priv->pending_tx_cnt++;
+
+	/* if next tx descriptor is not  clean, then we have to stop
+	 * queue */
+	if (unlikely(--priv->free_tx_desc_count == 0))
+		netif_stop_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+
+	return NETDEV_TX_OK;
+}
+
+/*
+ * tx reclaim func. Called by timer or tx done tasklet to reclaim sent
+ * buffers.
+ */
+static void enet_tx_reclaim(unsigned long data)
+{
+	struct net_device *dev;
+	struct tangox_enet_priv *priv;
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	spin_lock(&priv->tx_lock);
+
+	while (priv->free_tx_desc_count < TX_DESC_COUNT) {
+		volatile u32 *r_addr;
+		u32 report_cache;
+		struct sk_buff *skb;
+
+		r_addr = (volatile u32 *)KSEG1ADDR((u32)(&(priv->tx_report[priv->dirty_tx_desc])));
+		report_cache = __raw_readl(r_addr);
+		if (priv->dirty_tx_desc == priv->reclaim_limit)
+			break;
+
+		skb = priv->tx_skbs[priv->dirty_tx_desc];
+		priv->stats.tx_packets++;
+		if (skb) {
+			/* check  for  transmission  errors and  update  stats
+			 * accordingly */
+			if (report_cache & (TX_FIRST_DEFERRAL | TX_LATE_COLLISION |
+					    TX_PACKET_DROPPED | TX_FIFO_UNDERRUN)) {
+				priv->stats.tx_errors++;
+			} else {
+				priv->stats.tx_bytes += skb->len;
+			}
+			dev_kfree_skb(skb);
+		}
+		priv->tx_skbs[priv->dirty_tx_desc] = NULL;
+		priv->dirty_tx_desc++;
+		priv->dirty_tx_desc %= TX_DESC_COUNT;
+		priv->free_tx_desc_count++;
+		__raw_writel(0, r_addr);
+	}
+
+	if (priv->free_tx_desc_count != 0 && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+
+#ifdef ENABLE_TX_CHAINING
+	/* to rearm the xmit for some cases */
+	if (priv->pending_tx >= 0) {
+		unsigned int idx = (priv->dirty_tx_desc + priv->pending_tx_cnt) % TX_DESC_COUNT;
+		if (priv->pending_tx == idx)
+			enet_xmit(NULL, dev);
+	}
+#endif
+}
+
+/*
+ * our  irq handler, just  ack it  and schedule  the right  tasklet to
+ * handle this
+ */
+static irqreturn_t enet_isr(int irq, void *dev_id)
+{
+	struct net_device *dev;
+	struct tangox_enet_priv *priv;
+	unsigned long val = 0;
+
+	dev = (struct net_device *)dev_id;
+	priv = netdev_priv(dev);
+
+	/* tx interrupt */
+	if ((val = enet_readl(ENET_TXC_SR(priv->enet_mac_base))) != 0) {
+		enet_writel(ENET_TXC_SR(priv->enet_mac_base), 0xff);
+		//if (likely(val & TSR_DI)) {
+		if (likely(val & TSR_TI)) {
+			tasklet_schedule(&priv->tx_reclaim_tasklet);
+		}
+		if (unlikely(val & TSR_DE))
+			printk("TX DMA error\n");
+		if (unlikely(val & TSR_TO))
+			printk("TX FIFO overflow\n");
+	}
+	/* rx interrupt */
+	if ((val = enet_readl(ENET_RXC_SR(priv->enet_mac_base))) != 0) {
+		enet_writel(ENET_RXC_SR(priv->enet_mac_base), 0xff);
+		if (likely(val & RSR_RI)) {
+			if (netif_rx_schedule_prep(dev)) {
+				/*todo: disable rx interrupt */
+				/*avoid reentering */
+				enet_writel(ENET_RXC_SR(priv->enet_mac_base), 0xff);
+				__netif_rx_schedule(dev);
+			}
+		}
+
+		if (unlikely(val & RSR_DI)) 
+			DBG("RX EOC\n");			
+		if (unlikely(val & RSR_DE))
+			DBG("RX DMA error\n");
+		if (unlikely(val & RSR_RO))
+			DBG("RX FIFO overflow\n");
+	}
+
+ 	/* wake on lan */
+ 	if ((val = enet_readb(ENET_WAKEUP(priv->enet_mac_base))) == 1) {
+ 		/* clear sleeping mode */
+ 		enet_writeb(ENET_SLEEP_MODE(priv->enet_mac_base), 0);
+ 		/* clear wakeup mode */
+ 		enet_writeb(ENET_WAKEUP(priv->enet_mac_base), 0);
+ 	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * start/stop dma engine
+ */
+static __inline void enet_start_rx(struct tangox_enet_priv *priv)
+{
+	unsigned long val, flags;
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	val = enet_readl(ENET_RXC_CR(priv->enet_mac_base));
+	if(!(val & RCR_EN)){
+		val  |= RCR_EN;
+		enet_writel(ENET_RXC_CR(priv->enet_mac_base), val);
+	}
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+static __inline void enet_stop_rx(struct tangox_enet_priv *priv)
+{
+	unsigned long val, flags;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	/* stop  rx  dma */
+	val = enet_readl(ENET_RXC_CR(priv->enet_mac_base));
+	if((val & RCR_EN)){
+		val &= ~RCR_EN;
+		enet_writel(ENET_RXC_CR(priv->enet_mac_base), val);
+	}
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+static int enet_get_speed(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned int physr;
+	int speed = 100;
+
+	priv = netdev_priv(dev);
+	if(priv->rgmii == 0){
+		/*Realtek*/
+		physr = enet_mdio_read(dev, priv->mii.phy_id, MII_PHYADDR);
+		switch(physr & 0x3){
+		case 1:
+			speed = 100;
+			break;
+		case 2:
+			speed = 10;
+			break;
+		default:			
+			speed = 0;
+			break;
+		}
+		return speed;
+	}
+	/* Vitesse */
+	physr = enet_mdio_read(dev, priv->mii.phy_id, MII_NCONFIG);
+	physr >>= 3;
+
+	switch(physr & 0x3){
+		case 0:	
+			speed = 10;
+			break;
+		case 1:
+			speed = 100;
+			break;
+		case 2:
+			speed = 1000;
+			break;
+		case 3:
+			speed = 0;
+			break;
+	}
+	return speed;
+}
+
+
+
+static int phy_autoneg(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int loop;
+	unsigned int val = 0;
+
+	priv = netdev_priv(dev);
+
+	/* reset phy */
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_BMCR);
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, val | BMCR_ANENABLE|BMCR_ANRESTART);
+	udelay(100);
+	loop = 10000;
+	while (loop) {
+	if (enet_mdio_read(dev, priv->mii.phy_id, MII_BMSR) &  BMSR_ANEGCOMPLETE)
+			break;
+
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR "%s: PHY autonegotiation does not complete...\n", priv->name);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+
+
+static void enet_mac_config(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned char val;
+	int speed;
+
+	priv = netdev_priv(dev);
+
+	if(priv->rgmii == 0) {
+		/* 100 baseT, realtek*/
+		val = enet_readb(ENET_MAC_MODE(priv->enet_mac_base));
+		if(val & (GMAC_MODE | RGMII_MODE)){
+			val &= ~(GMAC_MODE | RGMII_MODE);    /*disable Gigabit mode for now*/
+			//val |= /*LB_EN |*/ BST_EN;	     /*loopback off, burst on*/
+			enet_writeb(ENET_MAC_MODE(priv->enet_mac_base), val);
+		}
+		return;
+	}
+
+	/*set RGMII skew timing compensation enable */
+	/* This added 2ns delay to RX_CLK and TX_CLK*/
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_RESV1);
+	enet_mdio_write(dev, priv->mii.phy_id, MII_RESV1 , val | (1<<8));
+	
+	val = enet_readl(ENET_MAC_MODE(priv->enet_mac_base));
+	speed = enet_get_speed(dev);
+	if(speed == 1000 ){
+		if((val & RGMII_MODE) && (val & GMAC_MODE))
+			return; /* configured for gigabit */
+
+		val |= RGMII_MODE;	
+		val |= GMAC_MODE;
+		enet_writeb(ENET_MAC_MODE(priv->enet_mac_base), val);
+		//printk("set 1000mbps  val=0x%x\n",  val);
+	}else if(speed == 100){
+		if((val & RGMII_MODE) && !(val & GMAC_MODE))
+			return; /* configured for 100mbps*/
+		val |= RGMII_MODE;	
+		val &= ~GMAC_MODE;
+		enet_writeb(ENET_MAC_MODE(priv->enet_mac_base), val);
+    	//printk("set 100mbps  val=0x%x\n",  val);
+	}else /*TODO*/
+	;	//printk("set 10 mbps or other val=0x%x\n",  val);
+
+	/*set threshold for internal clock 0x1*/
+	enet_writeb(ENET_IC_THRESHOLD(priv->enet_mac_base), (speed==1000 ? 3:1));
+
+	/*set slot time  0x7f for 10/100Mbps*/
+	enet_writeb(ENET_SLOT_TIME(priv->enet_mac_base), (speed==1000 ? 0xff : 0x7f));
+
+	//phy_autoneg(dev);
+}
+
+
+/*
+ * reconfigure mac for new link state
+ */
+static void enet_link_reconfigure(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned char val;
+
+	priv = netdev_priv(dev);
+
+	/* reflect duplex status in dma register */
+	spin_lock(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MODE(priv->enet_mac_base));
+	if (priv->mii.full_duplex)
+		val &= ~HALF_DUPLEX;
+	else
+		val |= HALF_DUPLEX;
+	enet_writeb(ENET_MAC_MODE(priv->enet_mac_base), val);
+
+	enet_mac_config(dev);
+
+	spin_unlock(&priv->maccr_lock);
+}
+
+/*
+ * link check timer callback
+ */
+static void enet_link_check(unsigned long data)
+{
+	struct net_device *dev;
+	struct tangox_enet_priv *priv;
+	int ret, speed;
+	static int old_speed;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	/*check speed change in gigabit*/
+	speed = enet_get_speed(dev);
+
+	/* check for duplex change */
+	spin_lock(&priv->mii_lock);
+	ret = mii_check_media(&priv->mii, 1, 0);
+	spin_unlock(&priv->mii_lock);
+
+	if (ret || (speed && (speed !=old_speed)))
+		enet_link_reconfigure(dev);
+
+	if(speed)
+		old_speed = speed;
+
+	/* reschedule timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+}
+
+/*
+ * program given mac address in hw registers
+ */
+static int enet_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock = addr;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	/* to make it safe, we won't do this while running */
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+
+	/*set mac addr*/
+	enet_writeb(ENET_MAC_ADDR1(priv->enet_mac_base), dev->dev_addr[0]);
+	enet_writeb(ENET_MAC_ADDR2(priv->enet_mac_base), dev->dev_addr[1]);
+	enet_writeb(ENET_MAC_ADDR3(priv->enet_mac_base), dev->dev_addr[2]);
+	enet_writeb(ENET_MAC_ADDR4(priv->enet_mac_base), dev->dev_addr[3]);
+	enet_writeb(ENET_MAC_ADDR5(priv->enet_mac_base), dev->dev_addr[4]);
+	enet_writeb(ENET_MAC_ADDR6(priv->enet_mac_base), dev->dev_addr[5]);
+	
+	/* set unicast addr */
+	enet_writeb(ENET_UC_ADDR1(priv->enet_mac_base), dev->dev_addr[0]);
+	enet_writeb(ENET_UC_ADDR2(priv->enet_mac_base), dev->dev_addr[1]);
+	enet_writeb(ENET_UC_ADDR3(priv->enet_mac_base), dev->dev_addr[2]);
+	enet_writeb(ENET_UC_ADDR4(priv->enet_mac_base), dev->dev_addr[3]);
+	enet_writeb(ENET_UC_ADDR5(priv->enet_mac_base), dev->dev_addr[4]);
+	enet_writeb(ENET_UC_ADDR6(priv->enet_mac_base), dev->dev_addr[5]);
+
+	return 0;
+}
+
+/*
+ * update hash table to reflect new device multicast address list
+ */
+static void enet_set_multicast_list(struct net_device *dev)
+{
+#ifdef ENABLE_MULTICAST
+	struct tangox_enet_priv *priv;
+	struct dev_mc_list *mclist;
+	unsigned char val;
+	uint32_t mc_filter[2];
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* the link check timer might change RX control, we need to protect
+	 * against it */
+	spin_lock_bh(&priv->maccr_lock);
+	val = enet_readl(ENET_RX_CTL(priv->enet_mac_base));
+
+	if (dev->flags & IFF_PROMISC) {
+		val &= ~(RX_BC_DISABLE | RX_AF_EN);
+	} else {
+		val |= RX_AF_EN	;
+		/* if we want all multicast or if address count is too
+		 * high, don't try to compute hash value */
+		if (dev->mc_count > 64 || dev->flags & IFF_ALLMULTI) {
+			val &= ~(RX_BC_DISABLE | RX_AF_EN);
+		}
+	}
+
+	enet_writel(ENET_RX_CTL(priv->enet_mac_base), val);
+	spin_unlock_bh(&priv->maccr_lock);
+
+	/* we  don't  need  to  update  hash  table  if  we  pass  all
+	 * multicast */
+	if (!(val & RX_BC_DISABLE) && !(val & RX_AF_EN))
+		return;
+
+	/* clear internal multicast address table */
+	enet_writeb(ENET_MC_INIT(priv->enet_mac_base), 0x0);
+	while(enet_readb(ENET_MC_INIT(priv->enet_mac_base)));
+
+	mc_filter[0] = mc_filter[1] = 0;
+	mclist = dev->mc_list;
+
+	for (i = 0; i < dev->mc_count; i++) {
+		char *addr;
+
+		addr = mclist->dmi_addr;
+		mclist = mclist->next;
+		if (!(*addr & 1))
+			continue;
+
+		enet_writeb(ENET_MC_ADDR1(priv->enet_mac_base), addr[0]);
+		enet_writeb(ENET_MC_ADDR2(priv->enet_mac_base), addr[1]);
+		enet_writeb(ENET_MC_ADDR3(priv->enet_mac_base), addr[2]);
+		enet_writeb(ENET_MC_ADDR4(priv->enet_mac_base), addr[3]);
+		enet_writeb(ENET_MC_ADDR5(priv->enet_mac_base), addr[4]);
+		enet_writeb(ENET_MC_ADDR6(priv->enet_mac_base), addr[5]);
+		enet_writeb(ENET_MC_INIT(priv->enet_mac_base),	0xff);
+		while(enet_readb(ENET_MC_INIT(priv->enet_mac_base)));
+	}
+#endif
+}
+
+/*
+ * open callback
+ */
+static int enet_open(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned char val;
+
+	priv = netdev_priv(dev);
+
+	/* check link */
+	if (mii_check_media(&priv->mii, 1, 1))
+		enet_link_reconfigure(dev);
+
+	/* enable mac rx & tx */
+	val = enet_readb(ENET_RX_CTL(priv->enet_mac_base));
+	val |= RX_EN;
+	enet_writeb(ENET_RX_CTL(priv->enet_mac_base), val);
+
+	val = enet_readb(ENET_TX_CTL1(priv->enet_mac_base));
+	val |= TX_EN;
+	enet_writeb(ENET_TX_CTL1(priv->enet_mac_base), val);
+
+	/*
+	 * clear & enable interrupts, we want:
+	 * - receive complete
+	 * - transmit complete
+	 */
+	enet_writel(ENET_TXC_SR(priv->enet_mac_base), 0xff);
+	enet_writel(ENET_RXC_SR(priv->enet_mac_base), 0xff);
+
+	/* start link check & tx reclaim timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+
+	//priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	//add_timer(&priv->tx_reclaim_timer);
+
+	/* and finally start tx queue */
+	netif_start_queue(dev);
+
+	/* start rx dma engine */
+	enet_start_rx(priv);
+
+	return 0;
+}
+
+/*
+ * stop callback
+ */
+static int enet_stop(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned char val;
+	volatile struct enet_desc *rx;
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* stop link timer */
+	del_timer_sync(&priv->link_check_timer);
+
+	/* stop tx queue */
+	netif_stop_queue(dev);
+
+	/* stop dma */
+	//enet_stop_rx(priv);
+
+	/* stop mac rx & tx */
+	val = enet_readb(ENET_RX_CTL(priv->enet_mac_base));
+	val &= ~RX_EN;
+	enet_writeb(ENET_RX_CTL(priv->enet_mac_base), val);
+
+	val = enet_readb(ENET_TX_CTL1(priv->enet_mac_base));
+	val &= ~TX_EN;
+	enet_writeb(ENET_TX_CTL1(priv->enet_mac_base), val);
+
+	/* while we were stopping it,  the rx dma may have filled some
+	 * buffer, consider it junk and rearm all descriptor */
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->pending_tx  = -1;
+	priv->pending_tx_cnt  = 0;
+	priv->reclaim_limit  = -1;
+	priv->last_rx_desc = 0;
+	priv->free_tx_desc_count = TX_DESC_COUNT;
+
+	enet_writel(ENET_RX_DESC_ADDR(priv->enet_mac_base), PHYSADDR((void *)&priv->rx_descs[0]));
+	enet_writel(ENET_TX_DESC_ADDR(priv->enet_mac_base), PHYSADDR((void *)&priv->tx_descs[0]));
+	/* clear eoc and set it to the last one*/
+        for(i=0; i< RX_DESC_COUNT; i++){
+		int cnt;
+		cnt = (priv->last_rx_desc + i) % RX_DESC_COUNT;
+		rx = &priv->rx_descs[cnt];
+		rx->config &= ~DESC_EOC;
+		*((volatile unsigned long *)KSEG1ADDR(&(priv->rx_report[i]))) = 0; 
+	}
+	rx = &priv->rx_descs[RX_DESC_COUNT-1];
+	rx->config |= DESC_EOC;
+	priv->rx_eoc = RX_DESC_COUNT - 1;
+	mb();
+	return 0;
+}
+
+/*
+ * get_stats callback
+ */
+static struct net_device_stats *enet_get_stats(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	priv = netdev_priv(dev);
+	return &priv->stats;
+}
+
+/*
+ * ethtool callbacks
+ */
+static int enet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_gset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_sset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_nway_reset(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_nway_restart(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static u32 enet_get_link(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_link_ok(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static struct ethtool_ops enet_ethtool_ops = {
+	.get_settings		= enet_get_settings,
+	.set_settings		= enet_set_settings,
+	.nway_reset		= enet_nway_reset,
+	.get_link		= enet_get_link,
+};
+
+static int enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii);
+	ret = generic_mii_ioctl(&priv->mii, if_mii(rq), cmd, NULL);
+	spin_unlock_bh(&priv->mii);
+
+	return ret;
+}
+
+/*
+ * dma ring allocation is done here
+ */
+static int enet_dma_init(struct tangox_enet_priv *priv)
+{
+	unsigned int size;
+	int i, rx_order, tx_order;
+	
+	/*
+	 * allocate rx descriptor list & rx buffers
+	 */
+	size = RX_DESC_COUNT * sizeof (struct enet_desc);
+	for (rx_order = 0; (PAGE_SIZE << rx_order) < size; rx_order++);
+
+	if (!(priv->rx_descs_cached = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA, rx_order)))
+		return -ENOMEM;
+	dma_cache_wback_inv((unsigned long)priv->rx_descs_cached, size);
+	priv->rx_descs = (volatile struct enet_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->rx_descs_cached);
+
+	/*
+	 * initialize all rx descs
+	 */
+	for (i = 0; i < RX_DESC_COUNT; i++) {
+		volatile struct enet_desc *rx;
+		struct sk_buff *skb;
+
+		rx = &priv->rx_descs[i];
+		rx->config = RX_BUF_SIZE | DESC_BTS(2) | DESC_EOF/* | DESC_ID*/;
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (!skb)
+			return -ENOMEM;
+		
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		*((volatile unsigned long *)KSEG1ADDR(&(priv->rx_report[i]))) = 0; 
+		rx->s_addr = PHYSADDR((void *)skb->data);
+		rx->r_addr = PHYSADDR((void *)&priv->rx_report[i]);
+		rx->n_addr = PHYSADDR((void *)&priv->rx_descs[i+1]);
+		if (i == (RX_DESC_COUNT - 1)) {
+			rx->n_addr = PHYSADDR((void *)&priv->rx_descs[0]);
+			rx->config |= DESC_EOC ;
+			priv->rx_eoc = i;
+		}
+#ifdef ETH_DEBUG
+		DBG("rx[%d]=0x%08x\n", i, (unsigned int)rx);
+		DBG("  s_addr=0x%08x\n", (unsigned int)rx->s_addr);
+		DBG("  n_addr=0x%08x\n", (unsigned int)rx->n_addr);
+		DBG("  r_addr=0x%08x\n", (unsigned int)rx->r_addr);
+		DBG("  config=0x%08x\n", (unsigned int)rx->config);
+#endif
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[i] = skb;
+	}
+	priv->last_rx_desc = 0;
+
+	/*
+	 * allocate tx descriptor list
+	 *
+	 * We allocate  only the descriptor list and  prepare them for
+	 * further use. When tx is needed, we will set the right flags
+	 * and kick the dma.
+	 */
+	size = TX_DESC_COUNT * sizeof (struct enet_desc);
+	for (tx_order = 0; (PAGE_SIZE << tx_order) < size; tx_order++);
+
+	if (!(priv->tx_descs_cached = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA, tx_order))) {
+		free_pages((u32)priv->rx_descs_cached, rx_order);
+		return -ENOMEM;
+	}
+	dma_cache_wback_inv((unsigned long)priv->tx_descs_cached, size);
+	priv->tx_descs = (volatile struct enet_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->tx_descs_cached);
+
+	/*
+	 * initialize tx descs
+	 */
+	for (i = 0; i < TX_DESC_COUNT; i++) {
+		volatile struct enet_desc *tx;
+
+		priv->tx_bufs[i] = (unsigned char *)__get_free_page(GFP_KERNEL | GFP_DMA);
+		dma_cache_wback_inv((unsigned long)priv->tx_bufs[i], PAGE_SIZE);
+
+		tx = &priv->tx_descs[i];
+		*((volatile unsigned long *)KSEG1ADDR(&(priv->tx_report[i]))) = 0; 
+		tx->r_addr = PHYSADDR((void *)&priv->tx_report[i]);
+		tx->s_addr = 0;
+		tx->config = DESC_EOF;
+		if (i == (TX_DESC_COUNT - 1)) {
+			tx->config |= DESC_EOC;
+			tx->n_addr = PHYSADDR((void *)&priv->tx_descs[0]);
+			priv->tx_eoc = i;
+		}
+		//DBG("tx[%d]=0x%08x\n", i, (unsigned int)tx);
+	}
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->pending_tx = -1;
+	priv->pending_tx_cnt  = 0;
+	priv->reclaim_limit  = -1;
+	priv->free_tx_desc_count = TX_DESC_COUNT;
+
+	/*
+	 * write rx desc list & tx desc list addresses in registers
+	 */
+	enet_writel(ENET_TX_DESC_ADDR(priv->enet_mac_base), PHYSADDR((void *)&priv->tx_descs[0]));
+	enet_writel(ENET_RX_DESC_ADDR(priv->enet_mac_base), PHYSADDR((void *)&priv->rx_descs[0]));
+	return 0;
+}
+
+/*
+ * free  all dma rings  memory, called  at uninit  time or  when error
+ * occurs at init time
+ */
+static void enet_dma_free(struct tangox_enet_priv *priv)
+{
+	int i, rx_order, tx_order;
+
+	for (rx_order = 0; (PAGE_SIZE << rx_order) < (RX_DESC_COUNT * sizeof(struct enet_desc)) ; rx_order++);
+	for (tx_order = 0; (PAGE_SIZE << tx_order) < (TX_DESC_COUNT * sizeof(struct enet_desc)) ; tx_order++);
+
+	/* note: kfree(NULL) is ok */
+	if (priv->rx_descs_cached) {
+		free_pages((u32)priv->rx_descs_cached, rx_order);
+		priv->rx_descs_cached = NULL;
+	}
+	if (priv->tx_descs_cached) {
+		free_pages((u32)priv->tx_descs_cached, tx_order);
+		priv->tx_descs_cached = NULL;
+	}
+
+	/* note: kfree_skb(NULL) is _not_ ok */
+	for (i = 0; i < RX_DESC_COUNT; i++) {
+		if (priv->rx_skbs[i]) {
+			kfree_skb(priv->rx_skbs[i]);
+			priv->rx_skbs[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < TX_DESC_COUNT; i++) {
+		if (priv->tx_skbs[i]) {
+			kfree_skb(priv->tx_skbs[i]);
+			priv->tx_skbs[i] = NULL;
+		}
+		if (priv->tx_bufs[i]) {
+			free_page((u32)priv->tx_bufs[i]);
+			priv->tx_bufs[i] = NULL;
+		}
+	}
+}
+
+static int phy_reset(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int loop;
+	unsigned int val = 0;
+
+	priv = netdev_priv(dev);
+
+	/* reset phy */
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_BMCR);
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, val | BMCR_RESET);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_mdio_read(dev, priv->mii.phy_id,
+				     MII_BMCR) & BMCR_RESET))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR "%s: PHY reset does not complete...\n", priv->name);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+
+/*
+ * mac hw init is done here
+ */
+static int enet_hw_init(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned int val = 0;
+
+	if(phy_reset(dev))
+		return -EBUSY;
+
+	priv = netdev_priv(dev);
+
+	/* set pad_mode according to rgmii or not*/
+	val = enet_readb(priv->enet_mac_base + 0x400) & 0xf0;
+	if(priv->rgmii)
+		enet_writeb(priv->enet_mac_base + 0x400, val | 0x01);
+
+	/* software reset IP */
+	enet_writeb(priv->enet_mac_base + 0x424, 0);
+	udelay(10);
+	enet_writeb(priv->enet_mac_base + 0x424, 1);
+
+	/*set threshold for internal clock 0x1*/
+	enet_writeb(ENET_IC_THRESHOLD(priv->enet_mac_base), 1);
+
+	/*set Random seed 0x8*/
+	enet_writeb(ENET_RANDOM_SEED(priv->enet_mac_base), 0x08);
+
+	/*set TX single deferral params 0xc*/
+	enet_writeb(ENET_TX_SDP(priv->enet_mac_base), 0xc);
+
+	/*set slot time  0x7f for 10/100Mbps*/
+	enet_writeb(ENET_SLOT_TIME(priv->enet_mac_base), 0x7f);
+
+	/*set Threshold for partial full  0x7f */
+	enet_writeb(ENET_PF_THRESHOLD(priv->enet_mac_base), 0x7f);
+
+	/* configure TX DMA Channels */
+	val = enet_readl(ENET_TXC_CR(priv->enet_mac_base));
+	val |=	TCR_RS  | TCR_LE  | TCR_TFI(1) | 
+		/*TCR_DIE |*/ TCR_BTS(2);
+	val |=	TCR_DM;
+ 
+	enet_writel(ENET_TXC_CR(priv->enet_mac_base), val);
+	val = enet_readl(ENET_TXC_CR(priv->enet_mac_base));
+
+ 	/* configure RX DMA Channels */
+	val = enet_readl(ENET_RXC_CR(priv->enet_mac_base));
+	val |= (RCR_RS    | RCR_LE | RCR_RFI(1) | 
+		RCR_BTS(2) | RCR_FI | RCR_DIE /* | RCR_EN*/); 
+	val |=	RCR_DM;
+
+	val |=  RX_BUF_SIZE << 16;
+	enet_writel(ENET_RXC_CR(priv->enet_mac_base), val); 
+
+	/* configure MAC ctrller */
+	val = enet_readb(ENET_TX_CTL1(priv->enet_mac_base));
+	val |= (TX_RETRY_EN | TX_PAD_EN | TX_APPEND_FCS);
+	enet_writeb(ENET_TX_CTL1(priv->enet_mac_base), (unsigned char)val);
+
+	/* set retry 5 time when collision occurs*/
+	enet_writeb(ENET_TX_CTL2(priv->enet_mac_base), 5);
+
+	val = enet_readb(ENET_RX_CTL(priv->enet_mac_base));
+	val |= (RX_RUNT | RX_PAD_STRIP | RX_SEND_CRC 
+	                | RX_PAUSE_EN| RX_AF_EN);
+	enet_writeb(ENET_RX_CTL(priv->enet_mac_base), (unsigned char)val);
+
+#ifdef ENABLE_MULTICAST
+	/* clear internal multicast address table */
+	enet_writeb(ENET_MC_INIT(priv->enet_mac_base),  0x00);
+	while(enet_readb(ENET_MC_INIT(priv->enet_mac_base)));
+	DBG("Internal multicast address table is cleared\n");
+#endif
+
+	/* unicast */
+	/* Threshold for internal clock*/
+	/* threshold for partial empty*/
+	/* threshold for partial full */
+
+	/* buffer size for transmit must be 1 from the doc
+	   however, it's said that using 0xff ??*/
+	enet_writeb(ENET_TX_BUFSIZE(priv->enet_mac_base), 0xff);
+
+	/* fifo control */
+
+	/*MAC mode*/
+	enet_mac_config(dev);
+
+	/* check gmii mode support */
+	priv->mii.supports_gmii = mii_check_gmii_support(&priv->mii);
+	DBG("gmii support=0x%x id=0x%x\n", priv->mii.supports_gmii, priv->mii.phy_id);
+
+	return 0;
+}
+
+/*
+ * allocate  netdevice structure,  do  all dma  rings allocations  and
+ * register the netdevice
+ */
+extern int tangox_ethernet_getmac(int, unsigned char *);
+
+static int enet_probe(int idx)
+{
+	struct tangox_enet_priv *priv;
+	struct net_device *dev;
+	int ret;
+	struct sockaddr sock;
+	char pad_mode;
+	short clk_div;
+	unsigned long enet_mac_base;
+	const char *name;
+
+	enet_mac_base = eth_mac_cores[idx].enet_mac_base;
+	name = eth_mac_cores[idx].name;
+
+#if 1 /* this part may be moved to boot loader */
+	/* set pad_mode*/
+	pad_mode = enet_readb(enet_mac_base + 0x400);
+	enet_writeb(enet_mac_base + 0x400, pad_mode & 0xf0);
+	pad_mode = enet_readb(enet_mac_base + 0x400);
+
+	/* set MDIO clock divider */
+	clk_div = enet_readw(enet_mac_base + 0x420);
+	//DBG("default clk_div =%d\n", clk_div);
+	//enet_writew(enet_mac_base + 0x420, 50);
+	enet_writew(enet_mac_base + 0x420, tangox_get_sysclock() / (2500000 * 2));
+	clk_div = enet_readw(enet_mac_base + 0x420);
+	//DBG("clk_div =%d: set MDIO clock=200/%d=%dMHz\n", clk_div, clk_div, 200/(clk_div*2));
+#endif
+
+	/* allocate  netdevice structure  with enough  length  for our
+	 * context data */
+	dev = alloc_etherdev(sizeof (*priv));
+	if (!dev)
+		return -ENOMEM;
+
+	/* initialize private data */
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof (*priv));
+	priv->enet_mac_base = enet_mac_base;
+	priv->name = name;
+	priv->pending_tx = -1;
+	priv->pending_tx_cnt = 0;
+	priv->reclaim_limit = -1;
+	spin_lock_init(&priv->tx_lock);
+	spin_lock_init(&priv->ier_lock);
+	spin_lock_init(&priv->maccr_lock);
+
+	/* init tx done tasklet */
+	tasklet_init(&priv->tx_reclaim_tasklet, enet_tx_reclaim,
+		     (unsigned long)dev);
+#if 0
+	/* init tx reclaim timer */
+	init_timer(&priv->tx_reclaim_timer);
+	priv->tx_reclaim_timer.data = (unsigned long )dev;
+	priv->tx_reclaim_timer.function = enet_tx_reclaim_timer;
+#endif
+	/* init link check timer and mii lock */
+	init_timer(&priv->link_check_timer);
+	priv->link_check_timer.data = (unsigned long)dev;
+	priv->link_check_timer.function = enet_link_check;
+	spin_lock_init(&priv->mii_lock);
+
+	/* fill mii info */
+	priv->mii.dev = dev;
+	priv->mii.phy_id_mask  = 0x1f;
+	priv->mii.reg_num_mask = 0x1f;
+	priv->mii.mdio_read = enet_mdio_read;
+	priv->mii.mdio_write = enet_mdio_write;
+	
+	if (eth_mac_cores[idx].phy_id != -1) {
+		/* phy id forced, just check for sanity */
+		if (eth_mac_cores[idx].phy_id < 0 || eth_mac_cores[idx].phy_id > 31) {
+			ret = -EINVAL;
+			goto err_free;
+		}
+		priv->mii.phy_id = eth_mac_cores[idx].phy_id;
+
+	} else {
+		int i;
+
+		/* try to probe phy if not given */
+		for (i = 0; i <32; i++) {
+			uint32_t id;
+			int val;
+
+			val = enet_mdio_read(dev, i, MII_PHYSID1);
+			id = (val << 16);
+			val = enet_mdio_read(dev, i, MII_PHYSID2);
+			id |= val;
+			if (id != 0xffffffff && id != 0x00000000) {
+				/* check vsc8061 */
+				if(id == 0x00070421)
+					priv->rgmii = 1;
+				break;
+			}
+		}
+		if (i == 32) {
+			printk(KERN_ERR "%s: unable to autodetect phy\n", priv->name);
+			ret = -EIO;
+			goto err_free;
+		}
+		printk(KERN_ERR "%s: detected phy %s at address 0x%02x\n", name,(priv->rgmii? "vsc8601":""), i);
+		priv->mii.phy_id = i;
+	}
+
+	printk(KERN_INFO "%s: Ethernet driver for SMP864x/SMP865x internal MAC core %d: %s Base at 0x%lx\n",
+				 name, idx, priv->rgmii?"1000Mbps":"100Mbps",  enet_mac_base);
+
+	/* initialize hardware */
+	if ((ret = enet_hw_init(dev)))
+		goto err_free;
+
+	/* initialize dma descriptors */
+	if ((ret = enet_dma_init(priv)))
+		goto err_free;
+
+	ret = request_irq(eth_mac_cores[idx].irq, enet_isr, IRQF_DISABLED,
+			  eth_mac_cores[idx].name, dev);
+	dev->irq = eth_mac_cores[idx].irq;
+
+	if (ret)
+		goto err_free;
+
+	/* install driver callbacks and register netdevice */
+	dev->open = enet_open;
+	dev->stop = enet_stop;
+	dev->hard_start_xmit = enet_xmit;
+	dev->get_stats = enet_get_stats;
+	dev->set_mac_address = enet_set_mac_address;
+	dev->set_multicast_list = enet_set_multicast_list;
+	dev->poll = enet_poll;
+	dev->ethtool_ops = &enet_ethtool_ops;
+	dev->do_ioctl = enet_ioctl;
+	dev->weight = RX_DESC_COUNT;
+	dev->tx_queue_len = TX_DESC_COUNT;
+#ifdef ENABLE_MULTICAST
+	dev->flags |= IFF_MULTICAST;
+#else	
+	dev->flags &= ~IFF_MULTICAST;
+#endif
+
+	/* set default mac address */
+	tangox_ethernet_getmac(idx, dev->dev_addr);
+	memcpy(&(sock.sa_data), dev->dev_addr, ETH_ALEN);
+
+	enet_set_mac_address(dev, &sock);
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR "%s: unable to register netdevice\n", priv->name);
+		goto err_free;
+	}
+
+	printk(KERN_INFO "%s: mac address %02x:%02x:%02x:%02x:%02x:%02x\n", priv->name,
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	eth_mac_cores[idx].gdev = dev;
+	return 0;
+
+err_free:
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	enet_dma_free(priv);
+	free_netdev(dev);
+	return ret;
+}
+
+
+/*
+ * entry point, checks if ethernet is  enabled on the board and if so,
+ * probes it
+ */
+extern int tangox_ethernet_enabled(int);
+
+int __init tangox_enet_init(void)
+{
+	int i;
+
+	/* for command line overwrite */
+	eth_mac_cores[0].phy_id = phyid_0;
+	eth_mac_cores[1].phy_id = phyid_1;
+
+	for (i = 0; i < NUM_MAC_CORES; i++) {
+		if ((1 << i) & mac_cores) {
+			if (!tangox_ethernet_enabled(i)) {
+				printk(KERN_NOTICE "%s: ethernet mac_core %d support is disabled from XENV\n", eth_mac_cores[i].name, i);
+				continue;
+			}
+			enet_probe(i);
+		} else {
+			printk(KERN_NOTICE "%s: ethernet mac_core %d support is disabled\n", eth_mac_cores[i].name, i);
+		}
+	}
+	return 0;
+}
+
+/*
+ * exit func, stops hardware and unregisters netdevice
+ */
+void __exit tangox_enet_exit(void)
+{
+	struct tangox_enet_priv *priv;
+	struct net_device *dev;
+	int i;
+
+	for (i = 0; i < NUM_MAC_CORES; i++) {
+		if ((dev = eth_mac_cores[i].gdev) == NULL)
+			continue;
+
+		free_irq(dev->irq, dev);
+		unregister_netdev(dev);
+
+		priv = netdev_priv(dev);
+		enet_dma_free(priv);
+
+		free_netdev(dev);
+	}
+}
+
+module_init(tangox_enet_init);
+module_exit(tangox_enet_exit);
+
+MODULE_DESCRIPTION("SMP86xx internal ethernet mac driver");
+MODULE_AUTHOR("TANGO3 standalone team");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM_DESC(phyid_0, "PHY id for core 0, else autodetect");
+module_param(phyid_0, int, 0);
+
+MODULE_PARM_DESC(phyid_1, "PHY id for core 1, else autodetect");
+module_param(phyid_1, int, 0);
+
+MODULE_PARM_DESC(mac_cores, "MAC core id, 1 for core 0, 2 for core 1, 3 for both");
+module_param(mac_cores, int, 0);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/net/tangox_enet.h linux-2.6.22.19/drivers/net/tangox_enet.h
--- linux-2.6.22.19.ref/drivers/net/tangox_enet.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/drivers/net/tangox_enet.h	2009-03-26 19:01:26.000000000 -0700
@@ -0,0 +1,385 @@
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGOX_ENET_H
+#define __TANGOX_ENET_H
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+
+#include <asm/addrspace.h>
+
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#else
+#error "Unknown architecture"
+#endif
+
+#define ENET_IRQ0	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC_INT))
+#define ENET_IRQ1	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC1_INT))
+
+/*
+ * number of rx/tx buffers available
+ * !!! MUST BE A POWER OF 2 !!!
+ */
+#define RX_DESC_COUNT   256 
+#define TX_DESC_COUNT	256	
+
+/*
+ * we enable tx  interrupt when there is equal to  this number of free
+ * tx desc. Keep it lower than TX_DESC_COUNT if you change it.
+ */
+#define ENET_DESC_LOW 32	
+
+/*
+ * sizeof rx buffers we give to the dma controller
+ */
+#define RX_BUF_SIZE		1534	// 0x600
+
+/* since the Ethernet header is 14 bytes, so that we need 2 more bytes to align. 
+ * but s_addr need to be 4 bytes aligned, so that we have trade off here
+ */
+#define SKB_RESERVE_SIZE	0	
+
+/*
+ * we reclaim  transmited using a  timer, we switch to  interrupt mode
+ * under high load. this is the timer frequency
+ */
+#define TX_RECLAIM_TIMER_FREQ	(HZ / 100)
+
+/*
+ * link status  is polled on a regular  basis by a timer,  this is its
+ * frequency
+ */
+#define LINK_CHECK_TIMER_FREQ	(HZ)
+
+/*
+ * getting system frequency
+ */
+extern unsigned long tangox_get_sysclock(void);
+
+/*
+ * address space conversion
+ */
+#define CACHE_TO_NONCACHE(x)	KSEG1ADDR(x)
+
+/*
+ * dma address translation
+ */
+static inline unsigned long PHYSADDR(void *addr) 
+{
+	return tangox_dma_address(CPHYSADDR((unsigned long)addr));
+}
+
+/*
+ * Mac/DMA registers offset, refer to documentation
+ */
+#define ENET_TX_CTL1(mac_base)		((mac_base) + 0x00)
+#define TX_TPD		        	(1 << 5)
+#define TX_APPEND_FCS       		(1 << 4)
+#define TX_PAD_EN          		(1 << 3)
+#define TX_RETRY_EN        		(1 << 2)
+#define TX_EN		        	(1 << 0)
+#define ENET_TX_CTL2(mac_base)		((mac_base) + 0x01)
+#define ENET_RX_CTL(mac_base)	    	((mac_base) + 0x04)
+#define RX_BC_DISABLE			(1 << 7)
+#define RX_RUNT		        	(1 << 6)
+#define RX_AF_EN			(1 << 5)
+#define RX_PAUSE_EN	     		(1 << 3)
+#define RX_SEND_CRC	    		(1 << 2)
+#define RX_PAD_STRIP	   		(1 << 1)
+#define RX_EN		        	(1 << 0)
+#define ENET_RANDOM_SEED(mac_base)	((mac_base) + 0x8)
+#define ENET_TX_SDP(mac_base)	    	((mac_base) + 0x14)
+#define ENET_TX_TPDP1(mac_base)		((mac_base) + 0x18)
+#define ENET_TX_TPDP2(mac_base)		((mac_base) + 0x19)
+#define ENET_SLOT_TIME(mac_base)	((mac_base) + 0x1c)
+#define ENET_MDIO_CMD1(mac_base)	((mac_base) + 0x20)
+#define ENET_MDIO_CMD2(mac_base)	((mac_base) + 0x21)
+#define ENET_MDIO_CMD3(mac_base)	((mac_base) + 0x22)
+#define ENET_MDIO_CMD4(mac_base)	((mac_base) + 0x23)
+#define MIIAR_ADDR(x)      		((x) << 21)
+#define MIIAR_REG(x)       		((x) << 16)
+#define MIIAR_DATA(x)      		((x) <<  0)
+#define MDIO_CMD_GO	    		(1 << 31)
+#define MDIO_CMD_WR   			(1 << 26)
+#define ENET_MDIO_STS1(mac_base)	((mac_base) + 0x24)
+#define ENET_MDIO_STS2(mac_base)	((mac_base) + 0x25)
+#define ENET_MDIO_STS3(mac_base)	((mac_base) + 0x26)
+#define ENET_MDIO_STS4(mac_base)	((mac_base) + 0x27)
+#define MDIO_STS_ERR			(1 << 31)
+#define ENET_MC_ADDR1(mac_base)		((mac_base) + 0x28)
+#define ENET_MC_ADDR2(mac_base)		((mac_base) + 0x29)
+#define ENET_MC_ADDR3(mac_base)		((mac_base) + 0x2a)
+#define ENET_MC_ADDR4(mac_base)		((mac_base) + 0x2b)
+#define ENET_MC_ADDR5(mac_base)		((mac_base) + 0x2c)
+#define ENET_MC_ADDR6(mac_base)		((mac_base) + 0x2d)
+#define ENET_MC_INIT(mac_base)		((mac_base) + 0x2e)
+#define ENET_UC_ADDR1(mac_base)		((mac_base) + 0x3c)
+#define ENET_UC_ADDR2(mac_base)		((mac_base) + 0x3d)
+#define ENET_UC_ADDR3(mac_base)		((mac_base) + 0x3e)
+#define ENET_UC_ADDR4(mac_base)		((mac_base) + 0x3f)
+#define ENET_UC_ADDR5(mac_base)		((mac_base) + 0x40)
+#define ENET_UC_ADDR6(mac_base)		((mac_base) + 0x41)
+#define ENET_MAC_MODE(mac_base)		((mac_base) + 0x44)
+#define RGMII_MODE	    		(1 << 7)
+#define HALF_DUPLEX  			(1 << 4)
+#define BST_EN	    	 		(1 << 3)
+#define LB_EN	    			(1 << 2)
+#define GMAC_MODE	    		(1 << 0)
+#define ENET_IC_THRESHOLD(mac_base)	((mac_base) + 0x50)
+#define ENET_PE_THRESHOLD(mac_base)	((mac_base) + 0x51)
+#define ENET_PF_THRESHOLD(mac_base)	((mac_base) + 0x52)
+/* TX buffer size must be set to 0x01 ??*/
+#define ENET_TX_BUFSIZE(mac_base)	((mac_base) + 0x54)
+#define ENET_FIFO_CTL(mac_base)		((mac_base) + 0x56)
+#define ENET_PQ1(mac_base)	    	((mac_base) + 0x60)
+#define ENET_PQ2(mac_base)	    	((mac_base) + 0x61)
+#define ENET_MAC_ADDR1(mac_base)	((mac_base) + 0x6a)
+#define ENET_MAC_ADDR2(mac_base)	((mac_base) + 0x6b)
+#define ENET_MAC_ADDR3(mac_base)	((mac_base) + 0x6c)
+#define ENET_MAC_ADDR4(mac_base)	((mac_base) + 0x6d)
+#define ENET_MAC_ADDR5(mac_base)	((mac_base) + 0x6e)
+#define ENET_MAC_ADDR6(mac_base)	((mac_base) + 0x6f)
+#define ENET_STAT_DATA1(mac_base)	((mac_base) + 0x78)
+#define ENET_STAT_DATA2(mac_base)	((mac_base) + 0x79)
+#define ENET_STAT_DATA3(mac_base)	((mac_base) + 0x7a)
+#define ENET_STAT_DATA4(mac_base)	((mac_base) + 0x7b)
+#define ENET_STAT_INDEX(mac_base)	((mac_base) + 0x7c)
+#define ENET_STAT_CLEAR(mac_base)	((mac_base) + 0x7d)
+#define ENET_SLEEP_MODE(mac_base)	((mac_base) + 0x7e)
+#define SLEEP_MODE	    		(1 << 0)
+#define ENET_WAKEUP(mac_base)	    	((mac_base) + 0x7f)
+#define WAKEUP		    		(1 << 0)
+
+#define ENET_TXC_CR(mac_base)		((mac_base) + 0x100)
+#define TCR_LK		    		(1 << 12)
+#define TCR_DS		    		(1 << 11)
+#define TCR_BTS(x)          		(((x) & 0x7) << 8)
+#define TCR_DIE		    		(1 << 7)
+#define TCR_TFI(x)          		(((x) & 0x7) << 4)
+#define TCR_LE		    		(1 << 3)
+#define TCR_RS		    		(1 << 2)
+#define TCR_DM		    		(1 << 1)
+#define TCR_EN		    		(1 << 0)
+
+#define ENET_TXC_SR(mac_base)		((mac_base) + 0x104)
+#define TSR_DE				(1 << 3)
+#define TSR_DI				(1 << 2)
+#define TSR_TO				(1 << 1)
+#define TSR_TI				(1 << 0)
+
+#define ENET_TX_SAR(mac_base)		((mac_base) + 0x108)
+#define ENET_TX_DESC_ADDR(mac_base)	((mac_base) + 0x10c)
+
+#define ENET_TX_REPORT_ADDR(mac_base)	((mac_base) + 0x110)
+#define TX_BYTES_TRASFERRED(x)		(((x) >> 16) & 0xffff)
+#define TX_FIRST_DEFERRAL		(1 << 7)
+#define TX_EARLY_COLLISIONS(x)		(((x) >> 3) & 0xf)
+#define TX_LATE_COLLISION		(1 << 2)
+#define TX_PACKET_DROPPED		(1 << 1)
+#define TX_FIFO_UNDERRUN		(1 << 0)
+
+#define ENET_TX_FIFO_SR(mac_base)	((mac_base) + 0x114)
+#define ENET_TX_ITR(mac_base)		((mac_base) + 0x118)
+
+#define ENET_RXC_CR(mac_base)		((mac_base) + 0x200)
+#define RCR_FI				(1 << 13)
+#define RCR_LK				(1 << 12)
+#define RCR_DS				(1 << 11)
+#define RCR_BTS(x)         		(((x) & 7) << 8)
+#define RCR_DIE				(1 << 7)
+#define RCR_RFI(x)         		(((x) & 7) << 4)
+#define RCR_LE				(1 << 3)
+#define RCR_RS				(1 << 2)
+#define RCR_DM				(1 << 1)
+#define RCR_EN				(1 << 0)
+
+#define ENET_RXC_SR(mac_base)		((mac_base) + 0x204)
+#define RSR_DE				(1 << 3)
+#define RSR_DI				(1 << 2)
+#define RSR_RO				(1 << 1)
+#define RSR_RI				(1 << 0)
+
+#define ENET_RX_SAR(mac_base)		((mac_base) + 0x208)
+#define ENET_RX_DESC_ADDR(mac_base)	((mac_base) + 0x20c)
+
+#define ENET_RX_REPORT_ADDR(mac_base)	((mac_base) + 0x210)
+#define RX_BYTES_TRANSFERRED(x)		(((x) >> 16) & 0xFFFF)
+#define RX_MULTICAST_PKT		(1 << 9)
+#define RX_BROADCAST_PKT		(1 << 8)
+#define RX_LENGTH_ERR			(1 << 7)
+#define RX_FCS_ERR			(1 << 6)
+#define RX_RUNT_PKT			(1 << 5)
+#define RX_FIFO_OVERRUN			(1 << 4)
+#define RX_LATE_COLLISION		(1 << 3)
+#define RX_FRAME_LEN_ERROR		(1 << 2)
+
+#define ENET_RX_FIFO_SR(mac_base)	((mac_base) + 0x214)
+#define ENET_RX_ITR(mac_base)		((mac_base) + 0x218)
+
+/*
+ * rx dma descriptor definition
+ */
+struct enet_desc {
+	unsigned long s_addr;
+	unsigned long n_addr;
+	unsigned long r_addr;
+	unsigned long config;
+}; 
+
+#define DESC_ID				(1 << 23)
+#define DESC_EOC			(1 << 22)
+#define DESC_EOF			(1 << 21)
+#define DESC_LK				(1 << 20)
+#define DESC_DS				(1 << 19)
+#define DESC_BTS(x)			(((x) & 0x7) <<16)
+#define DESC_TC(x)			(x)
+
+/*
+ * our private context
+ */
+struct tangox_enet_priv {
+
+	/*
+	 * rx related
+	 */
+
+	/* pointer to rx descriptor array */
+	volatile struct enet_desc	*rx_descs __attribute__((aligned(32)));
+	struct enet_desc		*rx_descs_cached __attribute__((aligned(32)));
+
+	/* last rx descriptor processed */
+	unsigned int			last_rx_desc;
+
+	/* we keep a list of skb given */
+	struct sk_buff			*rx_skbs[RX_DESC_COUNT] __attribute__((aligned(32)));
+	
+	/* desc status report */
+	unsigned long 			rx_report[RX_DESC_COUNT] __attribute__((aligned(32)));
+
+	/* ethernet device stats */
+	struct net_device_stats		stats;
+
+	/* rx stopped? */
+	int				rx_stopped;
+
+	/* tracking the EOC */
+	unsigned int			rx_eoc;
+
+	/*
+	 * tx related
+	 */
+
+	/* access  to  tx related  dma  stuffs  is  protected by  this
+	 * spinlock, this is because we  access them via a tasklet and
+	 * a timer */
+	spinlock_t			tx_lock;
+
+	/* pointer to tx descriptor array */
+	volatile struct enet_desc	*tx_descs __attribute__((aligned(32)));
+	struct enet_desc		*tx_descs_cached __attribute__((aligned(32)));
+
+	/* index of current dirty tx descriptor */
+	unsigned int			dirty_tx_desc;
+
+	/* index of next clean tx descriptor to use */
+	unsigned int			next_tx_desc;
+
+	/* count of free tx desc to avoid its computation */
+	unsigned int			free_tx_desc_count;
+
+	/* list of sent skb */
+	struct sk_buff			*tx_skbs[TX_DESC_COUNT] __attribute__((aligned(32)));
+
+	/* list of tx_bufs */
+	unsigned char 			*tx_bufs[TX_DESC_COUNT];
+	
+	/* desc status report */
+	unsigned long 			tx_report[RX_DESC_COUNT] __attribute__((aligned(32)));
+
+	/* tx  done operation is  done under  these tasklet  and timer
+	 * context */
+	struct tasklet_struct		tx_reclaim_tasklet;
+	struct timer_list		tx_reclaim_timer;
+
+	/* the 1st pending tx  */
+	int 				pending_tx;
+	
+	/* how many pending desc in this pending tx*/
+	int 				pending_tx_cnt;
+
+	/* reclaim to this limit */
+	int 				reclaim_limit;
+
+	/* tracking the EOC */
+	unsigned int			tx_eoc;
+
+	/*
+	 * misc
+	 */
+
+	/* base address of enet registers */
+	unsigned long			enet_mac_base;
+
+	/* device name */
+	const char 			*name;
+
+	/* spinlock used to protect interrupt enable register */
+	spinlock_t			ier_lock;
+
+	/* spinlock used to protect maccr register */
+	spinlock_t			maccr_lock;
+
+	/* our mii state */
+	struct mii_if_info	mii;
+
+	/* mii access is protected by following spinlock */
+	spinlock_t			mii_lock;
+
+	/* link status is checked periodically by this timer */
+	struct timer_list	link_check_timer;
+
+	/* rgmii */
+	int rgmii;
+};
+
+/*
+ * helpers to access registers
+ */
+#define enet_readl(x)	gbus_read_uint32(0, x)
+#define enet_readw(x)	gbus_read_uint16(0, x)
+#define enet_readb(x)	gbus_read_uint8(0, x)
+
+static inline void enet_writel(unsigned long addr, unsigned long data)
+{
+        gbus_write_uint32(0, addr, data);
+
+        /* some write  read sequence seems  to freeze completly  if no
+         * barrier is done between each access. To be safe, we do this
+         * after all write access */
+        iob();
+}
+
+static inline void enet_writew(unsigned long addr, unsigned short data)
+{
+        gbus_write_uint16(0, addr, data);
+        iob();
+}
+
+static inline void enet_writeb(unsigned long addr, unsigned char data)
+{
+        gbus_write_uint8(0, addr, data);
+        iob();
+}
+
+#endif /* __TANGOX_ENET_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/README.1006.enet.patch linux-2.6.22.19/README.1006.enet.patch
--- linux-2.6.22.19.ref/README.1006.enet.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/README.1006.enet.patch	2009-03-26 19:02:37.000000000 -0700
@@ -0,0 +1,20 @@
+Feature:
+--------
+Builtin ethernet controller support for SMP86xx chips
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+1002
+
+Primary author:
+---------------
+Craig Qu
+
+Related to which chip version SMP86xx xx=?
+------------------------------------------
+Tango2 ES6/RevA, Tango3 ES1, or above 
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
