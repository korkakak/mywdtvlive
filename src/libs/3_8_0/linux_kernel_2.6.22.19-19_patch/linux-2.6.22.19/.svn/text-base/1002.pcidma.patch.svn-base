diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/lib/iomap.c linux-2.6.22.19/arch/mips/lib/iomap.c
--- linux-2.6.22.19.ref/arch/mips/lib/iomap.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/lib/iomap.c	2009-04-20 09:05:13.000000000 -0700
@@ -5,10 +5,16 @@
  * (C) Copyright 2006 Ralf Baechle <ralf@linux-mips.org>
  * (C) Copyright 2007 MIPS Technologies, Inc.
  *     written by Ralf Baechle <ralf@linux-mips.org>
+ * (C) Copyright 2007 Sigma Designs, Inc.
  */
 #include <linux/module.h>
 #include <asm/io.h>
 
+ #include <linux/ioport.h>
+ #include <linux/module.h>
+ #include <linux/pci.h>
+
+
 /*
  * Read/write from/to an (offsettable) iomem cookie. It might be a PIO
  * access or a MMIO access, these functions don't care. The info is
@@ -210,17 +216,18 @@
 
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
 {
-	if (port > PIO_MASK)
+	unsigned long end;
+
+	end = port + nr - 1UL;
+	if (ioport_resource.start > port ||
+	    ioport_resource.end < end || port > end)
 		return NULL;
 
-	return ioport_map_legacy(port, nr);
+	return (void __iomem *)(mips_io_port_base + port);
 }
 
-EXPORT_SYMBOL(ioport_map);
-
 void ioport_unmap(void __iomem *addr)
 {
-	/* Nothing to do */
 }
-
+EXPORT_SYMBOL(ioport_map);
 EXPORT_SYMBOL(ioport_unmap);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/mm/dma-tangox.c linux-2.6.22.19/arch/mips/mm/dma-tangox.c
--- linux-2.6.22.19.ref/arch/mips/mm/dma-tangox.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/mm/dma-tangox.c	2009-04-20 09:05:13.000000000 -0700
@@ -0,0 +1,474 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000  Ani Joshi <ajoshi@unixbox.com>
+ * Copyright (C) 2000, 2001, 06  Ralf Baechle <ralf@linux-mips.org>
+ * swiped from i386, and cloned for MIPS by Geert, polished by Ralf.
+ *
+ * Adopted for Sigma Designs's Tango2/Tango3 platforms.
+ *
+ * Copyright (C) 2007-2009  Sigma Designs, Inc.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+
+#include <asm/cache.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#endif
+
+extern unsigned long g_pcimem_busaddr;
+extern unsigned long g_pcimem_physaddr;
+extern unsigned long g_pcimem_physaddr_end;
+
+#ifdef CONFIG_PCI
+#define IS_PCIDEV(x)	((x)->bus == &pci_bus_type)
+#else
+#define IS_PCIDEV(x)	0
+#endif
+
+#ifdef CONFIG_PCI
+static inline unsigned long __pci_virt_to_bus(unsigned long virt)
+{
+	if ((virt_to_phys((void *)virt) < g_pcimem_physaddr) ||
+	    (virt_to_phys((void *)virt) >= g_pcimem_physaddr_end)) {
+		printk("virt2bus: Not a dma-able address: 0x%08lx\n", virt);
+		return 0;
+	}
+	return((unsigned long)(virt_to_phys((void *)virt) - g_pcimem_physaddr +
+			       g_pcimem_busaddr));
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long busaddr)
+{
+	if ((busaddr < g_pcimem_busaddr) ||
+	    (busaddr >= (g_pcimem_busaddr + (g_pcimem_physaddr_end - g_pcimem_physaddr)))) {
+		printk("bus2virt: Not a valid bus address: 0x%08lx\n",
+		       busaddr);
+		return 0;
+	}
+	return((unsigned long)phys_to_virt((busaddr - g_pcimem_busaddr) +
+			       g_pcimem_physaddr));
+}
+#else
+static inline unsigned long __pci_virt_to_bus(unsigned long addr)
+{
+	BUG();
+	return 0;
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long addr)
+{
+	BUG();
+	return 0;
+}
+#endif
+
+unsigned long pci_virt_to_bus(unsigned long addr)
+{
+	return __pci_virt_to_bus(addr);
+}
+
+EXPORT_SYMBOL(pci_virt_to_bus);
+
+unsigned long pci_bus_to_virt(unsigned long addr)
+{
+	return __pci_bus_to_virt(addr);
+}
+
+EXPORT_SYMBOL(pci_bus_to_virt);
+
+static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr, size_t size)
+{
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus((unsigned long)addr);
+	return tangox_dma_address(virt_to_phys(addr));
+}
+
+static inline dma_addr_t plat_map_dma_mem_page(struct device *dev, struct page *page)
+{
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus((unsigned long)page_to_phys(page));
+	return tangox_dma_address(page_to_phys(page));
+}
+
+static inline unsigned long plat_dma_addr_to_phys(dma_addr_t dma_addr)
+{
+	return tangox_inv_dma_address(dma_addr);
+}
+
+static inline void plat_unmap_dma_mem(dma_addr_t dma_addr)
+{
+	/* nothing to be done */
+}
+
+static inline int plat_device_is_coherent(struct device *dev)
+{
+	return 0; /* Always noncoherent for Tango2/Tango3 */
+}
+
+static inline unsigned long dma_addr_to_virt(dma_addr_t dma_addr)
+{
+	unsigned long addr = plat_dma_addr_to_phys(dma_addr);
+
+	return (unsigned long)phys_to_virt(addr);
+}
+
+/*
+ * Warning on the terminology - Linux calls an uncached area coherent;
+ * MIPS terminology calls memory areas with hardware maintained coherency
+ * coherent.
+ */
+
+static inline int cpu_is_noncoherent_r10000(struct device *dev)
+{
+	return !plat_device_is_coherent(dev) &&
+	       (current_cpu_data.cputype == CPU_R10000 &&
+	       current_cpu_data.cputype == CPU_R12000);
+}
+
+void *dma_alloc_noncoherent(struct device *dev, size_t size,
+	dma_addr_t * dma_handle, gfp_t gfp)
+{
+	void *ret;
+
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+	if (dev == NULL || (dev->coherent_dma_mask < 0xffffffff))
+		gfp |= GFP_DMA;
+	ret = (void *) __get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+//		memset(ret, 0, size); /* may not be needed?? */
+		*dma_handle = plat_map_dma_mem(dev, ret, size);
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(dma_alloc_noncoherent);
+
+void *dma_alloc_coherent(struct device *dev, size_t size,
+	dma_addr_t * dma_handle, gfp_t gfp)
+{
+	void *ret;
+
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+	if (dev == NULL || (dev->coherent_dma_mask < 0xffffffff))
+		gfp |= GFP_DMA;
+	ret = (void *) __get_free_pages(gfp, get_order(size));
+
+	if (ret) {
+//		memset(ret, 0, size); /* may not be needed?? */
+		*dma_handle = plat_map_dma_mem(dev, ret, size);
+
+		if (!plat_device_is_coherent(dev)) {
+			dma_cache_wback_inv((unsigned long) ret, size);
+			ret = UNCAC_ADDR(ret);
+		}
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(dma_alloc_coherent);
+
+void dma_free_noncoherent(struct device *dev, size_t size, void *vaddr,
+	dma_addr_t dma_handle)
+{
+	free_pages((unsigned long) vaddr, get_order(size));
+}
+
+EXPORT_SYMBOL(dma_free_noncoherent);
+
+void dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+	dma_addr_t dma_handle)
+{
+	unsigned long addr = (unsigned long) vaddr;
+
+	if (!plat_device_is_coherent(dev))
+		addr = CAC_ADDR(addr);
+
+	free_pages(addr, get_order(size));
+}
+
+EXPORT_SYMBOL(dma_free_coherent);
+
+static inline void __dma_sync(unsigned long addr, size_t size,
+	enum dma_data_direction direction)
+{
+	switch (direction) {
+	case DMA_TO_DEVICE:
+		dma_cache_wback(addr, size);
+		break;
+
+	case DMA_FROM_DEVICE:
+		dma_cache_inv(addr, size);
+		break;
+
+	case DMA_BIDIRECTIONAL:
+		dma_cache_wback_inv(addr, size);
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+dma_addr_t dma_map_single(struct device *dev, void *ptr, size_t size,
+	enum dma_data_direction direction)
+{
+	unsigned long addr = (unsigned long) ptr;
+
+	if (!plat_device_is_coherent(dev))
+		__dma_sync(addr, size, direction);
+
+	return plat_map_dma_mem(dev, ptr, size);
+}
+
+EXPORT_SYMBOL(dma_map_single);
+
+void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
+	enum dma_data_direction direction)
+{
+	if (cpu_is_noncoherent_r10000(dev))
+		__dma_sync(dma_addr_to_virt(dma_addr), size,
+		           direction);
+
+	plat_unmap_dma_mem(dma_addr);
+}
+
+EXPORT_SYMBOL(dma_unmap_single);
+
+int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	for (i = 0; i < nents; i++, sg++) {
+		unsigned long addr;
+
+		addr = (unsigned long) page_address(sg->page);
+		if (!plat_device_is_coherent(dev) && addr)
+			__dma_sync(addr + sg->offset, sg->length, direction);
+		sg->dma_address = plat_map_dma_mem(dev,
+				                   (void *)(addr + sg->offset),
+						   sg->length);
+	}
+
+	return nents;
+}
+
+EXPORT_SYMBOL(dma_map_sg);
+
+void dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nhwentries,
+	enum dma_data_direction direction)
+{
+	unsigned long addr;
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	for (i = 0; i < nhwentries; i++, sg++) {
+		if (!plat_device_is_coherent(dev) &&
+		    direction != DMA_TO_DEVICE) {
+			addr = (unsigned long) page_address(sg->page);
+			if (addr)
+				__dma_sync(addr + sg->offset, sg->length,
+				           direction);
+		}
+		plat_unmap_dma_mem(sg->dma_address);
+	}
+}
+
+EXPORT_SYMBOL(dma_unmap_sg);
+
+dma_addr_t dma_map_page(struct device *dev, struct page *page,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (!plat_device_is_coherent(dev)) {
+		unsigned long addr;
+
+		addr = (unsigned long) page_address(page) + offset;
+//		dma_cache_wback_inv(addr, size);
+		__dma_sync(addr, size, direction);
+	}
+
+	return plat_map_dma_mem_page(dev, page) + offset;
+}
+
+EXPORT_SYMBOL(dma_map_page);
+
+void dma_unmap_page(struct device *dev, dma_addr_t dma_address, size_t size,
+	enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (!plat_device_is_coherent(dev) && direction != DMA_TO_DEVICE) {
+		unsigned long addr;
+
+		addr = plat_dma_addr_to_phys(dma_address);
+//		dma_cache_wback_inv(addr, size);
+		__dma_sync(addr, size, direction);
+	}
+
+	plat_unmap_dma_mem(dma_address);
+}
+
+EXPORT_SYMBOL(dma_unmap_page);
+
+void dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
+	size_t size, enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (cpu_is_noncoherent_r10000(dev)) {
+		unsigned long addr;
+
+		addr = dma_addr_to_virt(dma_handle);
+		__dma_sync(addr, size, direction);
+	}
+}
+
+EXPORT_SYMBOL(dma_sync_single_for_cpu);
+
+void dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,
+	size_t size, enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (!plat_device_is_coherent(dev)) {
+		unsigned long addr;
+
+		addr = dma_addr_to_virt(dma_handle);
+		__dma_sync(addr, size, direction);
+	}
+}
+
+EXPORT_SYMBOL(dma_sync_single_for_device);
+
+void dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t dma_handle,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (cpu_is_noncoherent_r10000(dev)) {
+		unsigned long addr;
+
+		addr = dma_addr_to_virt(dma_handle);
+		__dma_sync(addr + offset, size, direction);
+	}
+}
+
+EXPORT_SYMBOL(dma_sync_single_range_for_cpu);
+
+void dma_sync_single_range_for_device(struct device *dev, dma_addr_t dma_handle,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (!plat_device_is_coherent(dev)) {
+		unsigned long addr;
+
+		addr = dma_addr_to_virt(dma_handle);
+		__dma_sync(addr + offset, size, direction);
+	}
+}
+
+EXPORT_SYMBOL(dma_sync_single_range_for_device);
+
+void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nelems,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	/* Make sure that gcc doesn't leave the empty loop body.  */
+	for (i = 0; i < nelems; i++, sg++) {
+		if (cpu_is_noncoherent_r10000(dev))
+			__dma_sync((unsigned long)page_address(sg->page),
+			           sg->length, direction);
+		plat_unmap_dma_mem(sg->dma_address);
+	}
+}
+
+EXPORT_SYMBOL(dma_sync_sg_for_cpu);
+
+void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nelems,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	/* Make sure that gcc doesn't leave the empty loop body.  */
+	for (i = 0; i < nelems; i++, sg++) {
+		if (!plat_device_is_coherent(dev))
+			__dma_sync((unsigned long)page_address(sg->page),
+			           sg->length, direction);
+		plat_unmap_dma_mem(sg->dma_address);
+	}
+}
+
+EXPORT_SYMBOL(dma_sync_sg_for_device);
+
+int dma_mapping_error(dma_addr_t dma_addr)
+{
+	return (dma_addr == 0) ? 1 : 0;
+}
+
+EXPORT_SYMBOL(dma_mapping_error);
+
+int dma_supported(struct device *dev, u64 mask)
+{
+	/*
+	 * we fall back to GFP_DMA when the mask isn't all 1s,
+	 * so we can't guarantee allocations that must be
+	 * within a tighter range than GFP_DMA..
+	 */
+	if (mask < 0x00ffffff)
+		return 0;
+
+	return 1;
+}
+
+EXPORT_SYMBOL(dma_supported);
+
+int dma_is_consistent(struct device *dev, dma_addr_t dma_addr)
+{
+	return plat_device_is_coherent(dev);
+}
+
+EXPORT_SYMBOL(dma_is_consistent);
+
+void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+	       enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (!plat_device_is_coherent(dev))
+		dma_cache_wback_inv((unsigned long)vaddr, size);
+}
+
+EXPORT_SYMBOL(dma_cache_sync);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/pci/fixup-tangox.c linux-2.6.22.19/arch/mips/pci/fixup-tangox.c
--- linux-2.6.22.19.ref/arch/mips/pci/fixup-tangox.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/pci/fixup-tangox.c	2009-04-20 09:05:13.000000000 -0700
@@ -0,0 +1,59 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ *********************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_pci.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_pci.h>
+#endif
+
+extern int tangox_pcidev_irq_map(int pci_idsel, int int_num);
+
+int pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	/* return xenv config */
+	return tangox_pcidev_irq_map(slot, pin);
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+/*
+ * final fixup for our pci bus, called after all resource allocation.
+ */
+static void tangox_fixup(struct pci_dev *dev)
+{
+	dev->dev.platform_data = 0;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, tangox_fixup);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/pci/Makefile linux-2.6.22.19/arch/mips/pci/Makefile
--- linux-2.6.22.19.ref/arch/mips/pci/Makefile	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/arch/mips/pci/Makefile	2009-04-20 09:05:13.000000000 -0700
@@ -50,3 +50,4 @@
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
+obj-$(CONFIG_TANGOX)          += pci-tangox.o fixup-tangox.o ops-tangox.o
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/pci/ops-tangox.c linux-2.6.22.19/arch/mips/pci/ops-tangox.c
--- linux-2.6.22.19.ref/arch/mips/pci/ops-tangox.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/pci/ops-tangox.c	2009-04-20 09:05:13.000000000 -0700
@@ -0,0 +1,136 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ *********************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2_pci.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_pci.h>
+#endif
+
+/*
+ * remapped address to access config space from kernel
+ */
+void __iomem *tangox_pci_config_base;
+
+/*
+ * list of devices for which we allow configuration access
+ */
+int enabled_devices[PCIEM86XX_IDSEL_MAX];
+
+/*
+ * find cfg address to use for given bus/device/Address
+ */
+#define CFG_ADDR(bus,devfn,where)	\
+	(tangox_pci_config_base + (((bus) << 16) + ((devfn) << 8) + (where)))
+
+/*
+ * read/write callbacks for pci configuration memory access
+ */
+int tangox_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+			int where, int size, u32 *val)
+{
+	void __iomem *addr = CFG_ADDR(bus->number, devfn, where);
+	int ret, slot;
+
+	slot = PCI_SLOT(devfn);
+
+	/*
+	 * check that it is ok to use this slot
+	 */
+	if (!enabled_devices[slot] || slot >= PCIEM86XX_IDSEL_MAX)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	 * reject silly sizes
+	 */
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	switch (size) {
+	case 1:
+		ret = tangox_cfg_read8(addr, val);
+		break;
+
+	case 2:
+		ret = tangox_cfg_read16(addr, val);
+		break;
+
+	default:
+		ret = tangox_cfg_read32(addr, val);
+		break;
+	}
+
+	return ret;
+}
+
+int tangox_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+			 int where, int size, u32 val)
+{
+	void __iomem *addr = CFG_ADDR(bus->number, devfn, where);
+	int ret, slot;
+
+	slot = PCI_SLOT(devfn);
+
+	/*
+	 * check that it is ok to use this slot
+	 */
+	if (!enabled_devices[slot] || slot >= PCIEM86XX_IDSEL_MAX)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	 * reject silly sizes
+	 */
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	switch (size) {
+	case 1:
+		ret = tangox_cfg_write8(addr, &val);
+		break;
+
+	case 2:
+		ret = tangox_cfg_write16(addr, &val);
+		break;
+
+	default:
+		ret = tangox_cfg_write32(addr, &val);
+		break;
+	}
+
+	return ret;
+}
+
+struct pci_ops tangox_pci_ops = {
+	.read = tangox_pcibios_read,
+	.write = tangox_pcibios_write,
+};
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/pci/pci.c linux-2.6.22.19/arch/mips/pci/pci.c
--- linux-2.6.22.19.ref/arch/mips/pci/pci.c	2009-04-20 09:02:22.000000000 -0700
+++ linux-2.6.22.19/arch/mips/pci/pci.c	2009-04-20 09:05:52.000000000 -0700
@@ -324,10 +324,10 @@
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif
 
+int pci_enabled = 1; 
+
 char *pcibios_setup(char *str)
 {
-	extern int pci_enabled;
-
 	if (strcmp(str, "disabled") == 0) {
 		pci_enabled = 0;
 		return(NULL);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/pci/pci-tangox.c linux-2.6.22.19/arch/mips/pci/pci-tangox.c
--- linux-2.6.22.19.ref/arch/mips/pci/pci-tangox.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/arch/mips/pci/pci-tangox.c	2009-04-20 09:05:38.000000000 -0700
@@ -0,0 +1,433 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ *********************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/pci.h>
+#include <asm/dma.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_pci.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_pci.h>
+#endif
+
+#include <asm/cacheflush.h>
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+/*
+ * pci addresses used by dma subsystem
+ */
+unsigned long g_pcimem_busaddr;
+unsigned long g_pcimem_physaddr;
+unsigned long g_pcimem_physaddr_end;
+
+void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen);
+//void pci_iounmap(struct pci_dev *dev, void __iomem *addr);
+unsigned char *__unused_ptr1__ = (unsigned char *)pci_iomap;
+//unsigned char *__unused_ptr2__ = (unsigned char *)pci_iounmap;
+
+/*
+ * We can't  touch iospace directly from  kseg1, we need  to remap it.
+ * No  need to  remap too  much space,  only 256  bytes per  device is
+ * allowed, so 64k should be more than enough.
+ */
+#define MEMORY_SIZE_PCI_IO			(64 * 1024)
+
+static struct resource tangox_pci_io_resource = {
+	.name   = "tangox pci IO space",
+ 	.start  = MEMORY_BASE_PCI_IO,
+ 	.end    = MEMORY_BASE_PCI_IO + MEMORY_SIZE_PCI_IO - 1,
+	.flags  = IORESOURCE_IO
+};
+
+/*
+ * give 512MB for PCI memory space
+ */
+static struct resource tangox_pci_mem_resource = {
+        .name   = "tangox pci memory space",
+        .start  = MEMORY_BASE_PCI_MEMORY + 0x02000000, /* from 32MB offset */
+        .end    = MEMORY_BASE_PCI_MEMORY + 0x1fffffff,
+        .flags  = IORESOURCE_MEM
+};
+
+
+/*
+ * Need to  remap config  space to access  it from kernel.   Note that
+ * remap size is just enough for PCIEM86XX_IDSEL_MAX devices on 1 bus.
+ */
+#define MEMORY_SIZE_PCI_CONFIG	(PCIEM86XX_IDSEL_MAX * (1 << 11))
+
+/*
+ * in ops-tangox.c
+ */
+extern void __iomem *tangox_pci_config_base;
+extern struct pci_ops tangox_pci_ops;
+extern int enabled_devices[PCIEM86XX_IDSEL_MAX];
+
+struct pci_controller tangox_controller = {
+        .pci_ops        = &tangox_pci_ops,
+        .io_resource    = &tangox_pci_io_resource,
+        .mem_resource   = &tangox_pci_mem_resource,
+
+	/*
+	 * gbus  addresses are  not the  same as  pci  addresses, tell
+	 * Linux about this so it can adjust resource addresses.
+	 */
+	.mem_offset	= MEMORY_BASE_PCI_MEMORY,
+	.io_offset	= MEMORY_BASE_PCI_CONFIG,
+};
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * This is the  interrupt handler for bus fault  interrupt. Just clear
+ * it and warn user
+ */
+static irqreturn_t pci_busfault_intr(int irq, void *devinfo)
+{
+	static const char *reasons[] = {
+		"OK", "Master Abort", "Retry timer expired", "Unknown" };
+	static int faultcount = 0;
+	unsigned int data;
+
+	data = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 3;
+	WR_HOST_REG8(PCI_host_reg2 + 3, 1);
+	WR_HOST_REG8(PCI_host_reg2 + 3, 0);
+
+	/* don't flood */
+	if (printk_ratelimit())
+		printk("PCI: PCI bus fault (count %d): %s\n",
+		       ++faultcount, reasons[data]);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * platform initialization code
+ */
+extern int tangox_pci_host_enabled(void);
+extern int tangox_pcidev_enabled(int idsel);
+extern unsigned long tangox_chip_id(void);
+
+/* can turned on/off by XENV or cmd line */
+extern int pci_enabled; 
+
+/* Status of PCI host */
+static int pci_active = 0;
+
+/* the maximum idsel */
+static int pci_idsel_max = PCIEM86XX_IDSEL_MAX;
+
+static int __init tangox_pci_init(void)
+{
+	void __iomem *pci_io_base;
+	unsigned long memsize, regsize, membase, max_dma_size, dma_addr;
+	u32 data;
+	int i;
+
+	/* don't do anything if pci support is not enabled in xenv nor is it by cmd line */
+	if (!pci_enabled) {
+		return 0;
+	} else if (!tangox_pci_host_enabled()) {
+		printk(KERN_NOTICE "PCI: pci host support disabled\n");
+		return 0;
+	} 
+
+	if (((tangox_chip_id() >> 16) & 0xfff0) == 0x8650)
+		pci_idsel_max--; /* one less for 865x */
+
+	printk("PCI: Initializing SMP86xx PCI host controller\n");
+
+	/*
+	 * Enable pci host support
+	 */
+	WR_HOST_REG32(PCI_chip_is_host, 0); /* Reset PCI host */
+	udelay(1000);
+	WR_HOST_REG32(PCI_chip_is_host, 1);
+
+	/*
+	 * HOST_REG1 :
+	 * [31:16] : # of PCI retry cycle = 0xffff (default = 0xff)
+	 * [8] : host Super Request = 0
+	 * [3:0] arbitration level = 0x00 (Level 1)
+	 */
+	WR_HOST_REG32(PCI_host_reg1, 0xffff0000 | PCIEM86XX_ARBITER_LEVEL);
+
+	/*
+	 * PCI_CTRL1 :
+	 * [17] : enable "Memory Read Multiple" and "Memory Read Line"
+	 * [16] [7:0] : enable "prefetch" for PCI slave regions 2..7
+	 * [17] : Always enabled
+	 * [18] : additional bit for Tango. Long PCI memory read burst
+	 */
+	WR_HOST_REG32(PCI_pcictrl_reg1, 0x00030000);
+
+	/*
+	 * PCI_CTRL2 :
+	 * [18] : fast back-to-back capable = 0 (default)
+	 * [17] : read FIFO level = 1 (8 level deep, default)
+	 * [16] : discard timer enable = 1 (default)
+	 * [15:8] : subs latency = 0x06 (default = 0x08)
+	 * [7:0] : initial latency = 0x0d (default = 0x0b)
+	 */
+	WR_HOST_REG32(PCI_pcictrl_reg2, 0x0003060d);
+
+	/*
+	 * PCI_CTRL3 :
+	 * [16] : slave abort clear = 0
+	 * [10:8] : abort interrupt enable = 0 (default)
+	 * [2:0] : abort status = 0
+	 */
+	WR_HOST_REG32(PCI_pcictrl_reg3, 0);
+
+	/* clear any pending PCI bus fault */
+	if ((RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3) {
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);
+	}
+
+	/* Setting pci_configuration_vld */
+	WR_HOST_REG8(PCI_host_reg2 + 2, 1);
+
+	/* grant timeout */
+	WR_HOST_REG32(PCI_host_reg3, PCIEM86XX_ARBITER_GRANTTIMEOUT);
+	WR_HOST_REG32(PCI_host_reg5,
+		      PCIEM86XX_ARBITER_GRANTTIMEOUT & 0x000000ff);
+
+	/* initialize arbiter */
+	WR_HOST_REG32(PCI_host_reg4, 0);
+
+
+	/*
+	 * remap iorange and give port base to linux.
+	 */
+	pci_io_base = ioremap(MEMORY_BASE_PCI_IO, MEMORY_SIZE_PCI_IO);
+	set_io_port_base((unsigned long)pci_io_base - MEMORY_BASE_PCI_IO);
+
+	tangox_controller.io_map_base = (unsigned long)pci_io_base;
+
+	printk("PCI: Remapped PCI I/O space 0x%08lx to 0x%p, size %u kB\n",
+	       MEMORY_BASE_PCI_IO, pci_io_base, MEMORY_SIZE_PCI_IO / 1024);
+
+	/*
+	 * remap configuration space also
+	 */
+	tangox_pci_config_base = ioremap(MEMORY_BASE_PCI_CONFIG,
+					 MEMORY_SIZE_PCI_CONFIG);
+
+	printk("PCI: Remapped PCI config space 0x%08lx to 0x%p, size %u kB\n",
+	       MEMORY_BASE_PCI_CONFIG, tangox_pci_config_base,
+	       MEMORY_SIZE_PCI_CONFIG / 1024);
+
+	memset(&enabled_devices, 0, sizeof (enabled_devices));
+	for (i = 1; i < pci_idsel_max; i++) {
+		if (tangox_pcidev_enabled(i)) {
+			enabled_devices[i] = 1;
+		} else {
+			printk("PCI: device %d disabled\n", i);
+		}
+	}
+
+	/*
+	 * check that we can probe the EM8XXX at id 0
+	 */
+	if (tangox_cfg_read32(tangox_pci_config_base, &data)) {
+		printk("PCI: Can't initialize EM86XX as a PCI slave\n");
+		memset(&enabled_devices, 0, sizeof (enabled_devices));
+		return 1;
+	}
+
+	/*
+	 * configure it as a PCI slave
+	 *
+	 * set PCI memory size to maximum, so the PCI memory will cover the
+	 * whole memory if the total DRAM size is smaller than 112MB/896MB (Tango2/Tango3).
+	 * For Tango2, maximum = 128MB => 16MB per region => DMA memory = 16 * 7 = 112MB
+	 * For Tango3, maximum = 1024MB => 128MB per region => DMA memory = 128 * 7 = 896MB
+	 * But the current code doesn't care 2nd DRAM controller.
+	 */
+	WR_HOST_REG8(PCI_REG3, MAX_LOG2_PCIMEM_MAP);
+
+	memsize = RD_HOST_REG32(PCI_REG3) & 0x07;
+
+#ifdef CONFIG_TANGO2
+	memsize = 1 << memsize;  /* from 1MB to 128MB */
+#elif defined(CONFIG_TANGO3)
+	memsize = 1 << (memsize + 3); /* from 8MB to 1024MB */
+#else
+#error Unsupported chip!
+#endif
+
+	/* get memory size in bytes / 8 */
+	regsize = (memsize << 20) >> 3; /* regsize in MB */
+
+	/* pci command */
+	__raw_writew(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER,
+		     (void *)(tangox_pci_config_base + PCI_COMMAND));
+
+	/* base address 0 */
+	g_pcimem_busaddr = PCIBIOS_MIN_MEM_EM86XX - MEMORY_BASE_PCI_MEMORY;
+	__raw_writel(g_pcimem_busaddr,
+		     (void *)(tangox_pci_config_base + PCI_BASE_ADDRESS_0));
+
+	/*
+	 * PCI slave access
+	 * region 0 (R) : Configuration area
+	 * region 1 - 7: mapped to DRAM starting from DRAM_BASE */
+	g_pcimem_busaddr += (regsize * 1);
+	printk("PCI: Configured SMP86xx as PCI slave with %ldMB "
+	       "PCI memory\n", memsize);
+	membase = CPHYSADDR(em8xxx_kmem_start);
+	max_dma_size = (unsigned long)MAX_DMA_ADDRESS - em8xxx_kmem_start;
+	g_pcimem_physaddr = membase;
+	g_pcimem_physaddr_end = g_pcimem_physaddr + em8xxx_kmem_size;
+
+	dma_addr = tangox_dma_address(CPHYSADDR(membase));
+	for (i = 1; (i < 8) && (max_dma_size > 0); ++i) {
+		/* PCI region base registers should contain low address */
+		WR_HOST_REG32(PCI_REGION_0_BASE + (i * 4), dma_addr);
+		membase += regsize; 
+		max_dma_size -= regsize;
+		dma_addr += regsize;
+	}
+
+	if (g_pcimem_physaddr_end > membase)
+		g_pcimem_physaddr_end = membase;
+        printk("PCI: Region size is %ldKB\n", regsize >> 10);
+        printk("PCI: Map DMA memory 0x%08lx-0x%08lx for PCI at 0x%08lx\n",
+	       g_pcimem_physaddr, g_pcimem_physaddr_end, g_pcimem_busaddr);
+
+	/*
+	 * register the PCI bus fault interrupt
+	 */
+	if (request_irq(PCIEM86XX_PCIFAULT_INTR, pci_busfault_intr,
+		    IRQF_SHARED, "tangox_pci_fault", &tangox_controller) != 0) {
+		printk("PCI: fail to register PCI fault ISR(%d)\n", PCIEM86XX_PCIFAULT_INTR);
+		return 0;
+	}
+
+	/* finally register pci controller */
+	register_pci_controller(&tangox_controller);
+
+	pci_active = 1;
+
+	return 0;
+}
+
+arch_initcall(tangox_pci_init);
+
+/* For shutting down all PCI devices on this bus */
+void tangox_pci_shutdown(void)
+{
+	struct pci_bus *bus = tangox_controller.bus;
+        struct list_head *list;
+
+	if (pci_active && bus) {
+		list_for_each(list, &bus->devices) {
+			pci_disable_device(pci_dev_b(list));
+		}
+	}
+}
+
+int
+pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+
+	if (em8xxx_kmem_size > (MAX_PCIMEM_MAP_SIZE << 20)) {
+#if defined(CONFIG_TANGO2)
+		dev->dma_mask = mask & 0x07ffffff;
+#elif defined(CONFIG_TANGO3)
+		dev->dma_mask = mask & 0x3fffffff;
+#else
+		dev->dma_mask = mask;
+#endif
+	} else
+		dev->dma_mask = mask;
+
+	return 0;
+}
+    
+int
+pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+
+	if (em8xxx_kmem_size > (MAX_PCIMEM_MAP_SIZE << 20)) {
+#if defined(CONFIG_TANGO2)
+		dev->dev.coherent_dma_mask = mask & 0x07ffffff;
+#elif defined(CONFIG_TANGO3)
+		dev->dev.coherent_dma_mask = mask & 0x3fffffff;
+#else
+		dev->dev.coherent_dma_mask = mask;
+#endif
+	} else
+		dev->dev.coherent_dma_mask = mask;
+
+	return 0;
+}
+
+void tangox_pci_enable(void)
+{
+	struct pci_bus *bus = tangox_controller.bus;
+        struct list_head *list;
+
+	if (pci_active) {
+		list_for_each(list, &bus->devices) {
+			pci_set_master(pci_dev_b(list));
+		}
+	}
+}
+
+EXPORT_SYMBOL(tangox_pci_shutdown);
+EXPORT_SYMBOL(tangox_pci_enable);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/arch/mips/tangox/prom.c linux-2.6.22.19/arch/mips/tangox/prom.c
--- linux-2.6.22.19.ref/arch/mips/tangox/prom.c	2009-04-20 09:02:22.000000000 -0700
+++ linux-2.6.22.19/arch/mips/tangox/prom.c	2009-04-20 09:05:13.000000000 -0700
@@ -11,6 +11,7 @@
 #include <linux/init.h>
 #include <asm/bootinfo.h>
 #include <asm/page.h>
+#include <asm/cacheflush.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 
@@ -645,6 +646,12 @@
 	return(is_tango3_revision(0x5));
 }
 
+void tangox_flush_cache_all(void)
+{
+	flush_cache_all();
+}
+
+EXPORT_SYMBOL(tangox_flush_cache_all);
 EXPORT_SYMBOL(tangox_chip_id);
 EXPORT_SYMBOL(is_tango2_chip);
 EXPORT_SYMBOL(is_tango3_chip);
@@ -680,3 +687,67 @@
   
 EXPORT_SYMBOL(tangox_do_timer);
 
+#ifdef CONFIG_SD_DIRECT_DMA
+
+/* Given an address and length, determine if this area is physically contiguous or not, and
+   return the physical address of starting point, caller needs to ensure the page_table is
+   locked so no change is allowed. */
+int is_contiguous_memory(void __user *userbuf, unsigned int len, unsigned long *physaddr)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	unsigned long start = (unsigned long)userbuf;
+	unsigned long paddr, ppaddr;
+	unsigned long start_pg_addr, start_pg_offset, end_pg_addr, pg_addr;
+	struct mm_struct *mm = current->mm;
+	int ret = 0;
+
+//printk("%s:%d: start=0x%08lx, len=0x%x\n", __FILE__, __LINE__, start, len);
+
+	*physaddr = 0;
+	start_pg_addr = start & PAGE_MASK; /* address of start page */
+	start_pg_offset = start & (PAGE_SIZE - 1); /* offset within start page */
+	end_pg_addr = ((start + len) & PAGE_MASK) - (((start + len) & (PAGE_SIZE - 1)) ? 0 : PAGE_SIZE); /* address of last page */
+
+	for (ppaddr = 0, pg_addr = start_pg_addr; pg_addr <= end_pg_addr; pg_addr += PAGE_SIZE) {
+		if (pg_addr > TASK_SIZE)
+			pgd = pgd_offset_k(pg_addr);
+		else
+			pgd = pgd_offset_gate(mm, pg_addr);
+		BUG_ON(pgd_none(*pgd));
+		pud = pud_offset(pgd, pg_addr);
+		BUG_ON(pud_none(*pud));
+		pmd = pmd_offset(pud, pg_addr);
+		if (pmd_none(*pmd)) 
+			goto error;
+		pte = pte_offset_map(pmd, pg_addr);
+		if (pte_none(*pte)) {
+			pte_unmap(pte);
+			goto error;
+		}
+		paddr = pte_val(*pte) & PAGE_MASK;
+//printk("TRANSLATED 0x%08lx, pte=0x%p, paddr=0x%lx\n", pg, pte, paddr);
+		pte_unmap(pte);
+
+		if (ppaddr == 0) { /* first page */
+			ppaddr = paddr;
+			*physaddr = (ppaddr | start_pg_offset);
+		} else if ((ppaddr + PAGE_SIZE) != paddr) /* not contiguous */
+			goto not_contiguous;
+		else
+			ppaddr = paddr;
+	}
+	ret = 1;
+
+not_contiguous:
+error:
+//printk("%s:%d: return %d\n", __FILE__, __LINE__, ret);
+	return ret;
+}
+
+EXPORT_SYMBOL(is_contiguous_memory);
+
+#endif /* CONFIG_SD_DIRECT_DMA */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/block/ll_rw_blk.c linux-2.6.22.19/block/ll_rw_blk.c
--- linux-2.6.22.19.ref/block/ll_rw_blk.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/block/ll_rw_blk.c	2009-04-20 09:05:13.000000000 -0700
@@ -31,6 +31,10 @@
 #include <linux/blktrace_api.h>
 #include <linux/fault-inject.h>
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+#include <scsi/sg.h>
+#endif
+
 /*
  * for max sense size
  */
@@ -2330,10 +2334,19 @@
 	int ret = 0;
 
 	if (bio) {
-		if (bio_flagged(bio, BIO_USER_MAPPED))
-			bio_unmap_user(bio);
-		else
-			ret = bio_uncopy_user(bio);
+#ifdef CONFIG_SD_DIRECT_DMA
+		if (bio_flagged(bio, BIO_PHYSICAL)) {
+			up_read(&current->mm->mmap_sem); 
+			kfree(bio);
+		} else {
+#endif
+			if (bio_flagged(bio, BIO_USER_MAPPED))
+				bio_unmap_user(bio);
+			else
+				ret = bio_uncopy_user(bio);
+#ifdef CONFIG_SD_DIRECT_DMA
+		}
+#endif
 	}
 
 	return ret;
@@ -2345,18 +2358,65 @@
 	unsigned long uaddr;
 	struct bio *bio, *orig_bio;
 	int reading, ret;
+        int dma_alignment = 0;
 
+#ifdef CONFIG_SD_DIRECT_DMA
+        extern int is_contiguous_memory(void __user *userbuf, unsigned int len, unsigned long *paddr);
+        unsigned long paddr;
+        struct gendisk *disk = rq->rq_disk;
+#endif
 	reading = rq_data_dir(rq) == READ;
 
+        if (reading) {
+                if (!access_ok(VERIFY_WRITE, (void __user *)ubuf, len))
+                        return -EFAULT;
+        } else if (!access_ok(VERIFY_READ, (void __user *)ubuf, len))
+                return -EFAULT;
+
 	/*
 	 * if alignment requirement is satisfied, map in user pages for
 	 * direct dma. else, set up kernel bounce buffers
 	 */
 	uaddr = (unsigned long) ubuf;
-	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
-		bio = bio_map_user(q, NULL, uaddr, len, reading);
-	else
-		bio = bio_copy_user(q, uaddr, len, reading);
+        dma_alignment = queue_dma_alignment(q);
+
+        if (((uaddr & dma_alignment) == 0) && ((len & dma_alignment) == 0)) {
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+                if (reading)
+                        dma_cache_inv(uaddr, len);
+                else
+                        dma_cache_wback_inv(uaddr, len);
+#endif
+#ifdef CONFIG_SD_DIRECT_DMA
+                down_read(&current->mm->mmap_sem); /* lock the page table */
+                if ((len >= (128 * 1024)) && (is_contiguous_memory(ubuf, len, &paddr) != 0) &&
+                    (disk->major == IDE0_MAJOR)) { /* Only with Sigma's IDE interface */
+
+                        bio = kmalloc(sizeof(struct bio), GFP_KERNEL);
+                        if (bio == NULL)
+                                return -ENOMEM;
+
+                        memset(bio, 0, sizeof(struct bio));
+                        bio->bi_flags |= (1<<BIO_PHYSICAL);
+                        bio->bi_rw = (reading ? 0 : 1) | BIO_RW_SYNC;
+                        bio->bi_size = len;
+                        bio->bi_io_vec = (void *)ubuf;
+
+                        /* to carry physical addr to ide driver */
+                        bio->bi_private = (void *)paddr;
+                } else {
+                        up_read(&current->mm->mmap_sem); /* unlock the table since DDMA is not used */
+#endif
+                bio = bio_map_user(q, NULL, uaddr, len, reading);
+                if (IS_ERR(bio)) {
+                        /* the map operation failed, use copy instead */
+                        bio = bio_copy_user(q, uaddr, len, reading);
+                }
+#ifdef CONFIG_SD_DIRECT_DMA
+                }
+#endif
+        } else
+                bio = bio_copy_user(q, uaddr, len, reading);
 
 	if (IS_ERR(bio))
 		return PTR_ERR(bio);
@@ -2482,11 +2542,23 @@
 int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
 			struct sg_iovec *iov, int iov_count, unsigned int len)
 {
+	int i;
 	struct bio *bio;
 
 	if (!iov || iov_count <= 0)
 		return -EINVAL;
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+	for (i = 0; i < iov_count; i++) {
+		if (iov[i].iov_len) {
+			if (rq_data_dir(rq) == READ) 
+				dma_cache_inv((unsigned long)iov[i].iov_base, iov[i].iov_len);
+			else 
+				dma_cache_wback_inv((unsigned long)iov[i].iov_base, iov[i].iov_len);
+		}
+	}
+#endif
+
 	/* we don't allow misaligned data like bio_map_user() does.  If the
 	 * user is using sg, they're expected to know the alignment constraints
 	 * and respect them accordingly */
@@ -3671,6 +3743,19 @@
 {
 	/* first two bits are identical in rq->cmd_flags and bio->bi_rw */
 	rq->cmd_flags |= (bio->bi_rw & 3);
+#ifdef CONFIG_SD_DIRECT_DMA
+        if (bio_flagged(bio, BIO_PHYSICAL)) {
+                rq->nr_phys_segments = 1;
+                rq->nr_hw_segments = 1;
+                rq->current_nr_sectors = bio_cur_sectors(bio);
+                rq->hard_cur_sectors = rq->current_nr_sectors;
+                rq->hard_nr_sectors = rq->nr_sectors = bio_sectors(bio);
+                rq->buffer = bio_data(bio);
+
+                /*elevator doesn't know about this request*/
+                rq->cmd_flags &= ~REQ_SORTED;
+        } else {
+#endif
 
 	rq->nr_phys_segments = bio_phys_segments(q, bio);
 	rq->nr_hw_segments = bio_hw_segments(q, bio);
@@ -3679,7 +3764,9 @@
 	rq->hard_nr_sectors = rq->nr_sectors = bio_sectors(bio);
 	rq->buffer = bio_data(bio);
 	rq->data_len = bio->bi_size;
-
+#ifdef CONFIG_SD_DIRECT_DMA
+        }
+#endif
 	rq->bio = rq->biotail = bio;
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/block/scsi_ioctl.c linux-2.6.22.19/block/scsi_ioctl.c
--- linux-2.6.22.19.ref/block/scsi_ioctl.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/block/scsi_ioctl.c	2009-04-20 09:05:13.000000000 -0700
@@ -280,6 +280,10 @@
 	if (!rq->timeout)
 		rq->timeout = BLK_DEFAULT_TIMEOUT;
 
+#ifdef CONFIG_SD_DIRECT_DMA
+	rq->rq_disk = bd_disk;
+#endif
+
 	if (hdr->iovec_count) {
 		const int size = sizeof(struct sg_iovec) * hdr->iovec_count;
 		struct sg_iovec *iov;
@@ -503,7 +507,10 @@
 	rq->data_len = 0;
 	rq->timeout = BLK_DEFAULT_TIMEOUT;
 	memset(rq->cmd, 0, sizeof(rq->cmd));
-	rq->cmd[0] = cmd;
+	rq->cmd[0] = cmd & 0xff;
+	rq->cmd[1] = (cmd >> 8) & 0xff;
+	rq->cmd[2] = (cmd >> 16) & 0xff;
+	rq->cmd[3] = (cmd >> 24) & 0xff;
 	rq->cmd[4] = data;
 	rq->cmd_len = 6;
 	err = blk_execute_rq(q, bd_disk, rq, 0);
@@ -514,7 +521,7 @@
 
 static inline int blk_send_start_stop(request_queue_t *q, struct gendisk *bd_disk, int data)
 {
-	return __blk_send_generic(q, bd_disk, GPCMD_START_STOP_UNIT, data);
+	return __blk_send_generic(q, bd_disk, GPCMD_START_STOP_UNIT | 0x100 /* immed */, data);
 }
 
 int scsi_cmd_ioctl(struct file *file, struct gendisk *bd_disk, unsigned int cmd, void __user *arg)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/drivers/pci/quirks.c linux-2.6.22.19/drivers/pci/quirks.c
--- linux-2.6.22.19.ref/drivers/pci/quirks.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/drivers/pci/quirks.c	2009-04-20 09:05:13.000000000 -0700
@@ -34,6 +34,13 @@
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX,PCI_DEVICE_ID_MELLANOX_TAVOR,quirk_mellanox_tavor);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX,PCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGE,quirk_mellanox_tavor);
 
+int pci_pci_problems = 0;
+int isa_dma_bridge_buggy = 0;		/* Exported */
+int pcie_mch_quirk = 0;
+
+/* For Sigma Designs' TangoX, no quirks should be needed, at least for now */
+#ifndef CONFIG_TANGOX
+
 /* Deal with broken BIOS'es that neglect to enable passive release,
    which can cause problems in combination with the 82441FX/PPro MTRRs */
 static void quirk_passive_release(struct pci_dev *dev)
@@ -1321,6 +1328,7 @@
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_E7320_MCH,	quirk_pcie_mch );
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_E7525_MCH,	quirk_pcie_mch );
 
+#endif /* !CONFIG_TANGOX */
 
 /*
  * It's possible for the MSI to get corrupted if shpc and acpi
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/fs/direct-io.c linux-2.6.22.19/fs/direct-io.c
--- linux-2.6.22.19.ref/fs/direct-io.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/fs/direct-io.c	2009-04-20 09:05:13.000000000 -0700
@@ -1009,6 +1009,14 @@
 		user_addr = (unsigned long)iov[seg].iov_base;
 		dio->size += bytes = iov[seg].iov_len;
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+		if (bytes) {
+			if (rw == WRITE)
+				dma_cache_wback_inv(user_addr, bytes);
+			else
+				dma_cache_inv(user_addr, bytes);
+		}
+#endif
 		/* Index into the first page of the first block */
 		dio->first_block_in_page = (user_addr & ~PAGE_MASK) >> blkbits;
 		dio->final_block_in_request = dio->block_in_file +
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/io.h linux-2.6.22.19/include/asm-mips/io.h
--- linux-2.6.22.19.ref/include/asm-mips/io.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/io.h	2009-04-20 09:05:13.000000000 -0700
@@ -327,6 +327,7 @@
 			local_irq_restore(__flags);			\
 	} else								\
 		BUG();							\
+	__sync();                                                       \
 }									\
 									\
 static inline type pfx##read##bwlq(const volatile void __iomem *mem)	\
@@ -368,7 +369,7 @@
 	volatile type *__addr;						\
 	type __val;							\
 									\
-	__addr = (void *)__swizzle_addr_##bwlq(mips_io_port_base + port); \
+	__addr = (void *)(mips_io_port_base + __swizzle_addr_##bwlq(port)); \
 									\
 	__val = pfx##ioswab##bwlq(__addr, val);				\
 									\
@@ -376,6 +377,7 @@
 	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
 									\
 	*__addr = __val;						\
+	__sync();                                                       \
 	slow;								\
 }									\
 									\
@@ -384,7 +386,7 @@
 	volatile type *__addr;						\
 	type __val;							\
 									\
-	__addr = (void *)__swizzle_addr_##bwlq(mips_io_port_base + port); \
+	__addr = (void *)(mips_io_port_base + __swizzle_addr_##bwlq(port)); \
 									\
 	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
 									\
@@ -517,6 +519,35 @@
 {
 	memcpy((void __force *) dst, src, count);
 }
+#if 0
+/*
+ * Memory Mapped I/O
+ */
+#define ioread8(addr)           readb(addr)
+#define ioread16(addr)          readw(addr)
+#define ioread32(addr)          readl(addr)
+
+#define iowrite8(b,addr)        writeb(b,addr)
+#define iowrite16(w,addr)       writew(w,addr)
+#define iowrite32(l,addr)       writel(l,addr)
+
+#define ioread8_rep(a,b,c)      readsb(a,b,c)
+#define ioread16_rep(a,b,c)     readsw(a,b,c)
+#define ioread32_rep(a,b,c)     readsl(a,b,c)
+
+#define iowrite8_rep(a,b,c)     writesb(a,b,c)
+#define iowrite16_rep(a,b,c)    writesw(a,b,c)
+#define iowrite32_rep(a,b,c)    writesl(a,b,c)
+#endif
+/* Create a virtual mapping cookie for an IO port range */
+extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void __iomem *);
+
+/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
+struct pci_dev;
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long
+			       max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
 
 /*
  * ISA space is 'always mapped' on currently supported MIPS systems, no need
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango2/tango2_pci.h linux-2.6.22.19/include/asm-mips/tango2/tango2_pci.h
--- linux-2.6.22.19.ref/include/asm-mips/tango2/tango2_pci.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango2/tango2_pci.h	2009-04-20 09:05:13.000000000 -0700
@@ -0,0 +1,75 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_PCI_H
+#define __TANGO2_PCI_H
+
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+
+#define PCIEM86XX_PCIFAULT_INTR		((IRQ_CONTROLLER_IRQ_BASE) + \
+						(LOG2_CPU_PCI_FAULT_INT))
+
+#define PCIEM86XX_ARBITER_LEVEL		0x00
+#define PCIEM86XX_ARBITER_GRANTTIMEOUT	0x10101010
+
+#define PCIEM86XX_IDSEL_MAX		0x05
+#define PCIEM86XX_IDSEL_BITS		0x03
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * read/write data  from/to the configuration space.  The  only way to
+ * know if there is a device is by checking that we did not generate a
+ * bus fault interrupt, so we need to mask them during the access.
+ */
+#define BUILD_TANGOX_CFG_ACCESS(pfx, __x)				\
+static inline int tangox_cfg_##pfx(void __iomem *addr, u32 *data)	\
+{									\
+	unsigned long flags, status;					\
+									\
+	local_irq_save(flags);						\
+									\
+	__x;								\
+	status = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3;		\
+	if (status) {							\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);			\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);			\
+		local_irq_restore(flags);				\
+		return 1;						\
+	}								\
+									\
+	local_irq_restore(flags);					\
+	return 0;							\
+}
+
+BUILD_TANGOX_CFG_ACCESS(read8, *data = readb(addr) & 0xff)
+BUILD_TANGOX_CFG_ACCESS(read16, *data = readw(addr) & 0xffff)
+BUILD_TANGOX_CFG_ACCESS(read32, *data = readl(addr))
+BUILD_TANGOX_CFG_ACCESS(write8, writeb(*data & 0xff, addr))
+BUILD_TANGOX_CFG_ACCESS(write16, writew(*data & 0xffff, addr))
+BUILD_TANGOX_CFG_ACCESS(write32, writel(*data, addr))
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/asm-mips/tango3/tango3_pci.h linux-2.6.22.19/include/asm-mips/tango3/tango3_pci.h
--- linux-2.6.22.19.ref/include/asm-mips/tango3/tango3_pci.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/include/asm-mips/tango3/tango3_pci.h	2009-04-20 09:05:13.000000000 -0700
@@ -0,0 +1,75 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_PCI_H
+#define __TANGO3_PCI_H
+
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+
+#define PCIEM86XX_PCIFAULT_INTR		((IRQ_CONTROLLER_IRQ_BASE) + \
+						(LOG2_CPU_PCI_FAULT_INT))
+
+#define PCIEM86XX_ARBITER_LEVEL		0x00
+#define PCIEM86XX_ARBITER_GRANTTIMEOUT	0x10101010
+
+#define PCIEM86XX_IDSEL_MAX		0x05 	/* SMP865x:4, SMP864x:5 */
+#define PCIEM86XX_IDSEL_BITS		0x03
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * read/write data  from/to the configuration space.  The  only way to
+ * know if there is a device is by checking that we did not generate a
+ * bus fault interrupt, so we need to mask them during the access.
+ */
+#define BUILD_TANGOX_CFG_ACCESS(pfx, __x)				\
+static inline int tangox_cfg_##pfx(void __iomem *addr, u32 *data)	\
+{									\
+	unsigned long flags, status;					\
+									\
+	local_irq_save(flags);						\
+									\
+	__x;								\
+	status = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3;		\
+	if (status) {							\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);			\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);			\
+		local_irq_restore(flags);				\
+		return 1;						\
+	}								\
+									\
+	local_irq_restore(flags);					\
+	return 0;							\
+}
+
+BUILD_TANGOX_CFG_ACCESS(read8, *data = readb(addr) & 0xff)
+BUILD_TANGOX_CFG_ACCESS(read16, *data = readw(addr) & 0xffff)
+BUILD_TANGOX_CFG_ACCESS(read32, *data = readl(addr))
+BUILD_TANGOX_CFG_ACCESS(write8, writeb(*data & 0xff, addr))
+BUILD_TANGOX_CFG_ACCESS(write16, writew(*data & 0xffff, addr))
+BUILD_TANGOX_CFG_ACCESS(write32, writel(*data, addr))
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/include/linux/bio.h linux-2.6.22.19/include/linux/bio.h
--- linux-2.6.22.19.ref/include/linux/bio.h	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/include/linux/bio.h	2009-04-20 09:05:13.000000000 -0700
@@ -125,6 +125,7 @@
 #define BIO_BOUNCED	5	/* bio is a bounce bio */
 #define BIO_USER_MAPPED 6	/* contains user pages */
 #define BIO_EOPNOTSUPP	7	/* not supported */
+#define BIO_PHYSICAL	8	/* this bio is pointing to physically contiguous space */
 #define bio_flagged(bio, flag)	((bio)->bi_flags & (1 << (flag)))
 
 /*
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/mm/highmem.c linux-2.6.22.19/mm/highmem.c
--- linux-2.6.22.19.ref/mm/highmem.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/mm/highmem.c	2009-04-20 09:05:13.000000000 -0700
@@ -191,6 +191,9 @@
 	BUG_ON(!vaddr);
 	nr = PKMAP_NR(vaddr);
 
+	if (bio_flagged(*bio_orig, BIO_PHYSICAL)) 
+		return;
+
 	/*
 	 * A count must never go down to zero
 	 * without a TLB flush!
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/mm/memory.c linux-2.6.22.19/mm/memory.c
--- linux-2.6.22.19.ref/mm/memory.c	2008-02-26 01:54:25.000000000 -0800
+++ linux-2.6.22.19/mm/memory.c	2009-04-20 09:05:13.000000000 -0700
@@ -993,6 +993,21 @@
 	vm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
 	i = 0;
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+	if (len && (current == tsk)) {
+		struct vm_area_struct *vma = find_vma(current->mm, start & PAGE_MASK);
+		if (vma && ((start & PAGE_MASK) >= vma->vm_start) && (((start & PAGE_MASK) + (len << PAGE_SHIFT)) <= vma->vm_end)) {
+			if (write) {
+				if (vma->vm_flags & VM_READ)
+					dma_cache_inv(start & PAGE_MASK, len << PAGE_SHIFT);
+			} else {
+				if (vma->vm_flags & VM_WRITE)
+					dma_cache_wback_inv(start & PAGE_MASK, len << PAGE_SHIFT);
+			}
+		}
+	}
+#endif
+
 	do {
 		struct vm_area_struct *vma;
 		unsigned int foll_flags;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.22.19.ref/README.1002.pcidma.patch linux-2.6.22.19/README.1002.pcidma.patch
--- linux-2.6.22.19.ref/README.1002.pcidma.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.22.19/README.1002.pcidma.patch	2009-04-20 09:07:02.000000000 -0700
@@ -0,0 +1,19 @@
+Feature:
+--------
+PCI host and DMA support for SMP86xx chips
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+YH Lin
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
